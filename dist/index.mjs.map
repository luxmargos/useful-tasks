{"version":3,"sources":["../src/index.ts","../src/build_cli_parser.ts","../src/useful_tasks.ts","../src/utils.ts","../src/task_data.ts","../src/loggers.ts","../src/task_utils.ts","../src/handler_sub_tasks.ts","../src/handlers.ts","../src/handler_map.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport path from 'path';\nimport { setup } from './build_cli_parser';\nimport { usefulTasks } from './useful_tasks';\nexport { usefulTasks } from './useful_tasks';\n\nconst originCwd = path.resolve(process.cwd());\nconst setupResult = setup();\nusefulTasks(originCwd, setupResult.opt, setupResult.program);","import { Command } from 'commander';\nimport path from 'path';\n\nexport const DEFAULT_CONFIG = \"useful_tasks.json\";\nexport const DEFAULT_USE_CAMEL = true;\n\nexport const CwdRestore = 'restore';\nexport const CwdKeep = 'keep';\n\nexport const cwdModes = [CwdRestore, CwdKeep] as const;\ntype CwdModeTuple = typeof cwdModes;\nexport type CwdMode = CwdModeTuple[number];\n\nconst LogLevelInfo = 'info';\nconst LogLevelDebug = 'debug';\nconst LogLevelNone = 'none';\nexport const logLevels = [LogLevelNone, LogLevelInfo, LogLevelDebug] as const;\ntype LogLevelTuple = typeof logLevels;\nexport type LogLevel = LogLevelTuple[number];\n\nexport interface Options {\n    cwd?:string;\n    config:string;\n    include?:string[];\n    includeCta?:string[];\n    exclude?:string[];\n    excludeCta?:string[];\n    camelKeys:boolean;\n    cwdMode?:CwdMode;\n    cwdModeIsContinue?:boolean;\n    logLevel?:LogLevel;\n    extraArgs?:string[];\n}\n\n\nconst argDesc = {\n    cwdMode:`Choose between ${cwdModes.map((v)=>`'${v}'`).join(' or ')}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${CwdRestore}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${CwdKeep}' mode, the CWD will remain unchanged.`\n}\n\nexport const setup = (userArgv?:string[])=> {\n    // console.log('cwd', process.cwd());\n    // console.log('argv', process.argv);\n\n    const program = new Command();\n    program.name('useful-tasks').version(process.env.npm_package_version!)\n    .option('--cwd <string>','Change working directory')\n    .option('-c, --config <string>','A path of json configuraion', DEFAULT_CONFIG)\n    .option('-i, --include <items>','Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-a, --include-cta <items>','Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-e, --exclude <items>','Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-x, --exclude-cta <items>','Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('--camel-keys <boolean>','Specify whether to use camel case for the key of the variable. If the value is true, the paramter \"--var-my-key\" will be converted to \"myKey\" otherwise it will be \"my-key\"', DEFAULT_USE_CAMEL)\n    .option('--cwd-mode <string>',argDesc.cwdMode, CwdRestore)\n    .option('--log-level <string>', `Specify the logging level as ${logLevels.join(',')}. This parameter takes higher priority than the 'json' configuration.`, LogLevelInfo)\n    .allowUnknownOption(true);\n    \n    if(userArgv !== undefined){\n        program.parse(userArgv, {from:'user'});\n    }else{\n        program.parse();\n    }\n\n    const opts = program.opts();\n    // console.log(opts);\n\n    const typedOptions = opts as Options;\n    typedOptions.include = fixStringArrayArgument(typedOptions.include);\n    typedOptions.includeCta = fixStringArrayArgument(typedOptions.includeCta);\n    typedOptions.exclude = fixStringArrayArgument(typedOptions.exclude);\n    typedOptions.excludeCta = fixStringArrayArgument(typedOptions.excludeCta);\n    \n    typedOptions.cwdModeIsContinue = typedOptions.cwdMode === CwdKeep;\n    \n    if(typedOptions.camelKeys !== undefined && typeof(typedOptions.camelKeys) === 'string'){\n        let v:string = typedOptions.camelKeys;\n        v = v.trim().toLowerCase();\n        if(v === 'false' || v === '0' || v === 'no'){\n            typedOptions.camelKeys = false;\n        }else if(v==='true' || v==='1' || v === 'yes'){\n            typedOptions.camelKeys = true;\n        }else{\n            typedOptions.camelKeys = DEFAULT_USE_CAMEL;\n        }\n    }\n    typedOptions.extraArgs = [...program.args ?? []];\n\n    // console.log(`Using options : ${JSON.stringify(typedOptions, undefined, 2)}`);\n    // console.log(`Extra arguments`, program.args);\n\n    if(typedOptions.cwd){\n        process.chdir(path.resolve(typedOptions.cwd));\n    }\n\n    // console.log(\"######################################################################\")\n\n    return {opt:typedOptions, program};\n}\n\nconst fixStringArrayArgument = (value:string|string[]|undefined, skipEmptyItem:boolean = true)=>{\n    if(!value){\n        return [];\n    }\n    \n    if(typeof value === 'string'){\n        const result:string[] = [];\n        const arr = value.split(',');\n        arr.forEach((value)=>{\n            const trimedValue = value.trim();\n            if(skipEmptyItem){\n                if(trimedValue.length > 0){\n                    result.push(trimedValue);\n                }\n            }else{\n                result.push(trimedValue);\n            }\n        });\n        return result;\n    }\n    \n    return [];\n};\n","import path from 'path';\nimport { LogLevel, Options, logLevels } from './build_cli_parser';\nimport { containsAllTag, containsTag, loadJsonConfig } from './utils';\nimport debug from 'debug';\nimport { Config, TAG_DEBUG, Task, TaskContext, DEFAULT_REPLACE_REGEX, VAR_FROM_ARGUMENT_PREFIX,  ENV_VAR_FROM_ARGUMENT_PREFIX, LOG_TAG, TAG_INFO } from './task_data';\nimport { applyVariables, searchExtraKeyValue, setTaskVar, setEnvVar } from './task_utils';\nimport { Command } from 'commander';\nimport { handlerMap } from './handler_map';\nimport { logi, logv } from './loggers';\n\nexport const usefulTasks = (originCwd:string, opt:Options, program:Command)=>{\n    let tasksConfig:Config = {};\n\n    let configFilePath = path.resolve(opt.config);\n    try{\n        tasksConfig = loadJsonConfig(configFilePath);\n    }catch(e:any){\n        if(e instanceof Error){\n            console.log(e.message);\n        }else{\n            console.log(e);\n        }\n        console.log(\"\");\n        program.help();\n    }\n    \n    let debugPat:string | undefined;\n    \n    let logLevel:LogLevel = 'info';\n    let replaceRegex = DEFAULT_REPLACE_REGEX;\n    if(tasksConfig.env && typeof(tasksConfig.env) === 'object'){\n        const env = tasksConfig.env;\n        \n        if(env.verbose || env.verboseGit){\n            logLevel = 'debug';\n        }\n\n        if(env.logLevel && logLevels.includes(env.logLevel)){\n            logLevel = env.logLevel;\n        }\n    \n        if(env.replaceRegex){\n            replaceRegex = env.replaceRegex;\n        }\n    }\n\n    //cli argument can overwrite json's logLeve\n    if(opt.logLevel && logLevels.includes(opt.logLevel)){\n        logLevel = opt.logLevel;\n    }\n\n    if(logLevel === 'debug'){\n        // debugPat = `${LOG_TAG}:*`;\n        debugPat = `${TAG_INFO},${TAG_DEBUG}`;\n        debugPat = `${debugPat},simple-git,simple-git:*`;\n    }else if(logLevel === 'info'){\n        debugPat = `${TAG_INFO}`;\n    }\n    \n    if(debugPat){\n        debug.enable(debugPat);\n    }\n\n    logv(`CLI Options`, opt);\n\n    if(typeof(replaceRegex) !== 'string'){\n        throw new Error(`replaceRegex '${replaceRegex}'  must be a string`);\n    }\n    if(replaceRegex.length < 1){\n        throw new Error(`replaceRegex '${replaceRegex}' cannot be empty`);\n    }\n    if(replaceRegex.indexOf('(') < 0 || replaceRegex.indexOf(')') < 0){\n        throw new Error(`replaceRegex '${replaceRegex}' must contain regex group express '(' and ')'`);\n    }\n    \n    const baseCwd = path.resolve(process.cwd());\n    \n    const context:TaskContext = {\n        originCwd,\n        baseCwd,\n        replaceRegex:new RegExp(replaceRegex),\n        vars:{\n            __env:{\n                cwd_startup:originCwd,\n                cwd_base:baseCwd\n            }\n        }\n    };\n    \n    if(opt.extraArgs){\n        logv(\"Setting up the variables from the additional arguments\");\n        searchExtraKeyValue(opt.extraArgs, VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\n            setTaskVar(context, key, value);\n        });\n    \n        logv(\"Setting up the environment variables from the additional arguments\");\n        searchExtraKeyValue(opt.extraArgs, ENV_VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\n            setEnvVar(context, key, value);\n        });\n    }\n    \n    logi(\"\");\n    logi(`[${tasksConfig.name}] Start task processing`);\n    \n    const getTaskRepresentStr = (task:Task, i?:number)=>{ \n        if(i !== undefined && i !== null){\n            return task.id !== undefined ? `[${i}]${task.id}/${task.type}` : `[${i}]${task.type}`;\n        }else{\n            return task.id !== undefined ? `${task.id}/${task.type}` : `${task.type}`;\n        }\n    };\n    \n    const runTasks = async ()=>{\n        let tasks:Array<Task> = tasksConfig.tasks ?? [];\n    \n        for(let i=0;i<tasks.length;i++){\n            const task = tasks[i];\n\n            // Validate task IDs\n            if(task.id !== undefined && task.id !== null){\n                if(typeof(task.id) !== 'string'){\n                    throw new Error(`The task id must be a 'string' type`);\n                }\n    \n                if(task.id.length<1){\n                    throw new Error(`The task id cannot be empty`);\n                }\n    \n                for(let j=i+1;j<tasks.length;j++){\n                    const otherTask = tasks[j];\n                    if(otherTask.id !== undefined && otherTask.id === task.id){\n                        throw new Error(`The task id '${task.id}' must be unique`);\n                    }\n                }\n            }\n\n            if(!task.type || !(task.type in handlerMap)){\n                throw new Error(`Found the invalid task type '${task.type}'`);\n            }\n            \n            task.__compare__elements = [];\n            if(task.id){\n                task.id = task.id.trim()\n                task.__compare__elements.push(task.id.trim());\n            }\n            if(task.tags){\n                const printInvalidTags = (tags:any)=>{\n                    logv(`Ignoring invalid tags '${tags}'`);\n                };\n                if(typeof(task.tags) === 'string'){\n                    if(task.tags.length > 0){\n                        task.tags = task.tags.trim();\n                        task.__compare__elements.push(task.tags);\n                    }else{\n                        printInvalidTags(task.tags);\n                    }\n                }else if(Array.isArray(task.tags)){\n                    task.tags = task.tags.map((value:string)=>value.trim());\n                    for(const tag of task.tags){\n                        if(typeof(tag) === 'string' && tag.length>0){\n                            task.__compare__elements.push(tag);\n                        }else{\n                            printInvalidTags(tag);\n                        }\n                    }\n                }else{\n                    printInvalidTags(task.tags);\n                }\n            }\n        }\n    \n        if(opt.exclude && opt.exclude.length > 0){\n            const excludeItems = opt.exclude;\n    \n            logv(`Excluding tasks by specified IDs or Tags : --exclude=${excludeItems}`);\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(containsTag(excludeItems, taskItem.__compare__elements) === false){\n                    return taskItem;\n                }\n            });\n        }\n        if(opt.excludeCta && opt.excludeCta.length > 0){\n            const excludesItems = opt.excludeCta;\n    \n            logv(`Excluding tasks by specified IDs or Tags : --exclude-cta=${excludesItems}`);\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(containsAllTag(excludesItems, taskItem.__compare__elements) === false){\n                    return taskItem;\n                }\n            });\n        }\n        const hasIncludeFilters = opt.include && opt.include.length > 0;\n        const hasIncludeCTAFilters = opt.includeCta && opt.includeCta.length > 0;\n        if(hasIncludeFilters || hasIncludeCTAFilters){\n            const includeItems = opt.include;\n            const includeCtaItems = opt.includeCta;\n    \n            logv(`Including tasks by specified IDs or Tags : --include=${includeItems} / --include-cta=${includeCtaItems}`);\n            tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(\n                    (hasIncludeFilters && containsTag(includeItems!, taskItem.__compare__elements) === true)\n                    ||\n                    (hasIncludeCTAFilters && containsAllTag(includeCtaItems!, taskItem.__compare__elements) === true)\n                ){\n                    return taskItem;\n                }\n            });\n        }\n    \n        logi(`Tasks : ${tasks.map((v,i)=>{ return getTaskRepresentStr(v,i);})}`);\n    \n        const taskCount = tasks.length ?? 0;\n        for(let i=0;i<taskCount; i++){\n            const task = tasks[i];\n            applyVariables(context, task);\n    \n            const taskRepresentStr = getTaskRepresentStr(task,i);\n            if(task.enabled === false){\n                logi(`\\n### Skip the task without execution => ${taskRepresentStr}`);\n                continue;\n            }else{\n                logi(`\\n### Task : ${taskRepresentStr}`)\n            }\n    \n            if(task.comment){\n                logi(task.comment);\n            }\n    \n            let cwdHasChanges = false;\n            if(task.cwd){\n                const taskCwd = path.resolve(task.cwd);\n                logi(`Changing the current working directory => ${taskCwd}`);\n                cwdHasChanges = true;\n                process.chdir(taskCwd);\n            }\n            \n            const taskHandler = handlerMap[task.type];\n            await taskHandler(context, task);\n    \n            if(!opt.cwdModeIsContinue){\n                if(cwdHasChanges){\n                    logi(`Restoring the current working directory => ${baseCwd}`);\n                }\n                process.chdir(baseCwd);\n            }\n        }\n    };\n    \n    runTasks().then(()=>{}).catch((reason:any)=>{\n        throw reason;\n    }).finally(()=>{\n        process.chdir(baseCwd);\n        logv(`[${tasksConfig.name}] Tasks completed`);\n        logv(\"\");\n    });\n};\n","import fs from 'fs';\nimport path from 'path';\nimport json5 from 'json5';\n\nexport const loadJson = (filePath:string)=>{\n    if(!fs.existsSync(filePath)){\n        throw new Error(`ERROR: The Path '${filePath}' does not exists!`);\n    }\n\n    const fileString = fs.readFileSync(filePath, {encoding:'utf-8'});\n    return json5.parse(fileString);\n};\n\n\nexport const loadJsonConfig = (filePath:string)=>{\n    let configJson = loadJson(filePath);\n    if(configJson.extends){\n        const filePathDir = path.dirname(filePath);\n        const extendsFilePath = path.resolve(filePathDir, configJson.extends);\n        configJson = Object.assign({}, configJson, loadJsonConfig(extendsFilePath));\n    }\n    \n    return configJson;\n};\n\nexport const convertOrNotHyphenTextToCamelText=(text:string, flag:boolean)=>{\n    if(!flag){\n        return text;\n    }\n\n    let result = '';\n    let textArr = text.split(\"-\");\n    for(let i=0;i<textArr.length;i++){\n        let word = textArr[i];\n        if(i===0){\n            result = word;\n        }else{\n            if(word.length>0){\n                word = `${word[0].toUpperCase()}${word.substring(1)}`;\n            }\n            result = `${result}${word}`;\n        }\n    }\n    return result;\n}\n\n\n\nexport const containsTag = (elements:string[], tags:string[])=>{\n    if(elements.length < 1){\n        return false;\n    }\n    \n    for(const el of elements){\n        for(const tag of tags){\n            if(el === tag){\n                return true;    \n            }\n        }        \n    }\n\n    return false;\n};\n\nexport const containsAllTag = (elements:string[], tags:string[])=>{\n    if(elements.length < 1){\n        return false;\n    }\n    for(const el of elements){\n        let contained = false;\n        for(const tag of tags){\n            if(tag === el){\n                contained = true;\n                break;\n            }\n        }        \n        if(!contained){\n            return false;\n        }        \n    }\n    return true;\n};","import { LogLevel } from './build_cli_parser';\n\nexport interface TaskContext {\n    originCwd:string;\n    baseCwd:string;\n    replaceRegex:RegExp;\n    vars:any;\n}\n\nexport const allTaskTypes = ['git-repo-prepare','symlink','cmd','set-var','output','fs-copy','fs-del','env-var','sub-tasks'] as const;\ntype TasksTuple = typeof allTaskTypes;\nexport type TaskType = TasksTuple[number];\n\nexport interface Task {\n    type:TaskType;\n    id?:string;\n    tags?:string | string[],\n    cwd?:string;\n    enabled?:boolean;\n    comment?:string;\n    __compare__elements:string[];\n}\n\nexport interface TaskGitCheckout extends Task{\n    /** Executable git binary */\n    binary?:string;\n    url?:string;\n    localPath:string;\n    branch?:string;\n    startPoint?:string;\n    updateSubmodules?:Array<string> | string | boolean;\n}\n\nexport interface TaskSymlink extends Task{\n    target:string;\n    path:string;\n    linkType?:'dir' | 'file' | 'junction';\n    forced?:boolean;\n}\n\nexport interface TaskTerminalCommand extends Task{\n    cmd:string;\n    shell?:string;\n}\n\n\nexport interface TaskSetVar extends Task{\n    key:string;\n    var:string|number|any|boolean;\n    varType:'value'|'file';\n    fileFormat:'json'|'string';\n}\n\nexport interface TaskEnvVar extends Task{\n    var:any;\n    varType:'dict'|'file';\n}\n\nexport type TaskOutputTargets = 'console'|'file-write'|'file-append'|'c'|'fw'|'fa';\nexport interface TaskOutput extends Task{\n    text:string;\n    target:TaskOutputTargets;\n    path?:string;\n}\n\nexport interface TaskFsCopy extends Task{\n    src:string;\n    dest:string;\n    options?:{\n        conflict:'overwrite'|'skip'\n    };\n}\n\nexport interface TaskFsDelete extends Task{\n    path:string;\n}\n\nexport interface TaskSubTasks extends Task{\n    args:string;\n}\n\nexport interface Config {\n    name?:string;\n    \n    env?:{\n        logLevel?:LogLevel;\n        /** @deprecated */\n        verbose?:boolean;\n        /** @deprecated */\n        verboseGit?:boolean;\n        replaceRegex?:string;\n    };\n    tasks?:Array<Task>;\n}\n\nexport const LOG_TAG = \"useful-tasks\";\nexport const TAG_DEBUG = `${LOG_TAG}:debug`;\nexport const TAG_INFO = `${LOG_TAG}:info`;\n\n/** e.g. ${value.key} */\nexport const DEFAULT_REPLACE_REGEX = \"\\\\$\\\\{([a-zA-Z0-9\\\\.\\\\-_]*)\\\\}\";\n\nexport const VAR_FROM_ARGUMENT_PREFIX = \"--var-\";\nexport const ENV_VAR_FROM_ARGUMENT_PREFIX = \"--env-\";","import debug from \"debug\";\nimport { TAG_DEBUG, TAG_INFO } from \"./task_data\";\n\nexport const logv = debug(TAG_DEBUG);\nexport const logi = debug(TAG_INFO);","import { logv } from \"./loggers\";\nimport { Task, TaskContext } from \"./task_data\";\nimport { convertOrNotHyphenTextToCamelText, loadJson } from './utils';\n\nexport const applyVariables = async (context:TaskContext, task:Task)=>{\n    const anyTypeTask:any = task as any;\n    for(const key of Object.keys(anyTypeTask)) {\n        if(typeof(key) !== 'string'){\n            continue;\n        }\n        \n        if(key === 'id' || key === 'tags'){\n            continue;   \n        }\n        \n        if(anyTypeTask[key] !== undefined && typeof(anyTypeTask[key]) ==='string'){\n            let valueOfKey:string = anyTypeTask[key];\n            while(true){\n                const match = context.replaceRegex.exec(valueOfKey);\n                if(match === null || match === undefined){\n                    break;\n                }\n                \n                const matchedStr = match[0];\n                const varPath = match[1];\n\n                let currentVar = context.vars;\n                if(varPath.length > 0){\n                    const varPaths = varPath.split(\".\");\n                    for(let i=0; i<varPaths.length;i++){\n                        const varEl = varPaths[i];\n                        if(currentVar.hasOwnProperty(varEl)){\n                            currentVar = currentVar[varEl];\n                        }else{\n                            throw new Error(`The value of ${varPath} could not be found!`);\n                        }\n                    }\n                }\n\n                const valuePrefix = valueOfKey.substring(0, match.index);\n                const valueReplace = `${currentVar}`;\n                const valueSuffix = valueOfKey.substring(match.index+matchedStr.length);                    \n                valueOfKey = `${valuePrefix}${valueReplace}${valueSuffix}`;\n                logv(`Updated value ${valueOfKey}`);\n            }\n            \n            anyTypeTask[key] = valueOfKey;\n        }\n    }\n};\n\n\nexport const searchExtraKeyValue = (extraArgs:string[], fmt:string, convertToCamelKeys:boolean, callback:(key:string, value:string)=>void)=>{\n    let currentVarName:string|undefined;\n    let useNextElementAsVar:boolean = false;\n    \n    for(let extraArg of extraArgs){\n        const arg = extraArg.trim();\n        if(arg === '--'){\n            logv(\"Stop parsing by '--'\")\n            break;\n        }\n\n        if(useNextElementAsVar && currentVarName){\n            const value = extraArg.startsWith(\"-\") ? \"\":extraArg;\n            callback(currentVarName, value);\n            currentVarName = undefined;\n            useNextElementAsVar = false;\n        }else{\n            const prefixIndex = extraArg.indexOf(fmt);\n            if(prefixIndex >= 0){\n                const equalMarkIndex = extraArg.indexOf(\"=\");\n                if(equalMarkIndex >= 0){\n                    const varName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length, equalMarkIndex), convertToCamelKeys);\n                    const value = extraArg.substring(equalMarkIndex+1);\n                    callback(varName, value);\n                }else{\n                    currentVarName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length), convertToCamelKeys);\n                    useNextElementAsVar = true;\n                }\n            }    \n        }\n    }\n};\n\n\nexport const setTaskVar = (context:TaskContext, key:string, value:any)=>{\n    logv(`Sets the variable ${key}=${value}`);\n    context.vars[key] = value;\n}\n\nexport const setEnvVar = (context:TaskContext, key:string, value:any)=>{\n    var valueType = typeof(value);\n    if(valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean'){\n        logv(`Ignoring the invalid typed(${valueType}) environment variable ${key}=${value}`);\n    }else{\n        const stringVal = String(value);\n        if(stringVal.length < 1){\n            logv(`Ignoring the invalid environment variable ${key}=${value}`);\n        }else{\n            logv(`Sets the environment variable ${key}=${value}`);\n            process.env[key] = String(value);\n        }\n    }\n}\n","import stringArgv from 'string-argv';\nimport { TaskContext, TaskSubTasks } from './task_data';\nimport { usefulTasks } from './useful_tasks';\nimport { setup } from './build_cli_parser';\n\nexport const handleSubTasks = async (context:TaskContext, task:TaskSubTasks)=>{\n    if(!task.args || typeof(task.args) !== 'string'){\n        throw new Error(`Found missing or invalid property 'args' that is required`);\n    }\n\n    const subArgv = stringArgv(task.args);\n    const setupResult = setup(subArgv);\n    usefulTasks(context.originCwd, setupResult.opt, setupResult.program);\n}\n","import fs from 'fs';\nimport { execSync } from 'child_process';\nimport path from 'path';\nimport {CheckRepoActions, ResetMode, simpleGit} from 'simple-git';\nimport { copySync, mkdirpSync, removeSync } from 'fs-extra'\nimport { TaskContext, TaskOutput, TaskSetVar, TaskGitCheckout, TaskSymlink, TaskTerminalCommand, TaskOutputTargets, TaskFsCopy, TaskFsDelete, TaskEnvVar } from './task_data';\nimport { loadJson } from './utils';\nimport json5 from 'json5';\nimport { setEnvVar, setTaskVar } from './task_utils';\nimport { logv } from './loggers';\n\nexport const handleGitRepoSetup = async (context:TaskContext, task:TaskGitCheckout)=>{\n    const localPath = path.resolve(task.localPath);\n\n    if(!fs.existsSync(localPath)){\n        fs.mkdirSync(localPath, {recursive:true});\n    }\n\n    if(fs.readdirSync(localPath).length === 0){\n        if(task.url){\n            await simpleGit().clone(task.url, localPath);\n        }\n    }\n\n    const git = simpleGit(localPath, {binary:task.binary});\n\n    const isGitRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);\n    if(!isGitRepo){\n        throw Error(`${localPath} is not a git repository!!!`);\n    }\n\n    \n    if(task.updateSubmodules){\n        await git.submoduleInit();\n        await git.submoduleUpdate();\n    }else{\n        // const submodules = task.updateSubmodules ?? [];\n        // for(var submod of submodules){\n        // }\n    }\n\n    await git.fetch();\n\n    if(task.branch){\n        let hasLocalBranch = false;\n        const branchLocal = await git.branchLocal();\n        for(var b of branchLocal.all){\n            if(b === task.branch){\n                hasLocalBranch = true;\n                break;\n            }\n        }\n\n        const branch = task.branch ?? \"\";\n        const startPoint:string = task.startPoint ?? \"\";\n\n        if(!hasLocalBranch){\n            await git.checkoutBranch(branch, startPoint)\n        }else{\n            if(branchLocal.current !== task.branch){\n                await git.checkout(branch);\n            }\n            await git.reset(ResetMode.HARD, [startPoint])\n        }\n    }\n}\n\nexport const handleSymlink = async (context:TaskContext, task:TaskSymlink)=>{\n    const target:string = path.resolve(task.target);\n    const dstPath:string = path.resolve(task.path);\n\n    if(fs.existsSync(dstPath)){\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\n        logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n        if(task.forced){\n            if(lstat.isSymbolicLink() || lstat.isFile()){\n                logv(`Unlink ${dstPath}`);\n                fs.unlinkSync(dstPath);\n            }else if(lstat.isDirectory()){\n                logv(`Remove directory '${dstPath}'`);\n                removeSync(dstPath);\n            }\n        }\n    }\n\n    if(fs.existsSync(dstPath)){\n        logv(`Could not create symbolic link cause '${dstPath}' already exists`);\n        // throw Error()\n    }else{\n        logv(`Create symbolic link ${target} => ${dstPath}`);\n        fs.symlinkSync(target, dstPath, task.linkType);\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\n        logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n    }\n}\n\nexport const handleTerminalCommand = async (context:TaskContext, task:TaskTerminalCommand)=>{\n    logv(`Start execution... ${task.cmd}`);\n    execSync(task.cmd,{\n        shell: task.shell,\n        // cwd: cwd, \n        env: process.env,\n        stdio: [process.stdin, process.stdout, process.stderr],\n        encoding: 'utf-8'\n    })\n}\n\n\nexport const handleSetVar = async (context:TaskContext, task:TaskSetVar)=>{\n    if(task.key === undefined || !task.key || typeof(task.key) !== 'string' || task.key.length < 1){\n        throw new Error(`Invalid key ${task.key}. It must be a string.`);\n    }\n    \n    let taskVar = task.var;\n    if(task.varType === 'file'){\n        if(typeof(taskVar) !== 'string'){\n            throw new Error(`The \"var\" must contain path of a file with \"varType\":\"${task.varType}\"`);\n        }\n        \n        const varsPath = path.resolve(taskVar);\n        if(!fs.existsSync(varsPath)){\n            throw new Error(`File \"${varsPath}\" does not exist to use as a variable`);\n        }\n\n        taskVar = fs.readFileSync(varsPath ,{encoding:'utf8'});\n        if(task.fileFormat === 'json'){\n            taskVar = json5.parse(taskVar);\n        }\n    }\n\n    setTaskVar(context, task.key, taskVar);\n}\n\n\nexport const handleEnvVar = async (context:TaskContext, task:TaskEnvVar)=>{\n    let taskVar = task.var;\n    if(task.varType === 'file'){\n        if(typeof(taskVar) !== 'string'){\n            throw new Error(`The \"var\" must contain path of a file with \"varType\":\"${task.varType}\"`);\n        }\n        \n        const varsPath = path.resolve(taskVar);\n        taskVar = loadJson(varsPath);\n    }\n\n    if(typeof(taskVar) !== 'object'){\n        throw new Error(`The content of the \"var\" must be in the form of key-value pairs. For example: {\"KEY_A\":\"value_a\", \"KEY_B\":\"value_b\"}`);\n    }\n\n    Object.keys(taskVar).forEach(key => {\n        setEnvVar(context, key, taskVar[key]);\n    });\n}\n\nexport const handleOutput = async (context:TaskContext, task:TaskOutput)=>{\n    const text = task.text ?? '';\n    const target:TaskOutputTargets = (task.target ?? 'c').trim() as TaskOutputTargets;\n    const targetPath = task.path;\n    \n    if(target === 'c' || target === 'console'){\n        console.log(text);\n    }else{\n        if(!targetPath){\n            throw new Error(`The parameter 'path' is required for a target '${target}'!`);\n        }\n\n        const resolvedPath = path.resolve(targetPath);\n        const dir = path.dirname(resolvedPath);\n        if(!fs.existsSync(dir)){\n            mkdirpSync(dir);\n        }\n\n        if(target == 'fa' || target == 'file-append'){\n            let err;\n            let fd;\n            try{\n                fd = fs.openSync(resolvedPath,'a');\n                fs.appendFileSync(fd, text, 'utf8');\n            }catch(e){\n                err = e;\n            }finally{\n                if(fd !== undefined){\n                    fs.closeSync(fd);\n                }\n            }\n\n            if(err){\n                throw err;\n            }\n        }else{\n            fs.writeFileSync(resolvedPath, text);\n        }\n    }\n}\n\nexport const handleFsCopy = async (context:TaskContext, task:TaskFsCopy)=>{\n    let overwrite = task?.options?.conflict !== 'skip';\n\n    /** @deprecated support migrate from '0.1.18' */ \n    if(task.options && 'overwrite' in task?.options && typeof(task?.options?.overwrite) === 'boolean'){\n        overwrite = task.options.overwrite;\n    }\n    \n    copySync(task.src, task.dest,{overwrite});\n}\n\nexport const handleFsDelete = async (context:TaskContext, task:TaskFsDelete)=>{\n    removeSync(task.path);\n}","import { handleSubTasks } from \"./handler_sub_tasks\";\nimport { handleEnvVar, handleFsCopy, handleFsDelete, handleGitRepoSetup, handleOutput, handleSetVar, handleSymlink, handleTerminalCommand } from \"./handlers\";\nimport { TaskContext, TaskType } from \"./task_data\";\n\nexport const handlerMap:{\n    [k in TaskType]:(context:TaskContext, task:any)=>Promise<void>\n} = {\n    \"git-repo-prepare\": handleGitRepoSetup,\n    symlink: handleSymlink,\n    cmd: handleTerminalCommand,\n    \"set-var\": handleSetVar,\n    output: handleOutput,\n    \"fs-copy\":handleFsCopy,\n    \"fs-del\":handleFsDelete,\n    \"env-var\":handleEnvVar,\n    \"sub-tasks\": handleSubTasks\n};"],"mappings":"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","names":["path","Command","path","DEFAULT_CONFIG","DEFAULT_USE_CAMEL","CwdRestore","CwdKeep","cwdModes","LogLevelInfo","LogLevelDebug","LogLevelNone","logLevels","argDesc","v","setup","userArgv","program","typedOptions","fixStringArrayArgument","value","skipEmptyItem","result","trimedValue","path","fs","path","json5","loadJson","filePath","fileString","loadJsonConfig","configJson","filePathDir","extendsFilePath","convertOrNotHyphenTextToCamelText","text","flag","result","textArr","i","word","containsTag","elements","tags","el","tag","containsAllTag","contained","debug","LOG_TAG","TAG_DEBUG","TAG_INFO","DEFAULT_REPLACE_REGEX","VAR_FROM_ARGUMENT_PREFIX","ENV_VAR_FROM_ARGUMENT_PREFIX","debug","logv","debug","TAG_DEBUG","logi","TAG_INFO","applyVariables","context","task","anyTypeTask","key","valueOfKey","match","matchedStr","varPath","currentVar","varPaths","i","varEl","valuePrefix","valueReplace","valueSuffix","logv","searchExtraKeyValue","extraArgs","fmt","convertToCamelKeys","callback","currentVarName","useNextElementAsVar","extraArg","value","equalMarkIndex","varName","convertOrNotHyphenTextToCamelText","setTaskVar","setEnvVar","valueType","stringArgv","handleSubTasks","context","task","subArgv","stringArgv","setupResult","setup","usefulTasks","fs","execSync","path","CheckRepoActions","ResetMode","simpleGit","copySync","mkdirpSync","removeSync","json5","handleGitRepoSetup","context","task","localPath","path","fs","simpleGit","git","CheckRepoActions","hasLocalBranch","branchLocal","b","branch","startPoint","ResetMode","handleSymlink","target","dstPath","lstat","logv","removeSync","handleTerminalCommand","execSync","handleSetVar","taskVar","varsPath","json5","setTaskVar","handleEnvVar","loadJson","key","setEnvVar","handleOutput","text","targetPath","resolvedPath","dir","mkdirpSync","err","fd","e","handleFsCopy","overwrite","copySync","handleFsDelete","handlerMap","handleGitRepoSetup","handleSymlink","handleTerminalCommand","handleSetVar","handleOutput","handleFsCopy","handleFsDelete","handleEnvVar","handleSubTasks","usefulTasks","originCwd","opt","program","tasksConfig","configFilePath","path","loadJsonConfig","e","debugPat","logLevel","replaceRegex","DEFAULT_REPLACE_REGEX","env","logLevels","TAG_INFO","TAG_DEBUG","debug","logv","baseCwd","context","searchExtraKeyValue","VAR_FROM_ARGUMENT_PREFIX","key","value","setTaskVar","ENV_VAR_FROM_ARGUMENT_PREFIX","setEnvVar","logi","getTaskRepresentStr","task","i","tasks","j","otherTask","handlerMap","printInvalidTags","tags","tag","excludeItems","taskItem","index","array","containsTag","excludesItems","containsAllTag","hasIncludeFilters","hasIncludeCTAFilters","includeItems","includeCtaItems","v","taskCount","applyVariables","taskRepresentStr","cwdHasChanges","taskCwd","taskHandler","reason","originCwd","path","setupResult","setup","usefulTasks"]}