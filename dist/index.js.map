{"version":3,"sources":["../src/index.ts","../src/build_cli_parser.ts","../src/useful_tasks.ts","../src/utils.ts","../src/loggers.ts","../src/task_data.ts","../src/task_utils.ts","../src/tasks/handleSubTasks.ts","../src/tasks/handleContentReplace.ts","../src/glob_handler.ts","../src/tasks/handleFsMkdir.ts","../src/tasks/handleFsDelete.ts","../src/tasks/handleFsCopy.ts","../src/tasks/handleOutput.ts","../src/tasks/handleEnvVar.ts","../src/tasks/handleSetVar.ts","../src/tasks/handleTerminalCommand.ts","../src/tasks/handleFsSymlink.ts","../src/tasks/handleGitRepoSetup.ts","../src/handler_map.ts"],"sourcesContent":["#!/usr/bin/env node\r\n\r\nimport path from \"path\";\r\nimport { setup } from \"./build_cli_parser\";\r\nimport { usefulTasks } from \"./useful_tasks\";\r\nexport { usefulTasks } from \"./useful_tasks\";\r\n\r\nconst originCwd = path.resolve(process.cwd());\r\nconst setupResult = setup();\r\nusefulTasks(originCwd, setupResult.opt, setupResult.program);\r\n","import { Command } from 'commander';\r\nimport path from 'path';\r\n\r\nexport const DEFAULT_CONFIG = 'useful_tasks.json';\r\nexport const DEFAULT_USE_CAMEL = true;\r\n\r\nexport const CwdRestore = 'restore';\r\nexport const CwdKeep = 'keep';\r\n\r\nexport const cwdModes = [CwdRestore, CwdKeep] as const;\r\ntype CwdModeTuple = typeof cwdModes;\r\nexport type CwdMode = CwdModeTuple[number];\r\n\r\nconst LogLevelInfo = 'info';\r\nconst LogLevelDebug = 'debug';\r\nconst LogLevelNone = 'none';\r\nexport const logLevels = [LogLevelNone, LogLevelInfo, LogLevelDebug] as const;\r\ntype LogLevelTuple = typeof logLevels;\r\nexport type LogLevel = LogLevelTuple[number];\r\n\r\nexport interface Options {\r\n  cwd?: string;\r\n  config: string;\r\n  include?: string[];\r\n  includeCta?: string[];\r\n  exclude?: string[];\r\n  excludeCta?: string[];\r\n  camelKeys: boolean;\r\n  cwdMode?: CwdMode;\r\n  cwdModeIsContinue?: boolean;\r\n  logLevel?: LogLevel;\r\n  extraArgs?: string[];\r\n}\r\n\r\nconst argDesc = {\r\n  cwdMode: `Choose between ${cwdModes\r\n    .map((v) => `'${v}'`)\r\n    .join(\r\n      ' or '\r\n    )}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${CwdRestore}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${CwdKeep}' mode, the CWD will remain unchanged.`,\r\n};\r\n\r\nexport const setup = (userArgv?: string[]) => {\r\n  // console.log('cwd', process.cwd());\r\n  // console.log('argv', process.argv);\r\n\r\n  const program = new Command();\r\n  program\r\n    .name('useful-tasks')\r\n    .version(process.env.npm_package_version!)\r\n    .option('--cwd <string>', 'Change working directory')\r\n    .option('-c, --config <string>', 'A path of json configuraion', DEFAULT_CONFIG)\r\n    .option(\r\n      '-i, --include <items>',\r\n      'Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '-a, --include-cta <items>',\r\n      'Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '-e, --exclude <items>',\r\n      'Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '-x, --exclude-cta <items>',\r\n      'Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '--camel-keys <boolean>',\r\n      'Specify whether to use camel case for the key of the variable. If the value is true, the paramter \"--var-my-key\" will be converted to \"myKey\" otherwise it will be \"my-key\"',\r\n      DEFAULT_USE_CAMEL\r\n    )\r\n    .option('--cwd-mode <string>', argDesc.cwdMode, CwdRestore)\r\n    .option(\r\n      '--log-level <string>',\r\n      `Specify the logging level as ${logLevels.join(\r\n        ','\r\n      )}. This parameter takes higher priority than the 'json' configuration.`\r\n    )\r\n    // Allow unknown option to allow syntax such as \"--var-my-key\" to be passed to the program\r\n    .allowUnknownOption(true);\r\n\r\n  if (userArgv !== undefined) {\r\n    program.parse(userArgv, { from: 'user' });\r\n  } else {\r\n    program.parse();\r\n  }\r\n\r\n  const opts = program.opts();\r\n  // console.log(opts);\r\n\r\n  const typedOptions = opts as Options;\r\n  typedOptions.include = fixStringArrayArgument(typedOptions.include);\r\n  typedOptions.includeCta = fixStringArrayArgument(typedOptions.includeCta);\r\n  typedOptions.exclude = fixStringArrayArgument(typedOptions.exclude);\r\n  typedOptions.excludeCta = fixStringArrayArgument(typedOptions.excludeCta);\r\n\r\n  typedOptions.cwdModeIsContinue = typedOptions.cwdMode === CwdKeep;\r\n\r\n  if (typedOptions.camelKeys !== undefined && typeof typedOptions.camelKeys === 'string') {\r\n    let v: string = typedOptions.camelKeys;\r\n    v = v.trim().toLowerCase();\r\n    if (v === 'false' || v === '0' || v === 'no') {\r\n      typedOptions.camelKeys = false;\r\n    } else if (v === 'true' || v === '1' || v === 'yes') {\r\n      typedOptions.camelKeys = true;\r\n    } else {\r\n      typedOptions.camelKeys = DEFAULT_USE_CAMEL;\r\n    }\r\n  }\r\n  typedOptions.extraArgs = [...(program.args ?? [])];\r\n\r\n  // console.log(`Using options : ${JSON.stringify(typedOptions, undefined, 2)}`);\r\n  // console.log(`Extra arguments`, program.args);\r\n\r\n  if (typedOptions.cwd) {\r\n    process.chdir(path.resolve(typedOptions.cwd));\r\n  }\r\n\r\n  // console.log(\"######################################################################\")\r\n\r\n  return { opt: typedOptions, program };\r\n};\r\n\r\nconst fixStringArrayArgument = (value: string | string[] | undefined, skipEmptyItem: boolean = true) => {\r\n  if (!value) {\r\n    return [];\r\n  }\r\n\r\n  if (typeof value === 'string') {\r\n    const result: string[] = [];\r\n    const arr = value.split(',');\r\n    arr.forEach((value) => {\r\n      const trimedValue = value.trim();\r\n      if (skipEmptyItem) {\r\n        if (trimedValue.length > 0) {\r\n          result.push(trimedValue);\r\n        }\r\n      } else {\r\n        result.push(trimedValue);\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  return [];\r\n};\r\n","import path from 'path';\r\nimport { LogLevel, Options, logLevels } from './build_cli_parser';\r\nimport { containsAllTag, containsTag, loadJsonConfig } from './utils';\r\nimport debug from 'debug';\r\nimport {\r\n  Config,\r\n  TAG_DEBUG,\r\n  Task,\r\n  TaskContext,\r\n  DEFAULT_REPLACE_REGEX,\r\n  VAR_FROM_ARGUMENT_PREFIX,\r\n  ENV_VAR_FROM_ARGUMENT_PREFIX,\r\n  TAG_INFO,\r\n  TAG_WARN,\r\n} from './task_data';\r\nimport { applyVariables, searchExtraKeyValue, setTaskVar, setEnvVar } from './task_utils';\r\nimport { Command } from 'commander';\r\nimport { handlerMap } from './handler_map';\r\nimport { logi, logv } from './loggers';\r\n\r\nexport const usefulTasks = (originCwd: string, opt: Options, program: Command) => {\r\n  let tasksConfig: Config = {};\r\n\r\n  let configFilePath = path.resolve(opt.config);\r\n  try {\r\n    tasksConfig = loadJsonConfig(configFilePath);\r\n  } catch (e: any) {\r\n    if (e instanceof Error) {\r\n      console.log(e.message);\r\n    } else {\r\n      console.log(e);\r\n    }\r\n    console.log('');\r\n    program.help();\r\n  }\r\n\r\n  let debugPat: string | undefined;\r\n\r\n  let logLevel: LogLevel = 'info';\r\n  let replaceRegex = DEFAULT_REPLACE_REGEX;\r\n  if (tasksConfig.env && typeof tasksConfig.env === 'object') {\r\n    const env = tasksConfig.env;\r\n\r\n    if (env.verbose || env.verboseGit) {\r\n      logLevel = 'debug';\r\n    }\r\n\r\n    if (env.logLevel && logLevels.includes(env.logLevel)) {\r\n      logLevel = env.logLevel;\r\n    }\r\n\r\n    if (env.replaceRegex) {\r\n      replaceRegex = env.replaceRegex;\r\n    }\r\n  }\r\n\r\n  //cli argument can overwrite json's logLeve\r\n  if (opt.logLevel && logLevels.includes(opt.logLevel)) {\r\n    logLevel = opt.logLevel;\r\n  }\r\n\r\n  if (logLevel === 'debug') {\r\n    // debugPat = `${LOG_TAG}:*`;\r\n    debugPat = `${TAG_WARN},${TAG_INFO},${TAG_DEBUG}`;\r\n    debugPat = `${debugPat},simple-git,simple-git:*`;\r\n  } else if (logLevel === 'info') {\r\n    debugPat = `${TAG_WARN},${TAG_INFO}`;\r\n  }\r\n\r\n  if (debugPat) {\r\n    debug.enable(debugPat);\r\n  }\r\n\r\n  logv(`CLI Options`, opt);\r\n\r\n  if (typeof replaceRegex !== 'string') {\r\n    throw new Error(`replaceRegex '${replaceRegex}'  must be a string`);\r\n  }\r\n  if (replaceRegex.length < 1) {\r\n    throw new Error(`replaceRegex '${replaceRegex}' cannot be empty`);\r\n  }\r\n  if (replaceRegex.indexOf('(') < 0 || replaceRegex.indexOf(')') < 0) {\r\n    throw new Error(`replaceRegex '${replaceRegex}' must contain regex group express '(' and ')'`);\r\n  }\r\n\r\n  const baseCwd = path.resolve(process.cwd());\r\n\r\n  const context: TaskContext = {\r\n    originCwd,\r\n    baseCwd,\r\n    replaceRegex: new RegExp(replaceRegex),\r\n    vars: {\r\n      __env: {\r\n        cwd_startup: originCwd,\r\n        cwd_base: baseCwd,\r\n      },\r\n    },\r\n  };\r\n\r\n  if (opt.extraArgs) {\r\n    logv('Setting up the variables from the additional arguments');\r\n    searchExtraKeyValue(opt.extraArgs, VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key: string, value: string) => {\r\n      setTaskVar(context, key, value, false);\r\n    });\r\n\r\n    logv('Setting up the environment variables from the additional arguments');\r\n    searchExtraKeyValue(opt.extraArgs, ENV_VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key: string, value: string) => {\r\n      setEnvVar(context, key, value, false);\r\n    });\r\n  }\r\n\r\n  logi('');\r\n  logi(`[${tasksConfig.name}] Start task processing`);\r\n\r\n  const getTaskRepresentStr = (task: Task, i?: number) => {\r\n    if (i !== undefined && i !== null) {\r\n      return task.id !== undefined ? `[${i}]${task.id}/${task.type}` : `[${i}]${task.type}`;\r\n    } else {\r\n      return task.id !== undefined ? `${task.id}/${task.type}` : `${task.type}`;\r\n    }\r\n  };\r\n\r\n  const runTasks = async () => {\r\n    let tasks: Array<Task> = tasksConfig.tasks ?? [];\r\n\r\n    for (let i = 0; i < tasks.length; i++) {\r\n      const task = tasks[i];\r\n\r\n      // Validate task IDs\r\n      if (task.id !== undefined && task.id !== null) {\r\n        if (typeof task.id !== 'string') {\r\n          throw new Error(`The task id must be a 'string' type`);\r\n        }\r\n\r\n        if (task.id.length < 1) {\r\n          throw new Error(`The task id cannot be empty`);\r\n        }\r\n\r\n        for (let j = i + 1; j < tasks.length; j++) {\r\n          const otherTask = tasks[j];\r\n          if (otherTask.id !== undefined && otherTask.id === task.id) {\r\n            throw new Error(`The task id '${task.id}' must be unique`);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!task.type || !(task.type in handlerMap)) {\r\n        throw new Error(`Found the invalid task type '${task.type}'`);\r\n      }\r\n\r\n      task.__compare__elements = [];\r\n      if (task.id) {\r\n        task.id = task.id.trim();\r\n        task.__compare__elements.push(task.id.trim());\r\n      }\r\n      if (task.tags) {\r\n        const printInvalidTags = (tags: any) => {\r\n          logv(`Ignoring invalid tags '${tags}'`);\r\n        };\r\n        if (typeof task.tags === 'string') {\r\n          if (task.tags.length > 0) {\r\n            task.tags = task.tags.trim();\r\n            task.__compare__elements.push(task.tags);\r\n          } else {\r\n            printInvalidTags(task.tags);\r\n          }\r\n        } else if (Array.isArray(task.tags)) {\r\n          task.tags = task.tags.map((value: string) => value.trim());\r\n          for (const tag of task.tags) {\r\n            if (typeof tag === 'string' && tag.length > 0) {\r\n              task.__compare__elements.push(tag);\r\n            } else {\r\n              printInvalidTags(tag);\r\n            }\r\n          }\r\n        } else {\r\n          printInvalidTags(task.tags);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (opt.exclude && opt.exclude.length > 0) {\r\n      const excludeItems = opt.exclude;\r\n\r\n      logv(`Excluding tasks by specified IDs or Tags : --exclude=${excludeItems}`);\r\n      tasks = tasks.filter((taskItem: Task, index: number, array: Task[]) => {\r\n        if (containsTag(excludeItems, taskItem.__compare__elements) === false) {\r\n          return taskItem;\r\n        }\r\n      });\r\n    }\r\n    if (opt.excludeCta && opt.excludeCta.length > 0) {\r\n      const excludesItems = opt.excludeCta;\r\n\r\n      logv(`Excluding tasks by specified IDs or Tags : --exclude-cta=${excludesItems}`);\r\n      tasks = tasks.filter((taskItem: Task, index: number, array: Task[]) => {\r\n        if (containsAllTag(excludesItems, taskItem.__compare__elements) === false) {\r\n          return taskItem;\r\n        }\r\n      });\r\n    }\r\n    const hasIncludeFilters = opt.include && opt.include.length > 0;\r\n    const hasIncludeCTAFilters = opt.includeCta && opt.includeCta.length > 0;\r\n    if (hasIncludeFilters || hasIncludeCTAFilters) {\r\n      const includeItems = opt.include;\r\n      const includeCtaItems = opt.includeCta;\r\n\r\n      logv(`Including tasks by specified IDs or Tags : --include=${includeItems} / --include-cta=${includeCtaItems}`);\r\n      tasks = tasks.filter((taskItem: Task, index: number, array: Task[]) => {\r\n        if (\r\n          (hasIncludeFilters && containsTag(includeItems!, taskItem.__compare__elements) === true) ||\r\n          (hasIncludeCTAFilters && containsAllTag(includeCtaItems!, taskItem.__compare__elements) === true)\r\n        ) {\r\n          return taskItem;\r\n        }\r\n      });\r\n    }\r\n\r\n    logi(\r\n      `Tasks : ${tasks.map((v, i) => {\r\n        return getTaskRepresentStr(v, i);\r\n      })}`\r\n    );\r\n\r\n    const taskCount = tasks.length ?? 0;\r\n    for (let i = 0; i < taskCount; i++) {\r\n      const task = tasks[i];\r\n      await applyVariables(context, task);\r\n\r\n      const taskRepresentStr = getTaskRepresentStr(task, i);\r\n      if (task.enabled === false) {\r\n        logi(`\\n### Skip the task without execution => ${taskRepresentStr}`);\r\n        continue;\r\n      } else {\r\n        logi(`\\n### Task : ${taskRepresentStr}`);\r\n      }\r\n\r\n      if (task.comment) {\r\n        logi(task.comment);\r\n      }\r\n\r\n      let cwdHasChanges = false;\r\n      if (task.cwd) {\r\n        const taskCwd = path.resolve(task.cwd);\r\n        logi(`Changing the current working directory => ${taskCwd}`);\r\n        cwdHasChanges = true;\r\n        process.chdir(taskCwd);\r\n      }\r\n\r\n      const taskHandler = handlerMap[task.type];\r\n      await taskHandler(context, task);\r\n\r\n      if (!opt.cwdModeIsContinue) {\r\n        if (cwdHasChanges) {\r\n          logi(`Restoring the current working directory => ${baseCwd}`);\r\n        }\r\n        process.chdir(baseCwd);\r\n      }\r\n    }\r\n  };\r\n\r\n  runTasks()\r\n    .then(() => {})\r\n    .catch((reason: any) => {\r\n      throw reason;\r\n    })\r\n    .finally(() => {\r\n      process.chdir(baseCwd);\r\n      logi(`[${tasksConfig.name}] Tasks done\\n`);\r\n    });\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\nimport json5 from 'json5';\r\nimport { Task } from 'task_data';\r\nimport { logw, logv } from './loggers';\r\n\r\nexport const loadFileOrThrow = (filePath: string) => {\r\n  logv(`Loading file: ${filePath}`);\r\n  if (!fs.existsSync(filePath)) {\r\n    throw new Error(`ERROR: The Path '${filePath}' does not exists!`);\r\n  }\r\n\r\n  return fs.readFileSync(filePath, { encoding: 'utf-8' });\r\n};\r\n\r\nexport const loadJson = (filePath: string) => {\r\n  return parseJson(loadFileOrThrow(filePath));\r\n};\r\n\r\nexport const parseJson = (content: string) => json5.parse(content);\r\n\r\nexport const loadJsonConfig = (filePath: string) => {\r\n  let configJson = loadJson(filePath);\r\n  if (configJson.extends) {\r\n    const filePathDir = path.dirname(filePath);\r\n    const extendsFilePath = path.resolve(filePathDir, configJson.extends);\r\n    configJson = Object.assign({}, configJson, loadJsonConfig(extendsFilePath));\r\n  }\r\n\r\n  return configJson;\r\n};\r\n\r\nexport const convertOrNotHyphenTextToCamelText = (text: string, flag: boolean) => {\r\n  if (!flag) {\r\n    return text;\r\n  }\r\n\r\n  let result = '';\r\n  let textArr = text.split('-');\r\n  for (let i = 0; i < textArr.length; i++) {\r\n    let word = textArr[i];\r\n    if (i === 0) {\r\n      result = word;\r\n    } else {\r\n      if (word.length > 0) {\r\n        word = `${word[0].toUpperCase()}${word.substring(1)}`;\r\n      }\r\n      result = `${result}${word}`;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexport const containsTag = (elements: string[], tags: string[]) => {\r\n  if (elements.length < 1) {\r\n    return false;\r\n  }\r\n\r\n  for (const el of elements) {\r\n    for (const tag of tags) {\r\n      if (el === tag) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const containsAllTag = (elements: string[], tags: string[]) => {\r\n  if (elements.length < 1) {\r\n    return false;\r\n  }\r\n  for (const el of elements) {\r\n    let contained = false;\r\n    for (const tag of tags) {\r\n      if (tag === el) {\r\n        contained = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!contained) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nexport const checkEmptyStringOrThrow = (name: string, value: string) => {\r\n  if (!value) {\r\n    throw new Error(`The '${name}' property must not be empty.`);\r\n  }\r\n};\r\n\r\nexport const checkLegacyUsage = (task: Task, key: string) => {\r\n  if ((task as any)[key] !== undefined) logw(`The key '${key}' has been deprecated.`);\r\n};\r\n\r\ntype TypeString = 'string' | 'number' | 'boolean' | 'undefined' | 'object' | 'function' | 'bigint' | 'symbol';\r\nexport const checkType = (value: any, allowedTypes: TypeString[]): boolean => {\r\n  if (allowedTypes.length <= 0) return true;\r\n  return allowedTypes.includes(typeof value);\r\n};\r\n\r\nexport const checkTypeOrThrow = (name: string, value: any, allowedTypes: TypeString[]): boolean => {\r\n  if (checkType(value, allowedTypes)) {\r\n    return true;\r\n  }\r\n\r\n  const valueType = typeof value;\r\n  throw new Error(\r\n    `The '${name}' property has an invalid type '${valueType}' with the value '${value}'. The allowed types are [${allowedTypes}].`\r\n  );\r\n};\r\n\r\nconst ENV_LINE =\r\n  /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/gm;\r\n\r\n/**  Parse src into an Object */\r\nexport function parseLines(src: string) {\r\n  const obj: any = {};\r\n\r\n  // Convert buffer to string\r\n  let lines = src.toString();\r\n\r\n  // Convert line breaks to same format\r\n  lines = lines.replace(/\\r\\n?/gm, '\\n');\r\n\r\n  let match: RegExpExecArray | null;\r\n  while ((match = ENV_LINE.exec(lines)) != null) {\r\n    const key = match[1];\r\n    // Default undefined or null to empty string\r\n    let value = match[2] || '';\r\n    // Remove whitespace\r\n    value = value.trim();\r\n    // Check if double quoted\r\n    const maybeQuote = value[0];\r\n    // Remove surrounding quotes\r\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/gm, '$2');\r\n    // Expand newlines if double quoted\r\n    if (maybeQuote === '\"') {\r\n      value = value.replace(/\\\\n/g, '\\n');\r\n      value = value.replace(/\\\\r/g, '\\r');\r\n    }\r\n\r\n    // Add to object\r\n    obj[key] = value;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nexport const throwInvalidParamError = <T, K extends keyof T>(obj: T, key: K) => {\r\n  throw new Error(`The parameter '${String(key)}' has an invalid value ${obj[key]}`);\r\n};\r\n\r\nexport const resolveStringArray = (val: string | string[] | undefined | null, defaultValue: string[]): string[] => {\r\n  if (val !== undefined && val !== null) {\r\n    if (typeof val === 'string') {\r\n      return [val];\r\n    } else if (Array.isArray(val)) {\r\n      return val.filter((v) => typeof v === 'string');\r\n    }\r\n  }\r\n\r\n  return defaultValue;\r\n};\r\n","import debug from \"debug\";\r\nimport { TAG_DEBUG, TAG_INFO, TAG_WARN } from \"./task_data\";\r\n\r\nexport const logw = debug(TAG_WARN);\r\nexport const logi = debug(TAG_INFO);\r\nexport const logv = debug(TAG_DEBUG);\r\n","import { LogLevel } from './build_cli_parser';\r\n\r\nexport interface TaskContext {\r\n  originCwd: string;\r\n  baseCwd: string;\r\n  replaceRegex: RegExp;\r\n  vars: any;\r\n}\r\n\r\nexport const allTaskTypes = [\r\n  'git-repo-prepare',\r\n  'cmd',\r\n  'set-var',\r\n  'output',\r\n  'symlink',\r\n  'fs-copy',\r\n  'fs-del',\r\n  'fs-mkdir',\r\n  'env-var',\r\n  'sub-tasks',\r\n  'content-replace',\r\n] as const;\r\ntype TasksTuple = typeof allTaskTypes;\r\nexport type TaskType = TasksTuple[number];\r\n\r\nexport interface Task {\r\n  type: TaskType;\r\n  id?: string;\r\n  tags?: string | string[];\r\n  cwd?: string;\r\n  enabled?: boolean;\r\n  comment?: string;\r\n  __compare__elements: string[];\r\n\r\n  //TODO:Implement allowError\r\n  /** The process will not be interrupted even if errors are caught from this task. */\r\n  allowError?: boolean;\r\n}\r\n\r\nexport interface TaskGitCheckout extends Task {\r\n  /** Executable git binary */\r\n  binary?: string;\r\n  url?: string;\r\n  localPath: string;\r\n  branch?: string;\r\n  startPoint?: string;\r\n  updateSubmodules?: Array<string> | string | boolean;\r\n}\r\n\r\nexport interface TaskSymlink extends Task {\r\n  target: string;\r\n  path: string;\r\n  linkType?: 'dir' | 'file' | 'junction';\r\n  forced?: boolean;\r\n}\r\n\r\nexport interface TaskTerminalCommand extends Task {\r\n  cmd: string;\r\n  shell?: string;\r\n}\r\n\r\nexport interface TaskSetVar extends Task, GlobFilters {\r\n  key: string;\r\n  value?: string | number | boolean | any;\r\n  src?: string;\r\n  parser?: 'json' | 'lines' | 'string' | 'auto';\r\n  /** If the variable already exists, assigning will be skipped */\r\n  isFallback?: boolean;\r\n}\r\n\r\nexport interface TaskEnvVar extends Task, GlobFilters {\r\n  value?: any;\r\n  src?: string;\r\n  parser?: 'json' | 'lines' | 'auto';\r\n  /** If the environment variable already exists, assigning will be skipped */\r\n  isFallback?: boolean;\r\n}\r\n\r\nexport type TaskOutputTargets = 'console' | 'file-write' | 'file-append' | 'c' | 'fw' | 'fa';\r\nexport interface TaskOutput extends Task {\r\n  text: string;\r\n  target: TaskOutputTargets;\r\n  path?: string;\r\n}\r\n\r\nexport interface GlobFilters {\r\n  include?: string | string[];\r\n  exclude?: string | string[];\r\n}\r\n\r\nexport type TaskFsCopyOptions = {\r\n  conflict?: 'overwrite' | 'skip';\r\n};\r\n\r\nexport interface TaskFsCopy extends Task, GlobFilters {\r\n  src: string;\r\n  dest: string;\r\n  options?: TaskFsCopyOptions;\r\n}\r\n\r\nexport interface TaskFsDelete extends Task, GlobFilters {\r\n  path: string;\r\n}\r\n\r\nexport interface TaskFsMakeDir extends Task {\r\n  path: string;\r\n}\r\n\r\nexport interface TaskSubTasks extends Task {\r\n  args: string;\r\n}\r\n\r\nexport interface RegexData {\r\n  pattern: string;\r\n  flags?: string;\r\n}\r\n\r\nexport interface TaskContentReplace extends Task, GlobFilters {\r\n  /**\r\n   * If the task includes 'include' or 'exclude', it will be handled as a directory.\r\n   * Otherwise, it will be processed as a file.\r\n   */\r\n  path: string;\r\n\r\n  find: string | RegexData;\r\n  replace: string;\r\n  loop?: number;\r\n}\r\n\r\nexport interface Config {\r\n  name?: string;\r\n\r\n  env?: {\r\n    logLevel?: LogLevel;\r\n    /** @deprecated */\r\n    verbose?: boolean;\r\n    /** @deprecated */\r\n    verboseGit?: boolean;\r\n    replaceRegex?: string;\r\n  };\r\n  tasks?: Array<Task>;\r\n}\r\n\r\nexport const LOG_TAG = 'useful-tasks';\r\nexport const TAG_DEBUG = `${LOG_TAG}:debug`;\r\nexport const TAG_INFO = `${LOG_TAG}:info`;\r\nexport const TAG_WARN = `${LOG_TAG}:warn`;\r\n\r\n/** e.g. ${value.key} */\r\nexport const DEFAULT_REPLACE_REGEX = '\\\\$\\\\{([a-zA-Z0-9\\\\.\\\\-_]*)\\\\}';\r\n\r\nexport const VAR_FROM_ARGUMENT_PREFIX = '--var-';\r\nexport const ENV_VAR_FROM_ARGUMENT_PREFIX = '--env-';\r\n","import { logv } from \"./loggers\";\r\nimport { Task, TaskContext } from \"./task_data\";\r\nimport { convertOrNotHyphenTextToCamelText, loadJson } from \"./utils\";\r\n\r\nexport const applyVariables = async (context: TaskContext, task: Task) => {\r\n  const anyTypeTask: any = task as any;\r\n  for (const key of Object.keys(anyTypeTask)) {\r\n    if (typeof key !== \"string\") {\r\n      continue;\r\n    }\r\n\r\n    if (key === \"id\" || key === \"tags\") {\r\n      continue;\r\n    }\r\n\r\n    if (anyTypeTask[key] !== undefined && typeof anyTypeTask[key] === \"string\") {\r\n      let valueOfKey: string = anyTypeTask[key];\r\n      while (true) {\r\n        const match = context.replaceRegex.exec(valueOfKey);\r\n        if (match === null || match === undefined) {\r\n          break;\r\n        }\r\n\r\n        const matchedStr = match[0];\r\n        const varPath = match[1];\r\n\r\n        let currentVar = context.vars;\r\n        if (varPath.length > 0) {\r\n          const varPaths = varPath.split(\".\");\r\n          for (let i = 0; i < varPaths.length; i++) {\r\n            const varEl = varPaths[i];\r\n            if (currentVar.hasOwnProperty(varEl)) {\r\n              currentVar = currentVar[varEl];\r\n            } else {\r\n              throw new Error(`The value of ${varPath} could not be found!`);\r\n            }\r\n          }\r\n        }\r\n\r\n        const valuePrefix = valueOfKey.substring(0, match.index);\r\n        const valueReplace = `${currentVar}`;\r\n        const valueSuffix = valueOfKey.substring(match.index + matchedStr.length);\r\n        valueOfKey = `${valuePrefix}${valueReplace}${valueSuffix}`;\r\n        logv(`Variable injection: '${key}'=>'${valueOfKey}'`);\r\n      }\r\n\r\n      anyTypeTask[key] = valueOfKey;\r\n    }\r\n  }\r\n};\r\n\r\nexport const searchExtraKeyValue = (\r\n  extraArgs: string[],\r\n  fmt: string,\r\n  convertToCamelKeys: boolean,\r\n  callback: (key: string, value: string) => void\r\n) => {\r\n  let currentVarName: string | undefined;\r\n  let useNextElementAsVar: boolean = false;\r\n\r\n  for (let extraArg of extraArgs) {\r\n    const arg = extraArg.trim();\r\n    if (arg === \"--\") {\r\n      logv(\"Stop parsing by '--'\");\r\n      break;\r\n    }\r\n\r\n    if (useNextElementAsVar && currentVarName) {\r\n      const value = extraArg.startsWith(\"-\") ? \"\" : extraArg;\r\n      callback(currentVarName, value);\r\n      currentVarName = undefined;\r\n      useNextElementAsVar = false;\r\n    } else {\r\n      const prefixIndex = extraArg.indexOf(fmt);\r\n      if (prefixIndex >= 0) {\r\n        const equalMarkIndex = extraArg.indexOf(\"=\");\r\n        if (equalMarkIndex >= 0) {\r\n          const varName = convertOrNotHyphenTextToCamelText(\r\n            extraArg.substring(fmt.length, equalMarkIndex),\r\n            convertToCamelKeys\r\n          );\r\n          const value = extraArg.substring(equalMarkIndex + 1);\r\n          callback(varName, value);\r\n        } else {\r\n          currentVarName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length), convertToCamelKeys);\r\n          useNextElementAsVar = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const setTaskVar = (context: TaskContext, key: string, value: any, skipForExists: boolean) => {\r\n  if (skipForExists && context.vars[key] !== undefined) {\r\n    logv(`Skips assigning the variable ${key}=${value} because it already exists.`);\r\n    return;\r\n  }\r\n\r\n  logv(`Sets the variable ${key}=${value}`);\r\n  context.vars[key] = value;\r\n};\r\n\r\nexport const setEnvVar = (context: TaskContext, key: string, value: any, skipForExists: boolean) => {\r\n  var valueType = typeof value;\r\n  if (valueType !== \"string\" && valueType !== \"number\" && valueType !== \"boolean\") {\r\n    logv(`Ignoring the invalid typed(${valueType}) environment variable ${key}=${value}`);\r\n  } else {\r\n    const stringVal = String(value);\r\n    if (stringVal.length < 1) {\r\n      logv(`Ignoring the invalid environment variable ${key}=${value}`);\r\n    } else {\r\n      if (skipForExists && process.env[key] !== undefined) {\r\n        logv(`Skips assigning the environment variable ${key}=${value} because it already exists.`);\r\n        return;\r\n      }\r\n\r\n      logv(`Sets the environment variable ${key}=${value}`);\r\n      process.env[key] = String(value);\r\n    }\r\n  }\r\n};\r\n","import stringArgv from 'string-argv';\r\nimport { TaskContext, TaskSubTasks } from '../task_data';\r\nimport { usefulTasks } from '../useful_tasks';\r\nimport { setup } from '../build_cli_parser';\r\n\r\nexport const handleSubTasks = async (context: TaskContext, task: TaskSubTasks) => {\r\n  if (!task.args || typeof task.args !== 'string') {\r\n    throw new Error(`Found missing or invalid property 'args' that is required`);\r\n  }\r\n\r\n  const subArgv = stringArgv(task.args);\r\n  const setupResult = setup(subArgv);\r\n  usefulTasks(context.originCwd, setupResult.opt, setupResult.program);\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\nimport { TaskContext, TaskContentReplace, RegexData } from '../task_data';\r\nimport { logi, logv } from '../loggers';\r\nimport { processWithGlobSync } from '../glob_handler';\r\nimport { resolveStringArray, throwInvalidParamError } from '../utils';\r\n\r\nconst runFindAndReplaceWithRegex = (content: string, find: RegExp, replace: string, repeat: number): string => {\r\n  var text: string = content;\r\n  if (repeat < 1) {\r\n    while (find.test(text)) {\r\n      text = text.replace(find, replace);\r\n    }\r\n  } else {\r\n    for (var i = 0; i < repeat; i++) {\r\n      if (find.test(text)) {\r\n        text = text.replace(find, replace);\r\n      }\r\n    }\r\n  }\r\n  return text;\r\n};\r\n\r\nconst runFindAndReplaceWithText = (content: string, find: string, replace: string, repeat: number): string => {\r\n  var text: string = content;\r\n  if (repeat < 1) {\r\n    while (text.indexOf(find) >= 0) {\r\n      text = text.replace(find, replace);\r\n    }\r\n  } else {\r\n    for (var i = 0; i < repeat; i++) {\r\n      if (text.indexOf(find) >= 0) {\r\n        text = text.replace(find, replace);\r\n      }\r\n    }\r\n  }\r\n  return text;\r\n};\r\n\r\nconst isRegexData = (v: any) => {\r\n  if (v !== undefined && v !== null && typeof v === 'object' && 'pattern' in v && typeof v.pattern === 'string') {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\ntype FindAndReplaceFunc = (content: string, find: any, replace: string, repeat: number) => string;\r\n\r\nconst findAndReplaceWithFile = (\r\n  path: string,\r\n  replaceFunc: FindAndReplaceFunc,\r\n  find: string | RegExp,\r\n  replace: string,\r\n  repeat: number\r\n) => {\r\n  logv(`Find and Replace: ${path}`);\r\n  const content: string = fs.readFileSync(path, 'utf-8');\r\n  const newContent = replaceFunc(content, find, replace, repeat);\r\n  fs.writeFileSync(path, newContent, 'utf-8');\r\n};\r\n\r\nexport const handleContentReplace = async (context: TaskContext, task: TaskContentReplace) => {\r\n  if (!fs.existsSync(task.path)) {\r\n    logv(`The '${task.path}' does not exist`);\r\n    return;\r\n  }\r\n\r\n  if (task.replace === undefined || typeof task.replace !== 'string') {\r\n    throwInvalidParamError(task, 'replace');\r\n  }\r\n\r\n  let loop: number = task.loop === undefined || task.loop === null ? 1 : task.loop;\r\n  if (typeof loop === 'string') {\r\n    loop = parseInt(loop, 10);\r\n  } else if (typeof loop !== 'number') {\r\n    throwInvalidParamError(task, 'loop');\r\n  }\r\n\r\n  let find: string | RegExp;\r\n  let replaceFunc: FindAndReplaceFunc;\r\n  if (isRegexData(task.find)) {\r\n    const regexData = task.find as RegexData;\r\n    find = new RegExp(regexData.pattern, regexData.flags);\r\n    replaceFunc = runFindAndReplaceWithRegex;\r\n  } else if (typeof task.find === 'string') {\r\n    find = task.find;\r\n    replaceFunc = runFindAndReplaceWithText;\r\n  } else {\r\n    throwInvalidParamError(task, 'find');\r\n    return;\r\n  }\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const itemPath: string = path.join(task.path, f);\r\n      if (fs.statSync(itemPath).isDirectory()) {\r\n        continue;\r\n      }\r\n      findAndReplaceWithFile(path.join(task.path, f), replaceFunc, find, task.replace, loop);\r\n    }\r\n  };\r\n\r\n  // ignore dirs, include all files on empty filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    task.path,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    true,\r\n    true\r\n  );\r\n\r\n  // expect it is a single file\r\n  if (!handled) {\r\n    findAndReplaceWithFile(task.path, replaceFunc, find, task.replace, loop);\r\n  }\r\n};\r\n","import fs from \"fs\";\r\nimport { globSync } from \"glob\";\r\n\r\n/**\r\n *\r\n * @param handler\r\n * @param cwd\r\n * @param includes\r\n * @param excludes\r\n * @param includeAllForNonFilter\r\n * @param subOptions\r\n * @returns true - filters are applied, false - there was no filter to apply\r\n */\r\nexport const processWithGlobSync = (\r\n  handler: (items: string[]) => void,\r\n  cwd: string,\r\n  includes: string[],\r\n  excludes: string[],\r\n  skipDirs: boolean,\r\n  includeAllIfNonFilters: boolean\r\n): boolean => {\r\n  if (fs.statSync(cwd).isDirectory() === false) {\r\n    return false;\r\n  }\r\n\r\n  //pre apply filter for faster performance\r\n  const nodir: boolean = skipDirs === true;\r\n\r\n  const ilen: boolean = includes.length > 0;\r\n  const elen: boolean = excludes.length > 0;\r\n  if (!ilen && elen) {\r\n    //include all to apply excludes\r\n    handler(globSync(\"**\", { ignore: [\".\", ...excludes], cwd, nodir }));\r\n    return true;\r\n  } else if (ilen && !elen) {\r\n    //apply includes only\r\n    handler(globSync(includes, { cwd, nodir }));\r\n    return true;\r\n  } else if (ilen && elen) {\r\n    //apply include and exclude\r\n    handler(globSync(includes, { ignore: excludes, cwd, nodir }));\r\n    return true;\r\n  } else if (includeAllIfNonFilters) {\r\n    //include all to apply skipDirs, skipFiles\r\n    handler(globSync(\"**\", { ignore: [\".\"], cwd, nodir }));\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n","import { mkdirpSync } from 'fs-extra';\r\nimport { logv } from 'loggers';\r\nimport { TaskContext, TaskFsMakeDir } from 'task_data';\r\nimport { checkTypeOrThrow } from 'utils';\r\n\r\nexport const handleMkdir = async (context: TaskContext, task: TaskFsMakeDir) => {\r\n  checkTypeOrThrow('path', task.path, ['string']);\r\n  logv(`Make a directory at : ${task.path}`);\r\n  mkdirpSync(task.path);\r\n};\r\n","import fs from 'fs';\r\nimport { processWithGlobSync } from 'glob_handler';\r\nimport { logv } from 'loggers';\r\nimport path from 'path';\r\nimport { TaskContext, TaskFsDelete } from 'task_data';\r\nimport { removeSync } from 'fs-extra';\r\nimport { resolveStringArray } from 'utils';\r\n\r\nexport const runDelete = (path: string) => {\r\n  logv(`Delete: ${path}`);\r\n  removeSync(path);\r\n};\r\n\r\nexport const handleFsDelete = async (context: TaskContext, task: TaskFsDelete) => {\r\n  if (!fs.existsSync(task.path)) {\r\n    logv(`The '${task.path}' does not exist and cannot be deleted`);\r\n    return;\r\n  }\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      runDelete(path.join(task.path, f));\r\n    }\r\n  };\r\n\r\n  // allow dir with glob, do nothing withtout filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    task.path,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    false,\r\n    false\r\n  );\r\n\r\n  // delete the path is whatever\r\n  if (!handled) {\r\n    runDelete(task.path);\r\n  }\r\n};\r\n","import { processWithGlobSync } from '../glob_handler';\r\nimport path from 'path';\r\nimport { TaskContext, TaskFsCopy } from '../task_data';\r\nimport { logi, logv } from '../loggers';\r\nimport fse from 'fs-extra';\r\nimport { copySync, CopyOptionsSync } from 'fs-extra';\r\nimport { resolveStringArray } from '../utils';\r\n\r\nexport const runCopy = (src: string, dst: string, options: CopyOptionsSync) => {\r\n  logv(`Copy: ${src} => ${dst}`);\r\n  copySync(src, dst, options);\r\n};\r\n\r\nexport const handleFsCopy = async (context: TaskContext, task: TaskFsCopy) => {\r\n  if (!fse.existsSync(task.src)) {\r\n    throw new Error(`The source '${task.src}' does not exist`);\r\n  }\r\n\r\n  const conflict = task?.options?.conflict;\r\n  let overwrite =\r\n    conflict === undefined || conflict === null || (typeof conflict === 'string' && conflict.trim() === 'overwrite');\r\n\r\n  /** @deprecated support migrate from '0.1.18' */\r\n  if (task.options && 'overwrite' in task?.options && typeof task?.options?.overwrite === 'boolean') {\r\n    overwrite = task.options.overwrite;\r\n  }\r\n\r\n  const cpOpt: CopyOptionsSync = { overwrite };\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const from = path.join(task.src, f);\r\n      const to = path.join(task.dest, f);\r\n      runCopy(from, to, cpOpt);\r\n    }\r\n  };\r\n\r\n  // allow dir with glob, do nothing withtout filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    task.src,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    false,\r\n    false\r\n  );\r\n\r\n  // copy the path is whatever\r\n  if (!handled) {\r\n    runCopy(task.src, task.dest, cpOpt);\r\n  }\r\n};\r\n","import fs from \"fs\";\r\nimport { mkdirpSync } from \"fs-extra\";\r\nimport path from \"path\";\r\nimport { TaskContext, TaskOutput, TaskOutputTargets } from \"task_data\";\r\n\r\nexport const handleOutput = async (context: TaskContext, task: TaskOutput) => {\r\n  const text = task.text ?? \"\";\r\n  const target: TaskOutputTargets = (task.target ?? \"c\").trim() as TaskOutputTargets;\r\n  const targetPath = task.path;\r\n\r\n  if (target === \"c\" || target === \"console\") {\r\n    console.log(text);\r\n  } else {\r\n    if (!targetPath) {\r\n      throw new Error(`The parameter 'path' is required for a target '${target}'!`);\r\n    }\r\n\r\n    const resolvedPath = path.resolve(targetPath);\r\n    const dir = path.dirname(resolvedPath);\r\n    if (!fs.existsSync(dir)) {\r\n      mkdirpSync(dir);\r\n    }\r\n\r\n    if (target == \"fa\" || target == \"file-append\") {\r\n      let err;\r\n      let fd;\r\n      try {\r\n        fd = fs.openSync(resolvedPath, \"a\");\r\n        fs.appendFileSync(fd, text, \"utf8\");\r\n      } catch (e) {\r\n        err = e;\r\n      } finally {\r\n        if (fd !== undefined) {\r\n          fs.closeSync(fd);\r\n        }\r\n      }\r\n\r\n      if (err) {\r\n        throw err;\r\n      }\r\n    } else {\r\n      fs.writeFileSync(resolvedPath, text);\r\n    }\r\n  }\r\n};\r\n","import fse from 'fs-extra';\r\nimport { processWithGlobSync } from 'glob_handler';\r\nimport { logv } from 'loggers';\r\nimport path from 'path';\r\nimport { TaskContext, TaskEnvVar } from 'task_data';\r\nimport { setEnvVar } from 'task_utils';\r\nimport {\r\n  checkLegacyUsage,\r\n  parseLines,\r\n  checkTypeOrThrow,\r\n  loadFileOrThrow,\r\n  parseJson,\r\n  resolveStringArray,\r\n} from '../utils';\r\n\r\nexport const handleEnvVar = async (context: TaskContext, task: TaskEnvVar) => {\r\n  checkLegacyUsage(task, 'var');\r\n  checkLegacyUsage(task, 'varType');\r\n  checkLegacyUsage(task, 'fileFormat');\r\n\r\n  if (task.isFallback !== true) {\r\n    task.isFallback = false;\r\n  }\r\n  const isFallback: boolean = task.isFallback;\r\n\r\n  if (task.value !== undefined) {\r\n    let value: any = task.value;\r\n    if (typeof value === 'string') {\r\n      logv('Trying to parse as lines.');\r\n      value = parseLines(value);\r\n    }\r\n\r\n    Object.keys(value).forEach((key) => {\r\n      setEnvVar(context, key, value[key], isFallback);\r\n    });\r\n  }\r\n\r\n  if (!task.src) return;\r\n\r\n  checkTypeOrThrow('src', task.src, ['string']);\r\n  const src = task.src as string;\r\n  const parser = task.parser || 'auto';\r\n  logv(`Parser = ${parser}`);\r\n\r\n  const runFunc = (filePath: string) => {\r\n    const varsPath = path.resolve(filePath);\r\n    let obj: Record<string, any> | undefined;\r\n    const content = loadFileOrThrow(varsPath);\r\n\r\n    if (parser === 'auto' || parser === 'json') {\r\n      try {\r\n        logv('Trying to parse as JSON.');\r\n        obj = parseJson(content);\r\n      } catch (e) {\r\n        if (parser === 'json') throw e;\r\n      }\r\n    }\r\n\r\n    if (!obj && (parser === 'auto' || parser === 'lines')) {\r\n      logv('Trying to parse as lines.');\r\n      obj = parseLines(content);\r\n    }\r\n\r\n    if (obj) {\r\n      const finalObj = obj;\r\n      Object.keys(finalObj).forEach((key) => {\r\n        setEnvVar(context, key, finalObj[key], isFallback);\r\n      });\r\n    }\r\n  };\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const itemPath: string = path.join(src, f);\r\n\r\n      if (fse.statSync(itemPath).isDirectory()) {\r\n        continue;\r\n      }\r\n      runFunc(itemPath);\r\n    }\r\n  };\r\n\r\n  // ignore dirs, include all files on empty filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    src,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    true,\r\n    true\r\n  );\r\n\r\n  // expect it is a single file\r\n  if (!handled) {\r\n    runFunc(src);\r\n  }\r\n};\r\n","import fs from 'fs';\r\nimport { processWithGlobSync } from 'glob_handler';\r\nimport { logv } from 'loggers';\r\nimport path from 'path';\r\nimport { TaskContext, TaskSetVar } from 'task_data';\r\nimport { setTaskVar } from 'task_utils';\r\nimport {\r\n  checkLegacyUsage,\r\n  checkTypeOrThrow,\r\n  checkEmptyStringOrThrow,\r\n  loadFileOrThrow,\r\n  parseJson,\r\n  parseLines,\r\n  resolveStringArray,\r\n} from 'utils';\r\n\r\nexport const handleSetVar = async (context: TaskContext, task: TaskSetVar) => {\r\n  checkLegacyUsage(task, 'var');\r\n  checkLegacyUsage(task, 'varType');\r\n  checkLegacyUsage(task, 'fileFormat');\r\n\r\n  checkTypeOrThrow('key', task.key, ['string']);\r\n  checkEmptyStringOrThrow('key', task.key);\r\n\r\n  if (task.isFallback !== true) {\r\n    task.isFallback = false;\r\n  }\r\n  const isFallback: boolean = task.isFallback;\r\n\r\n  if (task.value !== undefined) {\r\n    const value = task.value;\r\n    setTaskVar(context, task.key, value, isFallback);\r\n  }\r\n\r\n  if (!task.src) return;\r\n  checkTypeOrThrow('src', task.src, ['string']);\r\n\r\n  const src = task.src as string;\r\n  const parser = task.parser || 'auto';\r\n  logv(`Parser = ${parser}`);\r\n\r\n  const runFunc = (filePath: string) => {\r\n    const varsPath = path.resolve(filePath);\r\n    let obj: any | undefined;\r\n    const content = loadFileOrThrow(varsPath);\r\n\r\n    if (parser === 'auto' || parser === 'json') {\r\n      try {\r\n        logv('Trying to parse as JSON.');\r\n        obj = parseJson(content);\r\n      } catch (e) {\r\n        if (parser === 'json') throw e;\r\n      }\r\n    }\r\n\r\n    if (!obj && (parser === 'auto' || parser === 'lines')) {\r\n      logv('Trying to parse as lines.');\r\n      obj = parseLines(content);\r\n    }\r\n\r\n    if (!obj && (parser === 'auto' || parser === 'string')) {\r\n      obj = content;\r\n    }\r\n\r\n    setTaskVar(context, task.key, obj, isFallback);\r\n  };\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const itemPath: string = path.join(src, f);\r\n      if (fs.statSync(itemPath).isDirectory()) {\r\n        continue;\r\n      }\r\n      runFunc(itemPath);\r\n    }\r\n  };\r\n\r\n  // ignore dirs, include all files on empty filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    src,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    true,\r\n    true\r\n  );\r\n\r\n  // expect it is a single file\r\n  if (!handled) {\r\n    runFunc(src);\r\n  }\r\n};\r\n","import { execSync } from \"child_process\";\r\nimport { logv } from \"loggers\";\r\nimport { TaskContext, TaskTerminalCommand } from \"task_data\";\r\n\r\nexport const handleTerminalCommand = async (context: TaskContext, task: TaskTerminalCommand) => {\r\n  logv(`Start execution... ${task.cmd}`);\r\n  execSync(task.cmd, {\r\n    shell: task.shell,\r\n    // cwd: cwd,\r\n    env: process.env,\r\n    stdio: [process.stdin, process.stdout, process.stderr],\r\n    encoding: \"utf-8\",\r\n  });\r\n};\r\n","import fs from 'fs';\r\nimport { removeSync } from 'fs-extra';\r\nimport { logv } from 'loggers';\r\nimport path from 'path';\r\nimport { TaskContext, TaskSymlink } from 'task_data';\r\n\r\nexport const handleFsSymlink = async (context: TaskContext, task: TaskSymlink) => {\r\n  const target: string = path.resolve(task.target);\r\n  const dstPath: string = path.resolve(task.path);\r\n\r\n  if (fs.existsSync(dstPath)) {\r\n    const lstat: fs.Stats = fs.lstatSync(dstPath);\r\n    logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\r\n    if (task.forced) {\r\n      if (lstat.isSymbolicLink() || lstat.isFile()) {\r\n        logv(`Unlink ${dstPath}`);\r\n        fs.unlinkSync(dstPath);\r\n      } else if (lstat.isDirectory()) {\r\n        logv(`Remove directory '${dstPath}'`);\r\n        removeSync(dstPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (fs.existsSync(dstPath)) {\r\n    logv(`Could not create symbolic link cause '${dstPath}' already exists`);\r\n    // throw Error()\r\n  } else {\r\n    logv(`Create symbolic link ${target} => ${dstPath}`);\r\n    fs.symlinkSync(target, dstPath, task.linkType);\r\n    const lstat: fs.Stats = fs.lstatSync(dstPath);\r\n    logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\r\n  }\r\n};\r\n","import fs from \"fs\";\r\nimport path from \"path\";\r\nimport simpleGit, { CheckRepoActions, ResetMode } from \"simple-git\";\r\nimport { TaskContext, TaskGitCheckout } from \"task_data\";\r\n\r\nexport const handleGitRepoSetup = async (context: TaskContext, task: TaskGitCheckout) => {\r\n  const localPath = path.resolve(task.localPath);\r\n\r\n  if (!fs.existsSync(localPath)) {\r\n    fs.mkdirSync(localPath, { recursive: true });\r\n  }\r\n\r\n  if (fs.readdirSync(localPath).length === 0) {\r\n    if (task.url) {\r\n      await simpleGit().clone(task.url, localPath);\r\n    }\r\n  }\r\n\r\n  const git = simpleGit(localPath, { binary: task.binary });\r\n\r\n  const isGitRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);\r\n  if (!isGitRepo) {\r\n    throw Error(`${localPath} is not a git repository!!!`);\r\n  }\r\n\r\n  if (task.updateSubmodules) {\r\n    await git.submoduleInit();\r\n    await git.submoduleUpdate();\r\n  } else {\r\n    // const submodules = task.updateSubmodules ?? [];\r\n    // for(var submod of submodules){\r\n    // }\r\n  }\r\n\r\n  await git.fetch();\r\n\r\n  if (task.branch) {\r\n    let hasLocalBranch = false;\r\n    const branchLocal = await git.branchLocal();\r\n    for (var b of branchLocal.all) {\r\n      if (b === task.branch) {\r\n        hasLocalBranch = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    const branch = task.branch ?? \"\";\r\n    const startPoint: string = task.startPoint ?? \"\";\r\n\r\n    if (!hasLocalBranch) {\r\n      await git.checkoutBranch(branch, startPoint);\r\n    } else {\r\n      if (branchLocal.current !== task.branch) {\r\n        await git.checkout(branch);\r\n      }\r\n      await git.reset(ResetMode.HARD, [startPoint]);\r\n    }\r\n  }\r\n};\r\n","import { handleSubTasks } from './tasks/handleSubTasks';\r\nimport { handleContentReplace } from './tasks/handleContentReplace';\r\nimport { handleMkdir } from 'tasks/handleFsMkdir';\r\nimport { handleFsDelete } from 'tasks/handleFsDelete';\r\nimport { handleFsCopy } from 'tasks/handleFsCopy';\r\nimport { handleOutput } from 'tasks/handleOutput';\r\nimport { handleEnvVar } from 'tasks/handleEnvVar';\r\nimport { handleSetVar } from 'tasks/handleSetVar';\r\nimport { handleTerminalCommand } from 'tasks/handleTerminalCommand';\r\nimport { handleFsSymlink } from 'tasks/handleFsSymlink';\r\nimport { handleGitRepoSetup } from 'tasks/handleGitRepoSetup';\r\nimport { TaskContext, TaskType } from './task_data';\r\n\r\nexport const handlerMap: {\r\n  [k in TaskType]: (context: TaskContext, task: any) => Promise<void>;\r\n} = {\r\n  'git-repo-prepare': handleGitRepoSetup,\r\n  cmd: handleTerminalCommand,\r\n  'set-var': handleSetVar,\r\n  output: handleOutput,\r\n  symlink: handleFsSymlink,\r\n  'fs-copy': handleFsCopy,\r\n  'fs-del': handleFsDelete,\r\n  'fs-mkdir': handleMkdir,\r\n  'env-var': handleEnvVar,\r\n  'sub-tasks': handleSubTasks,\r\n  'content-replace': handleContentReplace,\r\n};\r\n"],"mappings":"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","names":["src_exports","__export","usefulTasks","__toCommonJS","import_path","import_commander","import_path","DEFAULT_CONFIG","DEFAULT_USE_CAMEL","CwdRestore","CwdKeep","cwdModes","LogLevelInfo","LogLevelDebug","LogLevelNone","logLevels","argDesc","v","setup","userArgv","program","typedOptions","fixStringArrayArgument","path","value","skipEmptyItem","result","trimedValue","import_path","import_fs","import_path","import_json5","import_debug","LOG_TAG","TAG_DEBUG","TAG_INFO","TAG_WARN","DEFAULT_REPLACE_REGEX","VAR_FROM_ARGUMENT_PREFIX","ENV_VAR_FROM_ARGUMENT_PREFIX","logw","debug","TAG_WARN","logi","TAG_INFO","logv","TAG_DEBUG","loadFileOrThrow","filePath","logv","fs","loadJson","parseJson","content","json5","loadJsonConfig","configJson","filePathDir","path","extendsFilePath","convertOrNotHyphenTextToCamelText","text","flag","result","textArr","i","word","containsTag","elements","tags","el","tag","containsAllTag","contained","checkEmptyStringOrThrow","name","value","checkLegacyUsage","task","key","logw","checkType","allowedTypes","checkTypeOrThrow","valueType","ENV_LINE","parseLines","src","obj","lines","match","maybeQuote","throwInvalidParamError","resolveStringArray","val","defaultValue","v","import_debug","applyVariables","context","task","anyTypeTask","key","valueOfKey","match","matchedStr","varPath","currentVar","varPaths","i","varEl","valuePrefix","valueReplace","valueSuffix","logv","searchExtraKeyValue","extraArgs","fmt","convertToCamelKeys","callback","currentVarName","useNextElementAsVar","extraArg","value","equalMarkIndex","varName","convertOrNotHyphenTextToCamelText","setTaskVar","skipForExists","setEnvVar","valueType","import_string_argv","handleSubTasks","context","task","subArgv","stringArgv","setupResult","setup","usefulTasks","import_fs","import_path","import_fs","import_glob","processWithGlobSync","handler","cwd","includes","excludes","skipDirs","includeAllIfNonFilters","fs","nodir","ilen","elen","runFindAndReplaceWithRegex","content","find","replace","repeat","text","i","runFindAndReplaceWithText","isRegexData","v","findAndReplaceWithFile","path","replaceFunc","logv","fs","newContent","handleContentReplace","context","task","throwInvalidParamError","loop","regexData","processWithGlobSync","items","f","itemPath","resolveStringArray","import_fs_extra","handleMkdir","context","task","checkTypeOrThrow","logv","import_fs","import_path","import_fs_extra","runDelete","path","logv","handleFsDelete","context","task","fs","processWithGlobSync","items","f","resolveStringArray","import_path","import_fs_extra","runCopy","src","dst","options","logv","handleFsCopy","context","task","fse","conflict","overwrite","cpOpt","processWithGlobSync","items","f","from","path","to","resolveStringArray","import_fs","import_fs_extra","import_path","handleOutput","context","task","text","target","targetPath","resolvedPath","path","dir","fs","err","fd","e","import_fs_extra","import_path","handleEnvVar","context","task","checkLegacyUsage","isFallback","value","logv","parseLines","key","setEnvVar","checkTypeOrThrow","src","parser","runFunc","filePath","varsPath","path","obj","content","loadFileOrThrow","parseJson","e","finalObj","processWithGlobSync","items","f","itemPath","fse","resolveStringArray","import_fs","import_path","handleSetVar","context","task","checkLegacyUsage","checkTypeOrThrow","checkEmptyStringOrThrow","isFallback","value","setTaskVar","src","parser","logv","runFunc","filePath","varsPath","path","obj","content","loadFileOrThrow","parseJson","e","parseLines","processWithGlobSync","items","f","itemPath","fs","resolveStringArray","import_child_process","handleTerminalCommand","context","task","logv","import_fs","import_fs_extra","import_path","handleFsSymlink","context","task","target","path","dstPath","fs","lstat","logv","import_fs","import_path","import_simple_git","handleGitRepoSetup","context","task","localPath","path","fs","simpleGit","git","hasLocalBranch","branchLocal","b","branch","startPoint","handlerMap","handleGitRepoSetup","handleTerminalCommand","handleSetVar","handleOutput","handleFsSymlink","handleFsCopy","handleFsDelete","handleMkdir","handleEnvVar","handleSubTasks","handleContentReplace","usefulTasks","originCwd","opt","program","tasksConfig","configFilePath","path","loadJsonConfig","e","debugPat","logLevel","replaceRegex","DEFAULT_REPLACE_REGEX","env","logLevels","TAG_WARN","TAG_INFO","TAG_DEBUG","debug","logv","baseCwd","context","searchExtraKeyValue","VAR_FROM_ARGUMENT_PREFIX","key","value","setTaskVar","ENV_VAR_FROM_ARGUMENT_PREFIX","setEnvVar","logi","getTaskRepresentStr","task","i","tasks","j","otherTask","handlerMap","printInvalidTags","tags","tag","excludeItems","taskItem","index","array","containsTag","excludesItems","containsAllTag","hasIncludeFilters","hasIncludeCTAFilters","includeItems","includeCtaItems","v","taskCount","applyVariables","taskRepresentStr","cwdHasChanges","taskCwd","taskHandler","reason","originCwd","path","setupResult","setup","usefulTasks"]}