{"version":3,"sources":["../src/index.ts","../src/build_cli_parser.ts","../src/useful_tasks.ts","../src/utils.ts","../src/task_data.ts","../src/loggers.ts","../src/task_utils.ts","../src/handler_sub_tasks.ts","../src/handlers.ts","../src/glob_handler.ts","../src/handler_map.ts"],"sourcesContent":["#!/usr/bin/env node\r\n\r\nimport path from 'path';\r\nimport { setup } from './build_cli_parser';\r\nimport { usefulTasks } from './useful_tasks';\r\nexport { usefulTasks } from './useful_tasks';\r\n\r\nconst originCwd = path.resolve(process.cwd());\r\nconst setupResult = setup();\r\nusefulTasks(originCwd, setupResult.opt, setupResult.program);","import { Command } from 'commander';\r\nimport path from 'path';\r\n\r\nexport const DEFAULT_CONFIG = \"useful_tasks.json\";\r\nexport const DEFAULT_USE_CAMEL = true;\r\n\r\nexport const CwdRestore = 'restore';\r\nexport const CwdKeep = 'keep';\r\n\r\nexport const cwdModes = [CwdRestore, CwdKeep] as const;\r\ntype CwdModeTuple = typeof cwdModes;\r\nexport type CwdMode = CwdModeTuple[number];\r\n\r\nconst LogLevelInfo = 'info';\r\nconst LogLevelDebug = 'debug';\r\nconst LogLevelNone = 'none';\r\nexport const logLevels = [LogLevelNone, LogLevelInfo, LogLevelDebug] as const;\r\ntype LogLevelTuple = typeof logLevels;\r\nexport type LogLevel = LogLevelTuple[number];\r\n\r\nexport interface Options {\r\n    cwd?:string;\r\n    config:string;\r\n    include?:string[];\r\n    includeCta?:string[];\r\n    exclude?:string[];\r\n    excludeCta?:string[];\r\n    camelKeys:boolean;\r\n    cwdMode?:CwdMode;\r\n    cwdModeIsContinue?:boolean;\r\n    logLevel?:LogLevel;\r\n    extraArgs?:string[];\r\n}\r\n\r\n\r\nconst argDesc = {\r\n    cwdMode:`Choose between ${cwdModes.map((v)=>`'${v}'`).join(' or ')}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${CwdRestore}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${CwdKeep}' mode, the CWD will remain unchanged.`\r\n}\r\n\r\nexport const setup = (userArgv?:string[])=> {\r\n    // console.log('cwd', process.cwd());\r\n    // console.log('argv', process.argv);\r\n\r\n    const program = new Command();\r\n    program.name('useful-tasks').version(process.env.npm_package_version!)\r\n    .option('--cwd <string>','Change working directory')\r\n    .option('-c, --config <string>','A path of json configuraion', DEFAULT_CONFIG)\r\n    .option('-i, --include <items>','Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\r\n    .option('-a, --include-cta <items>','Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\r\n    .option('-e, --exclude <items>','Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\r\n    .option('-x, --exclude-cta <items>','Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\r\n    .option('--camel-keys <boolean>','Specify whether to use camel case for the key of the variable. If the value is true, the paramter \"--var-my-key\" will be converted to \"myKey\" otherwise it will be \"my-key\"', DEFAULT_USE_CAMEL)\r\n    .option('--cwd-mode <string>',argDesc.cwdMode, CwdRestore)\r\n    .option('--log-level <string>', `Specify the logging level as ${logLevels.join(',')}. This parameter takes higher priority than the 'json' configuration.`)\r\n    .allowUnknownOption(true);\r\n    \r\n    if(userArgv !== undefined){\r\n        program.parse(userArgv, {from:'user'});\r\n    }else{\r\n        program.parse();\r\n    }\r\n\r\n    const opts = program.opts();\r\n    // console.log(opts);\r\n\r\n    const typedOptions = opts as Options;\r\n    typedOptions.include = fixStringArrayArgument(typedOptions.include);\r\n    typedOptions.includeCta = fixStringArrayArgument(typedOptions.includeCta);\r\n    typedOptions.exclude = fixStringArrayArgument(typedOptions.exclude);\r\n    typedOptions.excludeCta = fixStringArrayArgument(typedOptions.excludeCta);\r\n    \r\n    typedOptions.cwdModeIsContinue = typedOptions.cwdMode === CwdKeep;\r\n    \r\n    if(typedOptions.camelKeys !== undefined && typeof(typedOptions.camelKeys) === 'string'){\r\n        let v:string = typedOptions.camelKeys;\r\n        v = v.trim().toLowerCase();\r\n        if(v === 'false' || v === '0' || v === 'no'){\r\n            typedOptions.camelKeys = false;\r\n        }else if(v==='true' || v==='1' || v === 'yes'){\r\n            typedOptions.camelKeys = true;\r\n        }else{\r\n            typedOptions.camelKeys = DEFAULT_USE_CAMEL;\r\n        }\r\n    }\r\n    typedOptions.extraArgs = [...program.args ?? []];\r\n\r\n    // console.log(`Using options : ${JSON.stringify(typedOptions, undefined, 2)}`);\r\n    // console.log(`Extra arguments`, program.args);\r\n\r\n    if(typedOptions.cwd){\r\n        process.chdir(path.resolve(typedOptions.cwd));\r\n    }\r\n\r\n    // console.log(\"######################################################################\")\r\n\r\n    return {opt:typedOptions, program};\r\n}\r\n\r\nconst fixStringArrayArgument = (value:string|string[]|undefined, skipEmptyItem:boolean = true)=>{\r\n    if(!value){\r\n        return [];\r\n    }\r\n    \r\n    if(typeof value === 'string'){\r\n        const result:string[] = [];\r\n        const arr = value.split(',');\r\n        arr.forEach((value)=>{\r\n            const trimedValue = value.trim();\r\n            if(skipEmptyItem){\r\n                if(trimedValue.length > 0){\r\n                    result.push(trimedValue);\r\n                }\r\n            }else{\r\n                result.push(trimedValue);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    \r\n    return [];\r\n};\r\n","import path from 'path';\r\nimport { LogLevel, Options, logLevels } from './build_cli_parser';\r\nimport { containsAllTag, containsTag, loadJsonConfig } from './utils';\r\nimport debug from 'debug';\r\nimport { Config, TAG_DEBUG, Task, TaskContext, DEFAULT_REPLACE_REGEX, VAR_FROM_ARGUMENT_PREFIX,  ENV_VAR_FROM_ARGUMENT_PREFIX, LOG_TAG, TAG_INFO } from './task_data';\r\nimport { applyVariables, searchExtraKeyValue, setTaskVar, setEnvVar } from './task_utils';\r\nimport { Command } from 'commander';\r\nimport { handlerMap } from './handler_map';\r\nimport { logi, logv } from './loggers';\r\n\r\nexport const usefulTasks = (originCwd:string, opt:Options, program:Command)=>{\r\n    let tasksConfig:Config = {};\r\n\r\n    let configFilePath = path.resolve(opt.config);\r\n    try{\r\n        tasksConfig = loadJsonConfig(configFilePath);\r\n    }catch(e:any){\r\n        if(e instanceof Error){\r\n            console.log(e.message);\r\n        }else{\r\n            console.log(e);\r\n        }\r\n        console.log(\"\");\r\n        program.help();\r\n    }\r\n    \r\n    let debugPat:string | undefined;\r\n    \r\n    let logLevel:LogLevel = 'info';\r\n    let replaceRegex = DEFAULT_REPLACE_REGEX;\r\n    if(tasksConfig.env && typeof(tasksConfig.env) === 'object'){\r\n        const env = tasksConfig.env;\r\n        \r\n        if(env.verbose || env.verboseGit){\r\n            logLevel = 'debug';\r\n        }\r\n\r\n        if(env.logLevel && logLevels.includes(env.logLevel)){\r\n            logLevel = env.logLevel;\r\n        }\r\n    \r\n        if(env.replaceRegex){\r\n            replaceRegex = env.replaceRegex;\r\n        }\r\n    }\r\n\r\n    //cli argument can overwrite json's logLeve\r\n    if(opt.logLevel && logLevels.includes(opt.logLevel)){\r\n        logLevel = opt.logLevel;\r\n    }\r\n\r\n    if(logLevel === 'debug'){\r\n        // debugPat = `${LOG_TAG}:*`;\r\n        debugPat = `${TAG_INFO},${TAG_DEBUG}`;\r\n        debugPat = `${debugPat},simple-git,simple-git:*`;\r\n    }else if(logLevel === 'info'){\r\n        debugPat = `${TAG_INFO}`;\r\n    }\r\n    \r\n    if(debugPat){\r\n        debug.enable(debugPat);\r\n    }\r\n\r\n    logv(`CLI Options`, opt);\r\n\r\n    if(typeof(replaceRegex) !== 'string'){\r\n        throw new Error(`replaceRegex '${replaceRegex}'  must be a string`);\r\n    }\r\n    if(replaceRegex.length < 1){\r\n        throw new Error(`replaceRegex '${replaceRegex}' cannot be empty`);\r\n    }\r\n    if(replaceRegex.indexOf('(') < 0 || replaceRegex.indexOf(')') < 0){\r\n        throw new Error(`replaceRegex '${replaceRegex}' must contain regex group express '(' and ')'`);\r\n    }\r\n    \r\n    const baseCwd = path.resolve(process.cwd());\r\n    \r\n    const context:TaskContext = {\r\n        originCwd,\r\n        baseCwd,\r\n        replaceRegex:new RegExp(replaceRegex),\r\n        vars:{\r\n            __env:{\r\n                cwd_startup:originCwd,\r\n                cwd_base:baseCwd\r\n            }\r\n        }\r\n    };\r\n    \r\n    if(opt.extraArgs){\r\n        logv(\"Setting up the variables from the additional arguments\");\r\n        searchExtraKeyValue(opt.extraArgs, VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\r\n            setTaskVar(context, key, value, false);\r\n        });\r\n    \r\n        logv(\"Setting up the environment variables from the additional arguments\");\r\n        searchExtraKeyValue(opt.extraArgs, ENV_VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\r\n            setEnvVar(context, key, value, false);\r\n        });\r\n    }\r\n    \r\n    logi(\"\");\r\n    logi(`[${tasksConfig.name}] Start task processing`);\r\n    \r\n    const getTaskRepresentStr = (task:Task, i?:number)=>{ \r\n        if(i !== undefined && i !== null){\r\n            return task.id !== undefined ? `[${i}]${task.id}/${task.type}` : `[${i}]${task.type}`;\r\n        }else{\r\n            return task.id !== undefined ? `${task.id}/${task.type}` : `${task.type}`;\r\n        }\r\n    };\r\n    \r\n    const runTasks = async ()=>{\r\n        let tasks:Array<Task> = tasksConfig.tasks ?? [];\r\n    \r\n        for(let i=0;i<tasks.length;i++){\r\n            const task = tasks[i];\r\n\r\n            // Validate task IDs\r\n            if(task.id !== undefined && task.id !== null){\r\n                if(typeof(task.id) !== 'string'){\r\n                    throw new Error(`The task id must be a 'string' type`);\r\n                }\r\n    \r\n                if(task.id.length<1){\r\n                    throw new Error(`The task id cannot be empty`);\r\n                }\r\n    \r\n                for(let j=i+1;j<tasks.length;j++){\r\n                    const otherTask = tasks[j];\r\n                    if(otherTask.id !== undefined && otherTask.id === task.id){\r\n                        throw new Error(`The task id '${task.id}' must be unique`);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(!task.type || !(task.type in handlerMap)){\r\n                throw new Error(`Found the invalid task type '${task.type}'`);\r\n            }\r\n            \r\n            task.__compare__elements = [];\r\n            if(task.id){\r\n                task.id = task.id.trim()\r\n                task.__compare__elements.push(task.id.trim());\r\n            }\r\n            if(task.tags){\r\n                const printInvalidTags = (tags:any)=>{\r\n                    logv(`Ignoring invalid tags '${tags}'`);\r\n                };\r\n                if(typeof(task.tags) === 'string'){\r\n                    if(task.tags.length > 0){\r\n                        task.tags = task.tags.trim();\r\n                        task.__compare__elements.push(task.tags);\r\n                    }else{\r\n                        printInvalidTags(task.tags);\r\n                    }\r\n                }else if(Array.isArray(task.tags)){\r\n                    task.tags = task.tags.map((value:string)=>value.trim());\r\n                    for(const tag of task.tags){\r\n                        if(typeof(tag) === 'string' && tag.length>0){\r\n                            task.__compare__elements.push(tag);\r\n                        }else{\r\n                            printInvalidTags(tag);\r\n                        }\r\n                    }\r\n                }else{\r\n                    printInvalidTags(task.tags);\r\n                }\r\n            }\r\n        }\r\n    \r\n        if(opt.exclude && opt.exclude.length > 0){\r\n            const excludeItems = opt.exclude;\r\n    \r\n            logv(`Excluding tasks by specified IDs or Tags : --exclude=${excludeItems}`);\r\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\r\n                if(containsTag(excludeItems, taskItem.__compare__elements) === false){\r\n                    return taskItem;\r\n                }\r\n            });\r\n        }\r\n        if(opt.excludeCta && opt.excludeCta.length > 0){\r\n            const excludesItems = opt.excludeCta;\r\n    \r\n            logv(`Excluding tasks by specified IDs or Tags : --exclude-cta=${excludesItems}`);\r\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\r\n                if(containsAllTag(excludesItems, taskItem.__compare__elements) === false){\r\n                    return taskItem;\r\n                }\r\n            });\r\n        }\r\n        const hasIncludeFilters = opt.include && opt.include.length > 0;\r\n        const hasIncludeCTAFilters = opt.includeCta && opt.includeCta.length > 0;\r\n        if(hasIncludeFilters || hasIncludeCTAFilters){\r\n            const includeItems = opt.include;\r\n            const includeCtaItems = opt.includeCta;\r\n    \r\n            logv(`Including tasks by specified IDs or Tags : --include=${includeItems} / --include-cta=${includeCtaItems}`);\r\n            tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\r\n                if(\r\n                    (hasIncludeFilters && containsTag(includeItems!, taskItem.__compare__elements) === true)\r\n                    ||\r\n                    (hasIncludeCTAFilters && containsAllTag(includeCtaItems!, taskItem.__compare__elements) === true)\r\n                ){\r\n                    return taskItem;\r\n                }\r\n            });\r\n        }\r\n    \r\n        logi(`Tasks : ${tasks.map((v,i)=>{ return getTaskRepresentStr(v,i);})}`);\r\n    \r\n        const taskCount = tasks.length ?? 0;\r\n        for(let i=0;i<taskCount; i++){\r\n            const task = tasks[i];\r\n            applyVariables(context, task);\r\n    \r\n            const taskRepresentStr = getTaskRepresentStr(task,i);\r\n            if(task.enabled === false){\r\n                logi(`\\n### Skip the task without execution => ${taskRepresentStr}`);\r\n                continue;\r\n            }else{\r\n                logi(`\\n### Task : ${taskRepresentStr}`)\r\n            }\r\n    \r\n            if(task.comment){\r\n                logi(task.comment);\r\n            }\r\n    \r\n            let cwdHasChanges = false;\r\n            if(task.cwd){\r\n                const taskCwd = path.resolve(task.cwd);\r\n                logi(`Changing the current working directory => ${taskCwd}`);\r\n                cwdHasChanges = true;\r\n                process.chdir(taskCwd);\r\n            }\r\n            \r\n            const taskHandler = handlerMap[task.type];\r\n            await taskHandler(context, task);\r\n    \r\n            if(!opt.cwdModeIsContinue){\r\n                if(cwdHasChanges){\r\n                    logi(`Restoring the current working directory => ${baseCwd}`);\r\n                }\r\n                process.chdir(baseCwd);\r\n            }\r\n        }\r\n    };\r\n    \r\n    runTasks().then(()=>{}).catch((reason:any)=>{\r\n        throw reason;\r\n    }).finally(()=>{\r\n        process.chdir(baseCwd);\r\n        logi(`[${tasksConfig.name}] Tasks done\\n`);\r\n    });\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\nimport json5 from 'json5';\r\n\r\nexport const loadFileOrThrow = (filePath:string)=>{\r\n    if(!fs.existsSync(filePath)){\r\n        throw new Error(`ERROR: The Path '${filePath}' does not exists!`);\r\n    }\r\n\r\n    return fs.readFileSync(filePath, {encoding:'utf-8'});\r\n}\r\n\r\nexport const loadJson = (filePath:string)=>{\r\n    return parseJson(loadFileOrThrow(filePath));\r\n};\r\n\r\nexport const parseJson = (content:string)=>json5.parse(content);\r\n\r\nexport const loadJsonConfig = (filePath:string)=>{\r\n    let configJson = loadJson(filePath);\r\n    if(configJson.extends){\r\n        const filePathDir = path.dirname(filePath);\r\n        const extendsFilePath = path.resolve(filePathDir, configJson.extends);\r\n        configJson = Object.assign({}, configJson, loadJsonConfig(extendsFilePath));\r\n    }\r\n    \r\n    return configJson;\r\n};\r\n\r\nexport const convertOrNotHyphenTextToCamelText=(text:string, flag:boolean)=>{\r\n    if(!flag){\r\n        return text;\r\n    }\r\n\r\n    let result = '';\r\n    let textArr = text.split(\"-\");\r\n    for(let i=0;i<textArr.length;i++){\r\n        let word = textArr[i];\r\n        if(i===0){\r\n            result = word;\r\n        }else{\r\n            if(word.length>0){\r\n                word = `${word[0].toUpperCase()}${word.substring(1)}`;\r\n            }\r\n            result = `${result}${word}`;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n\r\nexport const containsTag = (elements:string[], tags:string[])=>{\r\n    if(elements.length < 1){\r\n        return false;\r\n    }\r\n    \r\n    for(const el of elements){\r\n        for(const tag of tags){\r\n            if(el === tag){\r\n                return true;    \r\n            }\r\n        }        \r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nexport const containsAllTag = (elements:string[], tags:string[])=>{\r\n    if(elements.length < 1){\r\n        return false;\r\n    }\r\n    for(const el of elements){\r\n        let contained = false;\r\n        for(const tag of tags){\r\n            if(tag === el){\r\n                contained = true;\r\n                break;\r\n            }\r\n        }        \r\n        if(!contained){\r\n            return false;\r\n        }        \r\n    }\r\n    return true;\r\n};","import { LogLevel } from './build_cli_parser';\r\n\r\nexport interface TaskContext {\r\n    originCwd:string;\r\n    baseCwd:string;\r\n    replaceRegex:RegExp;\r\n    vars:any;\r\n}\r\n\r\nexport const allTaskTypes = ['git-repo-prepare','symlink','cmd','set-var','output','fs-copy','fs-del','env-var','sub-tasks', 'content-replace'] as const;\r\ntype TasksTuple = typeof allTaskTypes;\r\nexport type TaskType = TasksTuple[number];\r\n\r\nexport interface Task {\r\n    type:TaskType;\r\n    id?:string;\r\n    tags?:string | string[],\r\n    cwd?:string;\r\n    enabled?:boolean;\r\n    comment?:string;\r\n    __compare__elements:string[];\r\n\r\n    //TODO:\r\n    /** The process will not be interrupted even if errors are caught from this task. */\r\n    allowError?:boolean;\r\n}\r\n\r\nexport interface TaskGitCheckout extends Task{\r\n    /** Executable git binary */\r\n    binary?:string;\r\n    url?:string;\r\n    localPath:string;\r\n    branch?:string;\r\n    startPoint?:string;\r\n    updateSubmodules?:Array<string> | string | boolean;\r\n}\r\n\r\nexport interface TaskSymlink extends Task{\r\n    target:string;\r\n    path:string;\r\n    linkType?:'dir' | 'file' | 'junction';\r\n    forced?:boolean;\r\n}\r\n\r\nexport interface TaskTerminalCommand extends Task{\r\n    cmd:string;\r\n    shell?:string;\r\n}\r\n\r\n//TODO: Use value as 'value', file as 'path'.\r\nexport interface TaskSetVar extends Task{\r\n    key:string;\r\n    value:string|number|boolean|any;\r\n    varType:'value'|'file';\r\n    //TODO: Implement lines, auto\r\n    fileFormat?:'json'|'string'|'lines'|'auto';\r\n\r\n    /** If the variable already exists, assigning will be skipped */\r\n    isFallback?:boolean;\r\n\r\n    /** @deprecated replaced as \"value\" */\r\n    var?:string|number|boolean|any;\r\n}\r\n\r\n/** TODO: Use value as a 'value', file as a 'path'. */\r\nexport interface TaskEnvVar extends Task{\r\n    value:object | string;\r\n    varType:'dict'|'file';\r\n\r\n    //TODO: Implement all\r\n    fileFormat?:'json'|'lines'|'auto';\r\n\r\n    /** If the environment variable already exists, assigning will be skipped */\r\n    isFallback?:boolean;\r\n\r\n    /** @deprecated replaced as \"value\" */\r\n    var?:any;\r\n}\r\n\r\nexport type TaskOutputTargets = 'console'|'file-write'|'file-append'|'c'|'fw'|'fa';\r\nexport interface TaskOutput extends Task{\r\n    text:string;\r\n    target:TaskOutputTargets;\r\n    path?:string;\r\n}\r\n\r\nexport interface GlobFilters {\r\n    include?:string | string[];\r\n    exclude?:string | string[];\r\n}\r\n\r\nexport type TaskFsCopyOptions = {\r\n    conflict?:'overwrite'|'skip';\r\n};\r\n\r\nexport interface TaskFsCopy extends Task, GlobFilters {\r\n    src:string;\r\n    dest:string;\r\n    options?:TaskFsCopyOptions;\r\n}\r\n\r\nexport interface TaskFsDelete extends Task, GlobFilters{\r\n    path:string;\r\n}\r\n\r\nexport interface TaskSubTasks extends Task{\r\n    args:string;\r\n}\r\n\r\nexport interface RegexData {\r\n    pattern:string;\r\n    flags?:string;\r\n}\r\n\r\nexport interface TaskContentReplace extends Task, GlobFilters {\r\n    /** \r\n     * If the task includes 'include' or 'exclude', it will be handled as a directory. \r\n     * Otherwise, it will be processed as a file.\r\n     */\r\n    path:string;\r\n\r\n    find:string | RegexData;\r\n    replace:string;\r\n    loop?:number;\r\n}\r\n\r\nexport interface Config {\r\n    name?:string;\r\n    \r\n    env?:{\r\n        logLevel?:LogLevel;\r\n        /** @deprecated */\r\n        verbose?:boolean;\r\n        /** @deprecated */\r\n        verboseGit?:boolean;\r\n        replaceRegex?:string;\r\n    };\r\n    tasks?:Array<Task>;\r\n}\r\n\r\nexport const LOG_TAG = \"useful-tasks\";\r\nexport const TAG_DEBUG = `${LOG_TAG}:debug`;\r\nexport const TAG_INFO = `${LOG_TAG}:info`;\r\n\r\n/** e.g. ${value.key} */\r\nexport const DEFAULT_REPLACE_REGEX = \"\\\\$\\\\{([a-zA-Z0-9\\\\.\\\\-_]*)\\\\}\";\r\n\r\nexport const VAR_FROM_ARGUMENT_PREFIX = \"--var-\";\r\nexport const ENV_VAR_FROM_ARGUMENT_PREFIX = \"--env-\";","import debug from \"debug\";\r\nimport { TAG_DEBUG, TAG_INFO } from \"./task_data\";\r\n\r\nexport const logv = debug(TAG_DEBUG);\r\nexport const logi = debug(TAG_INFO);","import { logv } from \"./loggers\";\r\nimport { Task, TaskContext } from \"./task_data\";\r\nimport { convertOrNotHyphenTextToCamelText, loadJson } from './utils';\r\n\r\nexport const applyVariables = async (context:TaskContext, task:Task)=>{\r\n    const anyTypeTask:any = task as any;\r\n    for(const key of Object.keys(anyTypeTask)) {\r\n        if(typeof(key) !== 'string'){\r\n            continue;\r\n        }\r\n        \r\n        if(key === 'id' || key === 'tags'){\r\n            continue;   \r\n        }\r\n        \r\n        if(anyTypeTask[key] !== undefined && typeof(anyTypeTask[key]) ==='string'){\r\n            let valueOfKey:string = anyTypeTask[key];\r\n            while(true){\r\n                const match = context.replaceRegex.exec(valueOfKey);\r\n                if(match === null || match === undefined){\r\n                    break;\r\n                }\r\n                \r\n                const matchedStr = match[0];\r\n                const varPath = match[1];\r\n\r\n                let currentVar = context.vars;\r\n                if(varPath.length > 0){\r\n                    const varPaths = varPath.split(\".\");\r\n                    for(let i=0; i<varPaths.length;i++){\r\n                        const varEl = varPaths[i];\r\n                        if(currentVar.hasOwnProperty(varEl)){\r\n                            currentVar = currentVar[varEl];\r\n                        }else{\r\n                            throw new Error(`The value of ${varPath} could not be found!`);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const valuePrefix = valueOfKey.substring(0, match.index);\r\n                const valueReplace = `${currentVar}`;\r\n                const valueSuffix = valueOfKey.substring(match.index+matchedStr.length);                    \r\n                valueOfKey = `${valuePrefix}${valueReplace}${valueSuffix}`;\r\n                logv(`Variable injection: '${key}'=>'${valueOfKey}'`);\r\n            }\r\n            \r\n            anyTypeTask[key] = valueOfKey;\r\n        }\r\n    }\r\n};\r\n\r\n\r\nexport const searchExtraKeyValue = (extraArgs:string[], fmt:string, convertToCamelKeys:boolean, callback:(key:string, value:string)=>void)=>{\r\n    let currentVarName:string|undefined;\r\n    let useNextElementAsVar:boolean = false;\r\n    \r\n    for(let extraArg of extraArgs){\r\n        const arg = extraArg.trim();\r\n        if(arg === '--'){\r\n            logv(\"Stop parsing by '--'\")\r\n            break;\r\n        }\r\n\r\n        if(useNextElementAsVar && currentVarName){\r\n            const value = extraArg.startsWith(\"-\") ? \"\":extraArg;\r\n            callback(currentVarName, value);\r\n            currentVarName = undefined;\r\n            useNextElementAsVar = false;\r\n        }else{\r\n            const prefixIndex = extraArg.indexOf(fmt);\r\n            if(prefixIndex >= 0){\r\n                const equalMarkIndex = extraArg.indexOf(\"=\");\r\n                if(equalMarkIndex >= 0){\r\n                    const varName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length, equalMarkIndex), convertToCamelKeys);\r\n                    const value = extraArg.substring(equalMarkIndex+1);\r\n                    callback(varName, value);\r\n                }else{\r\n                    currentVarName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length), convertToCamelKeys);\r\n                    useNextElementAsVar = true;\r\n                }\r\n            }    \r\n        }\r\n    }\r\n};\r\n\r\n\r\nexport const setTaskVar = (context:TaskContext, key:string, value:any, skipForExists:boolean)=>{\r\n    if(skipForExists && context.vars[key] !== undefined){\r\n        logv(`Skips assigning the variable ${key}=${value} because it already exists.`);\r\n        return;\r\n    }\r\n\r\n    logv(`Sets the variable ${key}=${value}`);\r\n    context.vars[key] = value;\r\n}\r\n\r\nexport const setEnvVar = (context:TaskContext, key:string, value:any, skipForExists:boolean)=>{\r\n    var valueType = typeof(value);\r\n    if(valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean'){\r\n        logv(`Ignoring the invalid typed(${valueType}) environment variable ${key}=${value}`);\r\n    }else{\r\n        const stringVal = String(value);\r\n        if(stringVal.length < 1){\r\n            logv(`Ignoring the invalid environment variable ${key}=${value}`);\r\n        }else{\r\n            if(skipForExists && process.env[key] !== undefined){\r\n                logv(`Skips assigning the environment variable ${key}=${value} because it already exists.`);\r\n                return;\r\n            }\r\n\r\n            logv(`Sets the environment variable ${key}=${value}`);\r\n            process.env[key] = String(value);\r\n        }\r\n    }\r\n}\r\n","import stringArgv from 'string-argv';\r\nimport { TaskContext, TaskSubTasks } from './task_data';\r\nimport { usefulTasks } from './useful_tasks';\r\nimport { setup } from './build_cli_parser';\r\n\r\nexport const handleSubTasks = async (context:TaskContext, task:TaskSubTasks)=>{\r\n    if(!task.args || typeof(task.args) !== 'string'){\r\n        throw new Error(`Found missing or invalid property 'args' that is required`);\r\n    }\r\n\r\n    const subArgv = stringArgv(task.args);\r\n    const setupResult = setup(subArgv);\r\n    usefulTasks(context.originCwd, setupResult.opt, setupResult.program);\r\n}\r\n","import fs from 'fs';\r\nimport { execSync } from 'child_process';\r\nimport path from 'path';\r\nimport {CheckRepoActions, ResetMode, simpleGit} from 'simple-git';\r\nimport { CopyOptionsSync, CopySyncOptions, copyFileSync, copySync, mkdirpSync, removeSync } from 'fs-extra'\r\nimport { TaskContext, TaskOutput, TaskSetVar, TaskGitCheckout, TaskSymlink, TaskTerminalCommand, TaskOutputTargets, TaskFsCopy, TaskFsDelete, TaskEnvVar, TaskContentReplace, RegexData } from './task_data';\r\nimport { loadFileOrThrow, loadJson, parseJson } from './utils';\r\nimport json5 from 'json5';\r\nimport { setEnvVar, setTaskVar } from './task_utils';\r\nimport { logi, logv } from './loggers';\r\nimport { processWithGlobSync } from './glob_handler';\r\n\r\nconst throwInvalidParamError = <T, K extends keyof T>(obj:T, key:K) => {\r\n    throw new Error(`The parameter '${String(key)}' has an invalid value ${obj[key]}`);\r\n};\r\n\r\nexport const handleGitRepoSetup = async (context:TaskContext, task:TaskGitCheckout)=>{\r\n    const localPath = path.resolve(task.localPath);\r\n\r\n    if(!fs.existsSync(localPath)){\r\n        fs.mkdirSync(localPath, {recursive:true});\r\n    }\r\n\r\n    if(fs.readdirSync(localPath).length === 0){\r\n        if(task.url){\r\n            await simpleGit().clone(task.url, localPath);\r\n        }\r\n    }\r\n\r\n    const git = simpleGit(localPath, {binary:task.binary});\r\n\r\n    const isGitRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);\r\n    if(!isGitRepo){\r\n        throw Error(`${localPath} is not a git repository!!!`);\r\n    }\r\n\r\n    \r\n    if(task.updateSubmodules){\r\n        await git.submoduleInit();\r\n        await git.submoduleUpdate();\r\n    }else{\r\n        // const submodules = task.updateSubmodules ?? [];\r\n        // for(var submod of submodules){\r\n        // }\r\n    }\r\n\r\n    await git.fetch();\r\n\r\n    if(task.branch){\r\n        let hasLocalBranch = false;\r\n        const branchLocal = await git.branchLocal();\r\n        for(var b of branchLocal.all){\r\n            if(b === task.branch){\r\n                hasLocalBranch = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        const branch = task.branch ?? \"\";\r\n        const startPoint:string = task.startPoint ?? \"\";\r\n\r\n        if(!hasLocalBranch){\r\n            await git.checkoutBranch(branch, startPoint)\r\n        }else{\r\n            if(branchLocal.current !== task.branch){\r\n                await git.checkout(branch);\r\n            }\r\n            await git.reset(ResetMode.HARD, [startPoint])\r\n        }\r\n    }\r\n}\r\n\r\nexport const handleSymlink = async (context:TaskContext, task:TaskSymlink)=>{\r\n    const target:string = path.resolve(task.target);\r\n    const dstPath:string = path.resolve(task.path);\r\n\r\n    if(fs.existsSync(dstPath)){\r\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\r\n        logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\r\n        if(task.forced){\r\n            if(lstat.isSymbolicLink() || lstat.isFile()){\r\n                logv(`Unlink ${dstPath}`);\r\n                fs.unlinkSync(dstPath);\r\n            }else if(lstat.isDirectory()){\r\n                logv(`Remove directory '${dstPath}'`);\r\n                removeSync(dstPath);\r\n            }\r\n        }\r\n    }\r\n\r\n    if(fs.existsSync(dstPath)){\r\n        logv(`Could not create symbolic link cause '${dstPath}' already exists`);\r\n        // throw Error()\r\n    }else{\r\n        logv(`Create symbolic link ${target} => ${dstPath}`);\r\n        fs.symlinkSync(target, dstPath, task.linkType);\r\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\r\n        logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\r\n    }\r\n}\r\n\r\nexport const handleTerminalCommand = async (context:TaskContext, task:TaskTerminalCommand)=>{\r\n    logv(`Start execution... ${task.cmd}`);\r\n    execSync(task.cmd,{\r\n        shell: task.shell,\r\n        // cwd: cwd, \r\n        env: process.env,\r\n        stdio: [process.stdin, process.stdout, process.stderr],\r\n        encoding: 'utf-8'\r\n    })\r\n}\r\n\r\n\r\nexport const handleSetVar = async (context:TaskContext, task:TaskSetVar)=>{\r\n    if(task.key === undefined || !task.key || typeof(task.key) !== 'string' || task.key.length < 1){\r\n        throw new Error(`Invalid key ${task.key}. It must be a string.`);\r\n    }\r\n    \r\n    let value = task.value;\r\n    //old version support\r\n    if((value === undefined || value === null) && task.var){\r\n        value = task.var;\r\n    }\r\n\r\n    if(task.isFallback !== true){\r\n        task.isFallback = false;\r\n    }\r\n\r\n    if(task.varType === 'file'){\r\n        if(typeof(value) !== 'string'){\r\n            throw new Error(`The \"value\" must contain path of a file with \"varType\":\"${task.varType}\"`);\r\n        }\r\n        \r\n        const varsPath = path.resolve(value);\r\n        if(!fs.existsSync(varsPath)){\r\n            throw new Error(`File \"${varsPath}\" does not exist to use as a variable`);\r\n        }\r\n\r\n        value = fs.readFileSync(varsPath ,{encoding:'utf8'});\r\n        if(task.fileFormat === 'json'){\r\n            value = json5.parse(value);\r\n        }\r\n    }\r\n\r\n    setTaskVar(context, task.key, value, task.isFallback);\r\n}\r\n\r\n\r\nconst ENV_LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\r\n\r\n// Parse src into an Object\r\nfunction parseEnv (src:string) {\r\n    const obj:any = {}\r\n\r\n    // Convert buffer to string\r\n    let lines = src.toString()\r\n\r\n    // Convert line breaks to same format\r\n    lines = lines.replace(/\\r\\n?/mg, '\\n')\r\n\r\n    let match:RegExpExecArray | null;\r\n    while ((match = ENV_LINE.exec(lines)) != null) {\r\n        const key = match[1]\r\n        // Default undefined or null to empty string\r\n        let value = (match[2] || '')\r\n        // Remove whitespace\r\n        value = value.trim()\r\n        // Check if double quoted\r\n        const maybeQuote = value[0]\r\n        // Remove surrounding quotes\r\n        value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\r\n        // Expand newlines if double quoted\r\n        if (maybeQuote === '\"') {\r\n            value = value.replace(/\\\\n/g, '\\n')\r\n            value = value.replace(/\\\\r/g, '\\r')\r\n        }\r\n\r\n        // Add to object\r\n        obj[key] = value\r\n    }\r\n\r\n    return obj\r\n}\r\n\r\n\r\nexport const handleEnvVar = async (context:TaskContext, task:TaskEnvVar)=>{\r\n    let value = task.value;\r\n\r\n    //old version support\r\n    if((value === undefined || value === null) && task.var){\r\n        value = task.var;\r\n    }\r\n\r\n    if(task.isFallback !== true){\r\n        task.isFallback = false;\r\n    }\r\n    const isFallback:boolean = task.isFallback;\r\n    \r\n    if(task.varType === 'file'){\r\n        if(typeof(value) !== 'string'){\r\n            throw new Error(`The \"value\" must contain path of a file with \"varType\":\"${task.varType}\"`);\r\n        }\r\n        \r\n        const varsPath = path.resolve(value);\r\n        let obj:Record<string,any> | undefined;\r\n        const content = loadFileOrThrow(varsPath);\r\n        try{\r\n            obj = parseJson(content);\r\n        }catch(e){\r\n        }\r\n\r\n        if(!obj){\r\n            logv(\"Parsing with JSON failed, for now, trying to parse line literals.\")\r\n            obj = parseEnv(content);\r\n        }\r\n        value = obj;\r\n    }\r\n\r\n    if(typeof(value) !== 'object'){\r\n        throw new Error(`The content of the \"value\" must be in the form of key-value pairs. For example: {\"KEY_A\":\"value_a\", \"KEY_B\":\"value_b\"}`);\r\n    }\r\n\r\n    Object.keys(value).forEach(key => {\r\n        setEnvVar(context, key, value[key], isFallback);\r\n    });\r\n}\r\n\r\nexport const handleOutput = async (context:TaskContext, task:TaskOutput)=>{\r\n    const text = task.text ?? '';\r\n    const target:TaskOutputTargets = (task.target ?? 'c').trim() as TaskOutputTargets;\r\n    const targetPath = task.path;\r\n    \r\n    if(target === 'c' || target === 'console'){\r\n        console.log(text);\r\n    }else{\r\n        if(!targetPath){\r\n            throw new Error(`The parameter 'path' is required for a target '${target}'!`);\r\n        }\r\n\r\n        const resolvedPath = path.resolve(targetPath);\r\n        const dir = path.dirname(resolvedPath);\r\n        if(!fs.existsSync(dir)){\r\n            mkdirpSync(dir);\r\n        }\r\n\r\n        if(target == 'fa' || target == 'file-append'){\r\n            let err;\r\n            let fd;\r\n            try{\r\n                fd = fs.openSync(resolvedPath,'a');\r\n                fs.appendFileSync(fd, text, 'utf8');\r\n            }catch(e){\r\n                err = e;\r\n            }finally{\r\n                if(fd !== undefined){\r\n                    fs.closeSync(fd);\r\n                }\r\n            }\r\n\r\n            if(err){\r\n                throw err;\r\n            }\r\n        }else{\r\n            fs.writeFileSync(resolvedPath, text);\r\n        }\r\n    }\r\n}\r\n\r\nconst resolveStringArray = (val:string | string[] | undefined | null, defaultValue:string[]):string[]=>{\r\n    if(val !== undefined && val !== null){\r\n        if(typeof(val) === 'string'){\r\n            return [val];\r\n        }else if(Array.isArray(val)){\r\n            return val.filter((v)=>typeof(v)==='string');\r\n        }\r\n    }\r\n\r\n    return [];\r\n};\r\n\r\n\r\nconst runCopy = (src:string, dst:string, options:CopySyncOptions)=>{\r\n    logv(`Copy: ${src} => ${dst}`);\r\n    copySync(src,dst,options);\r\n};\r\n\r\nexport const handleFsCopy = async (context:TaskContext, task:TaskFsCopy)=>{\r\n    if(!fs.existsSync(task.src)){\r\n        throw new Error(`The source '${task.src}' does not exist`);\r\n    }\r\n    \r\n    const conflict = task?.options?.conflict;\r\n    let overwrite = conflict === undefined || conflict === null || (typeof(conflict) === 'string' && conflict.trim() === 'overwrite');\r\n\r\n    /** @deprecated support migrate from '0.1.18' */ \r\n    if(task.options && 'overwrite' in task?.options && typeof(task?.options?.overwrite) === 'boolean'){\r\n        overwrite = task.options.overwrite;\r\n    }\r\n\r\n    const cpOpt:CopyOptionsSync = { overwrite };\r\n    \r\n    const runGlobSync = (items:string[])=>{\r\n        for(const f of items){\r\n            const from = path.join(task.src, f);\r\n            const to = path.join(task.dest, f);\r\n            runCopy(from, to, cpOpt);\r\n        }\r\n    };\r\n\r\n    const handled = processWithGlobSync(runGlobSync, task.src, \r\n        resolveStringArray(task.include, []),\r\n        resolveStringArray(task.exclude, []),\r\n        false, false);\r\n\r\n    if(!handled){\r\n        runCopy(task.src, task.dest, cpOpt);\r\n    }\r\n}\r\n\r\nconst runDelete = (path:string)=>{\r\n    logv(`Delete: ${path}`);\r\n    removeSync(path);\r\n};\r\n\r\nexport const handleFsDelete = async (context:TaskContext, task:TaskFsDelete)=>{\r\n    if(!fs.existsSync(task.path)){\r\n        logv(`The '${task.path}' does not exist and cannot be deleted`);\r\n        return;\r\n    }\r\n\r\n    const runGlobSync = (items:string[])=>{\r\n        for(const f of items){\r\n            runDelete(path.join(task.path, f));\r\n        }\r\n    };\r\n\r\n    const handled = processWithGlobSync(runGlobSync, task.path, \r\n        resolveStringArray(task.include, []),\r\n        resolveStringArray(task.exclude, []),\r\n        false, false);\r\n\r\n    if(!handled){\r\n        runDelete(task.path);\r\n    }\r\n}\r\n\r\nconst runFindAndReplaceWithRegex = (content:string, find:RegExp, replace:string, repeat:number):string=>{\r\n    var text:string = content;\r\n    if(repeat < 1){\r\n        while(find.test(text)){\r\n            text = text.replace(find, replace);\r\n        }\r\n    }else{\r\n        for(var i=0;i<repeat;i++){\r\n            if(find.test(text)){\r\n                text = text.replace(find, replace);\r\n            }\r\n        }\r\n    }\r\n    return text;\r\n};\r\n\r\nconst runFindAndReplaceWithText = (content:string, find:string, replace:string, repeat:number):string=>{\r\n    var text:string = content;\r\n    if(repeat < 1){\r\n        while(text.indexOf(find) >= 0){\r\n            text = text.replace(find, replace);\r\n        }\r\n    }else{\r\n        for(var i=0;i<repeat;i++){\r\n            if(text.indexOf(find) >= 0){\r\n                text  = text.replace(find, replace);\r\n            }\r\n        }\r\n    }\r\n    return text;\r\n};\r\n\r\nconst isRegexData = (v:any)=>{\r\n    if(v !== undefined && v !== null && typeof(v) === 'object' && 'pattern' in v && typeof(v.pattern) === 'string'){\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\ntype FindAndReplaceFunc = ((content:string, find:any, replace:string, repeat:number)=>string);\r\n\r\nconst findAndReplaceWithFile = (path:string, replaceFunc:FindAndReplaceFunc, find:string | RegExp, replace:string, repeat:number) => {\r\n    logv(`Find and Replace: ${path}`);\r\n    const content:string = fs.readFileSync(path, 'utf-8');\r\n    const newContent = replaceFunc(content, find, replace, repeat);\r\n    fs.writeFileSync(path, newContent, 'utf-8');\r\n};\r\n\r\nexport const handleContentReplace = async (context:TaskContext, task:TaskContentReplace)=>{\r\n    if(!fs.existsSync(task.path)){\r\n        logv(`The '${task.path}' does not exist`);\r\n        return;\r\n    }\r\n\r\n    if(task.replace === undefined || typeof(task.replace) !== 'string'){\r\n        throwInvalidParamError(task, 'replace');\r\n    }\r\n\r\n    let loop:number = task.loop === undefined || task.loop === null? 1 : task.loop;\r\n    if(typeof(loop) === 'string'){\r\n        loop = parseInt(loop, 10);\r\n    }else if(typeof(loop) !== 'number'){\r\n        throwInvalidParamError(task, 'loop');\r\n    }\r\n\r\n    let find:string | RegExp;\r\n    let replaceFunc:FindAndReplaceFunc;\r\n    if(isRegexData(task.find)){\r\n        const regexData = task.find as RegexData;\r\n        find = new RegExp(regexData.pattern, regexData.flags);\r\n        replaceFunc = runFindAndReplaceWithRegex;\r\n    }else if(typeof(task.find) === 'string'){\r\n        find = task.find;\r\n        replaceFunc = runFindAndReplaceWithText;\r\n    }else{\r\n        throwInvalidParamError(task, 'find');\r\n        return;\r\n    }\r\n\r\n    const runGlobSync = (items:string[])=>{\r\n        for(const f of items){\r\n            const itemPath:string = path.join(task.path, f);\r\n            if(fs.statSync(itemPath).isDirectory()){\r\n                continue;\r\n            }\r\n            findAndReplaceWithFile(path.join(task.path, f), replaceFunc, find, task.replace, loop);\r\n        }\r\n    };\r\n\r\n    const handled = processWithGlobSync(runGlobSync, task.path, \r\n        resolveStringArray(task.include, []),\r\n        resolveStringArray(task.exclude, []),\r\n        true, true);\r\n\r\n    if(!handled){\r\n        findAndReplaceWithFile(task.path, replaceFunc, find, task.replace, loop);\r\n    }\r\n}\r\n\r\n","import fs from 'fs';\r\nimport { globSync } from 'glob';\r\n\r\n/**\r\n * \r\n * @param handler \r\n * @param cwd \r\n * @param includes \r\n * @param excludes \r\n * @param includeAllForNonFilter \r\n * @param subOptions \r\n * @returns true - filters are applied, false - there was no filter to apply\r\n */\r\nexport const processWithGlobSync = (\r\n    handler:(items:string[])=>void, cwd:string, \r\n    includes:string[], excludes:string[],\r\n    skipDirs:boolean,\r\n    includeAllForNonFilters:boolean\r\n    ):boolean =>{\r\n\r\n    if(fs.statSync(cwd).isDirectory() === false){\r\n        return false;\r\n    }\r\n\r\n\r\n    //pre apply filter for faster performance\r\n    const nodir:boolean = skipDirs === true;\r\n\r\n    const ilen:boolean = includes.length > 0;\r\n    const elen:boolean = excludes.length > 0;\r\n    if(!ilen && elen){\r\n        //include all to apply excludes\r\n        handler(globSync('**', {ignore:['.', ...excludes], cwd, nodir}));\r\n        return true;\r\n    }else if(ilen && !elen){\r\n        //apply includes only\r\n        handler(globSync(includes, { cwd, nodir}));\r\n        return true;\r\n    }else if(ilen && elen){\r\n        //apply include and exclude\r\n        handler(globSync(includes, {ignore:excludes, cwd, nodir}));\r\n        return true;\r\n    }else if(includeAllForNonFilters){\r\n        //include all to apply skipDirs, skipFiles\r\n        handler(globSync('**', {ignore:['.'], cwd, nodir}));\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};","import { handleSubTasks } from \"./handler_sub_tasks\";\r\nimport { handleContentReplace, handleEnvVar, handleFsCopy, handleFsDelete, handleGitRepoSetup, handleOutput, handleSetVar, handleSymlink, handleTerminalCommand } from \"./handlers\";\r\nimport { TaskContext, TaskType } from \"./task_data\";\r\n\r\nexport const handlerMap:{\r\n    [k in TaskType]:(context:TaskContext, task:any)=>Promise<void>\r\n} = {\r\n    \"git-repo-prepare\": handleGitRepoSetup,\r\n    symlink: handleSymlink,\r\n    cmd: handleTerminalCommand,\r\n    \"set-var\": handleSetVar,\r\n    output: handleOutput,\r\n    \"fs-copy\":handleFsCopy,\r\n    \"fs-del\":handleFsDelete,\r\n    \"env-var\":handleEnvVar,\r\n    \"sub-tasks\": handleSubTasks,\r\n    \"content-replace\":handleContentReplace\r\n};"],"mappings":"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","names":["src_exports","__export","usefulTasks","__toCommonJS","import_path","import_commander","import_path","DEFAULT_CONFIG","DEFAULT_USE_CAMEL","CwdRestore","CwdKeep","cwdModes","LogLevelInfo","LogLevelDebug","LogLevelNone","logLevels","argDesc","v","setup","userArgv","program","typedOptions","fixStringArrayArgument","path","value","skipEmptyItem","result","trimedValue","import_path","import_fs","import_path","import_json5","loadFileOrThrow","filePath","fs","loadJson","parseJson","content","json5","loadJsonConfig","configJson","filePathDir","path","extendsFilePath","convertOrNotHyphenTextToCamelText","text","flag","result","textArr","i","word","containsTag","elements","tags","el","tag","containsAllTag","contained","import_debug","LOG_TAG","TAG_DEBUG","TAG_INFO","DEFAULT_REPLACE_REGEX","VAR_FROM_ARGUMENT_PREFIX","ENV_VAR_FROM_ARGUMENT_PREFIX","import_debug","logv","debug","TAG_DEBUG","logi","TAG_INFO","applyVariables","context","task","anyTypeTask","key","valueOfKey","match","matchedStr","varPath","currentVar","varPaths","i","varEl","valuePrefix","valueReplace","valueSuffix","logv","searchExtraKeyValue","extraArgs","fmt","convertToCamelKeys","callback","currentVarName","useNextElementAsVar","extraArg","value","equalMarkIndex","varName","convertOrNotHyphenTextToCamelText","setTaskVar","skipForExists","setEnvVar","valueType","import_string_argv","handleSubTasks","context","task","subArgv","stringArgv","setupResult","setup","usefulTasks","import_fs","import_child_process","import_path","import_simple_git","import_fs_extra","import_json5","import_fs","import_glob","processWithGlobSync","handler","cwd","includes","excludes","skipDirs","includeAllForNonFilters","fs","nodir","ilen","elen","throwInvalidParamError","obj","key","handleGitRepoSetup","context","task","localPath","path","fs","git","hasLocalBranch","branchLocal","b","branch","startPoint","handleSymlink","target","dstPath","lstat","logv","handleTerminalCommand","handleSetVar","value","varsPath","json5","setTaskVar","ENV_LINE","parseEnv","src","lines","match","maybeQuote","handleEnvVar","isFallback","content","loadFileOrThrow","parseJson","setEnvVar","handleOutput","text","targetPath","resolvedPath","dir","err","fd","e","resolveStringArray","val","defaultValue","v","runCopy","dst","options","handleFsCopy","conflict","overwrite","cpOpt","processWithGlobSync","items","f","from","to","runDelete","handleFsDelete","runFindAndReplaceWithRegex","find","replace","repeat","i","runFindAndReplaceWithText","isRegexData","findAndReplaceWithFile","replaceFunc","newContent","handleContentReplace","loop","regexData","itemPath","handlerMap","handleGitRepoSetup","handleSymlink","handleTerminalCommand","handleSetVar","handleOutput","handleFsCopy","handleFsDelete","handleEnvVar","handleSubTasks","handleContentReplace","usefulTasks","originCwd","opt","program","tasksConfig","configFilePath","path","loadJsonConfig","e","debugPat","logLevel","replaceRegex","DEFAULT_REPLACE_REGEX","env","logLevels","TAG_INFO","TAG_DEBUG","debug","logv","baseCwd","context","searchExtraKeyValue","VAR_FROM_ARGUMENT_PREFIX","key","value","setTaskVar","ENV_VAR_FROM_ARGUMENT_PREFIX","setEnvVar","logi","getTaskRepresentStr","task","i","tasks","j","otherTask","handlerMap","printInvalidTags","tags","tag","excludeItems","taskItem","index","array","containsTag","excludesItems","containsAllTag","hasIncludeFilters","hasIncludeCTAFilters","includeItems","includeCtaItems","v","taskCount","applyVariables","taskRepresentStr","cwdHasChanges","taskCwd","taskHandler","reason","originCwd","path","setupResult","setup","usefulTasks"]}