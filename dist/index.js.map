{"version":3,"sources":["../src/index.ts","../src/build_cli_parser.ts","../src/useful_tasks.ts","../src/utils.ts","../src/task_data.ts","../src/handlers.ts"],"sourcesContent":["import path from 'path';\nimport { Options, setup } from './build_cli_parser';\nimport { Command } from 'commander';\nimport { usefulTasks } from './useful_tasks';\nexport { usefulTasks } from './useful_tasks';\n\nconst originCwd = path.resolve(process.cwd());\n\nconst setupResult = setup();\n\nconst opt:Options = setupResult.typedOptions;\nconst program:Command = setupResult.program;\n\nusefulTasks(originCwd, opt, program);","import { program } from 'commander';\nimport path from 'path';\n\nexport const DEFAULT_CONFIG = \"useful_tasks.json\";\nexport const DEFAULT_USE_CAMEL = true;\n\nexport interface Options {\n    cwd?:string;\n    config:string;\n    include?:string[];\n    includeCta?:string[];\n    exclude?:string[];\n    excludeCta?:string[];\n    camelKeys:boolean;\n    extraArgs?:string[];\n}\n\nexport const setup = ()=> {\n    // console.log('cwd', process.cwd());\n    // console.log('argv', process.argv);\n\n    program.name('useful-tasks').version(process.env.npm_package_version!)\n    .option('--cwd <string>','Change working directory')\n    .option('-c, --config <string>','A path of json configuraion', DEFAULT_CONFIG)\n    .option('-i, --include <items>','Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-a, --include-cta <items>','Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-e, --exclude <items>','Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-x, --exclude-cta <items>','Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('--camel-keys <boolean>','Specify whether to use camel case for the key of the variable. If the value is true, the paramter \"--var-my-key\" will be converted to \"myKey\" otherwise it will be \"my-key\"', DEFAULT_USE_CAMEL)\n    .allowUnknownOption(true);\n    \n    program.parse();\n\n    const opts = program.opts();\n\n    const typedOptions = opts as Options;\n    typedOptions.include = fixStringArrayArgument(typedOptions.include);\n    typedOptions.includeCta = fixStringArrayArgument(typedOptions.includeCta);\n    typedOptions.exclude = fixStringArrayArgument(typedOptions.exclude);\n    typedOptions.excludeCta = fixStringArrayArgument(typedOptions.excludeCta);\n    \n    if(typedOptions.camelKeys !== undefined && typeof(typedOptions.camelKeys) === 'string'){\n        let v:string = typedOptions.camelKeys;\n        v = v.trim().toLowerCase();\n        if(v === 'false' || v === '0' || v === 'no'){\n            typedOptions.camelKeys = false;\n        }else if(v==='true' || v==='1' || v === 'yes'){\n            typedOptions.camelKeys = true;\n        }else{\n            typedOptions.camelKeys = DEFAULT_USE_CAMEL;\n        }\n    }\n    typedOptions.extraArgs = [...program.args ?? []];\n\n    // console.log(`Using options : ${JSON.stringify(typedOptions, undefined, 2)}`);\n    // console.log(`Extra arguments`, program.args);\n\n    if(typedOptions.cwd){\n        process.chdir(path.resolve(typedOptions.cwd));\n    }\n    console.log(\"######################################################################\")\n\n    return {typedOptions, program};\n}\n\nconst fixStringArrayArgument = (value:string|string[]|undefined, skipEmptyItem:boolean = true)=>{\n    if(!value){\n        return [];\n    }\n    \n    if(typeof value === 'string'){\n        const result:string[] = [];\n        const arr = value.split(',');\n        arr.forEach((value)=>{\n            const trimedValue = value.trim();\n            if(skipEmptyItem){\n                if(trimedValue.length > 0){\n                    result.push(trimedValue);\n                }\n            }else{\n                result.push(trimedValue);\n            }\n        });\n        return result;\n    }\n    \n    return [];\n};\n","import path from 'path';\nimport { Options, setup } from './build_cli_parser';\nimport { containsAllTag, containsTag, convertOrNotHyphenTextToCamelText, loadJsonConfig } from './utils';\nimport debug from 'debug';\nimport { Config, TAG, Task, TaskContext, TaskOutput, TaskSetVar, TaskGitCheckout, TaskSymlink, TaskTerminalCommand, DEFAULT_REPLACE_REGEX, VAR_FROM_ARGUMENT_PREFIX, TaskFsCopy, TaskFsDelete, TaskEnvVar, ENV_VAR_FROM_ARGUMENT_PREFIX } from './task_data';\nimport { handleTerminalCommand, handleGitRepoSetup, handleSymlink, handleSetVar, handleOutput, applyVariables, handleFsCopy, handleFsDelete, handleEnvVar, searchExtraKeyValue, setTaskVar, setEnvVar } from './handlers';\nimport { Command } from 'commander';\n\nexport const usefulTasks = (originCwd:string, opt:Options, program:Command)=>{\n    let tasksConfig:Config = {};\n\n    let configFilePath = path.resolve(opt.config);\n    try{\n        tasksConfig = loadJsonConfig(configFilePath);\n    }catch(e:any){\n        if(e instanceof Error){\n            console.log(e.message);\n        }else{\n            console.log(e);\n        }\n        console.log(\"\");\n        program.help();\n    }\n    \n    let debugPat:string = '';\n    \n    let replaceRegex = DEFAULT_REPLACE_REGEX;\n    if(tasksConfig.env && typeof(tasksConfig.env) === 'object'){\n        const env = tasksConfig.env;\n        if(env.verbose){\n            debugPat = `${TAG}, ${TAG}:*`;\n        }\n        \n        if(env.verboseGit){\n            debugPat = `${debugPat},simple-git,simple-git:*`;\n        }\n    \n        if(env.replaceRegex){\n            replaceRegex = env.replaceRegex;\n        }\n    }\n    \n    if(typeof(replaceRegex) !== 'string'){\n        throw new Error(`replaceRegex '${replaceRegex}'  must be a string`);\n    }\n    if(replaceRegex.length < 1){\n        throw new Error(`replaceRegex '${replaceRegex}' cannot be empty`);\n    }\n    if(replaceRegex.indexOf('(') < 0 || replaceRegex.indexOf(')') < 0){\n        throw new Error(`replaceRegex '${replaceRegex}' must contain regex group express '(' and ')'`);\n    }\n    \n    if(debugPat){\n        debug.enable(debugPat);\n    }\n    \n    const vlog = debug(TAG);\n    const baseCwd = path.resolve(process.cwd());\n    \n    const context:TaskContext = {\n        replaceRegex:new RegExp(replaceRegex),\n        vars:{\n            __env:{\n                cwd_startup:originCwd,\n                cwd_base:baseCwd\n            }\n        }\n    };\n    \n    if(opt.extraArgs){\n        vlog(\"Setting up the variables from the additional arguments\");\n        searchExtraKeyValue(opt.extraArgs, VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\n            setTaskVar(context, key, value);\n        });\n    \n        vlog(\"Setting up the environment variables from the additional arguments\");\n        searchExtraKeyValue(opt.extraArgs, ENV_VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\n            setEnvVar(context, key, value);\n        });\n    }\n    \n    console.log(\"######################################################################\")\n    console.log(`[${tasksConfig.name}] Start task processing`);\n    \n    const getTaskRepresentStr = (task:Task, i?:number)=>{ \n        if(i !== undefined && i !== null){\n            return task.id !== undefined ? `[${i}]${task.id}/${task.type}` : `[${i}]${task.type}`;\n        }else{\n            return task.id !== undefined ? `${task.id}/${task.type}` : `${task.type}`;\n        }\n    };\n    \n    const runTasks = async ()=>{\n        let tasks:Array<Task> = tasksConfig.tasks ?? [];\n    \n        // Validate task IDs\n        for(let i=0;i<tasks.length;i++){\n            const task = tasks[i];\n            if(task.id !== undefined && task.id !== null){\n                if(typeof(task.id) !== 'string'){\n                    throw new Error(`The task id must be a 'string' type`);\n                }\n    \n                if(task.id.length<1){\n                    throw new Error(`The task id cannot be empty`);\n                }\n    \n                for(let j=i+1;j<tasks.length;j++){\n                    const otherTask = tasks[j];\n                    if(otherTask.id !== undefined && otherTask.id === task.id){\n                        throw new Error(`The task id '${task.id}' must be unique`);\n                    }\n                }\n            }\n    \n            \n            task.__compare__elements = [];\n            if(task.id){\n                task.id = task.id.trim()\n                task.__compare__elements.push(task.id.trim());\n            }\n            if(task.tags){\n                const printInvalidTags = (tags:any)=>{\n                    vlog(`Ignoring invalid tags '${tags}'`);\n                };\n                if(typeof(task.tags) === 'string'){\n                    if(task.tags.length > 0){\n                        task.tags = task.tags.trim();\n                        task.__compare__elements.push(task.tags);\n                    }else{\n                        printInvalidTags(task.tags);\n                    }\n                }else if(Array.isArray(task.tags)){\n                    task.tags = task.tags.map((value:string)=>value.trim());\n                    for(const tag of task.tags){\n                        if(typeof(tag) === 'string' && tag.length>0){\n                            task.__compare__elements.push(tag);\n                        }else{\n                            printInvalidTags(tag);\n                        }\n                    }\n                }else{\n                    printInvalidTags(task.tags);\n                }\n            }\n        }\n    \n        if(opt.exclude && opt.exclude.length > 0){\n            const excludeItems = opt.exclude;\n    \n            vlog(`Excluding tasks by specified IDs or Tags : --exclude=${excludeItems}`);\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(containsTag(excludeItems, taskItem.__compare__elements) === false){\n                    return taskItem;\n                }\n            });\n        }\n        if(opt.excludeCta && opt.excludeCta.length > 0){\n            const excludesItems = opt.excludeCta;\n    \n            vlog(`Excluding tasks by specified IDs or Tags : --exclude-cta=${excludesItems}`);\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(containsAllTag(excludesItems, taskItem.__compare__elements) === false){\n                    return taskItem;\n                }\n            });\n        }\n        const hasIncludeFilters = opt.include && opt.include.length > 0;\n        const hasIncludeCTAFilters = opt.includeCta && opt.includeCta.length > 0;\n        if(hasIncludeFilters || hasIncludeCTAFilters){\n            const includeItems = opt.include;\n            const includeCtaItems = opt.includeCta;\n    \n            vlog(`Including tasks by specified IDs or Tags : --include=${includeItems} / --include-cta=${includeCtaItems}`);\n            tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(\n                    (hasIncludeFilters && containsTag(includeItems!, taskItem.__compare__elements) === true)\n                    ||\n                    (hasIncludeCTAFilters && containsAllTag(includeCtaItems!, taskItem.__compare__elements) === true)\n                ){\n                    return taskItem;\n                }\n            });\n        }\n    \n        vlog(`Tasks : ${tasks.map((v,i)=>{ return getTaskRepresentStr(v,i);})}`);\n    \n        const taskCount = tasks.length ?? 0;\n        for(let i=0;i<taskCount; i++){\n            const task = tasks[i];\n            applyVariables(context, task);\n    \n            const taskRepresentStr = getTaskRepresentStr(task,i);\n            if(task.enabled === false){\n                vlog(`Skip the task without execution => ${taskRepresentStr}`);\n                continue;\n            }else{\n                vlog(`Task : ${taskRepresentStr}`)\n            }\n    \n            if(task.comment){\n                vlog(task.comment);\n            }\n    \n            if(task.cwd){\n                const taskCwd = path.resolve(task.cwd);\n                vlog(`Changing the current working directory => ${taskCwd}`);\n                process.chdir(taskCwd);\n            }\n            \n            if(task.type === 'git-repo-prepare'){\n                await handleGitRepoSetup(context, task as TaskGitCheckout);\n            }else if(task.type === 'symlink'){\n                await handleSymlink(context, task as TaskSymlink);\n            }else if(task.type === 'cmd'){\n                await handleTerminalCommand(context, task as TaskTerminalCommand);\n            }else if(task.type === 'set-var'){\n                await handleSetVar(context, task as TaskSetVar);\n            }else if(task.type === 'env-var'){\n                await handleEnvVar(context, task as TaskEnvVar);\n            }else if(task.type === 'output'){\n                await handleOutput(context, task as TaskOutput);\n            }else if(task.type === 'fs-copy'){\n                await handleFsCopy(context, task as TaskFsCopy);\n            }else if(task.type === 'fs-del'){\n                await handleFsDelete(context, task as TaskFsDelete);\n            }\n    \n            process.chdir(baseCwd);\n        }\n    };\n    \n    runTasks().then(()=>{}).catch((reason:any)=>{\n        throw reason;\n    }).finally(()=>{\n        process.chdir(baseCwd);\n        console.log(`[${tasksConfig.name}] Tasks completed`);\n        console.log(\"######################################################################\")\n    });\n    \n};\n","import fs from 'fs';\nimport path from 'path';\nimport json5 from 'json5';\n\nexport const loadJson = (filePath:string)=>{\n    if(!fs.existsSync(filePath)){\n        throw new Error(`ERROR: The Path '${filePath}' does not exists!`);\n    }\n\n    const fileString = fs.readFileSync(filePath, {encoding:'utf-8'});\n    return json5.parse(fileString);\n};\n\n\nexport const loadJsonConfig = (filePath:string)=>{\n    let configJson = loadJson(filePath);\n    if(configJson.extends){\n        const filePathDir = path.dirname(filePath);\n        const extendsFilePath = path.resolve(filePathDir, configJson.extends);\n        configJson = Object.assign({}, configJson, loadJsonConfig(extendsFilePath));\n    }\n    \n    return configJson;\n};\n\nexport const convertOrNotHyphenTextToCamelText=(text:string, flag:boolean)=>{\n    if(!flag){\n        return text;\n    }\n\n    let result = '';\n    let textArr = text.split(\"-\");\n    for(let i=0;i<textArr.length;i++){\n        let word = textArr[i];\n        if(i===0){\n            result = word;\n        }else{\n            if(word.length>0){\n                word = `${word[0].toUpperCase()}${word.substring(1)}`;\n            }\n            result = `${result}${word}`;\n        }\n    }\n    return result;\n}\n\n\n\nexport const containsTag = (elements:string[], tags:string[])=>{\n    if(elements.length < 1){\n        return false;\n    }\n    \n    for(const el of elements){\n        for(const tag of tags){\n            if(el === tag){\n                return true;    \n            }\n        }        \n    }\n\n    return false;\n};\n\nexport const containsAllTag = (elements:string[], tags:string[])=>{\n    if(elements.length < 1){\n        return false;\n    }\n    for(const el of elements){\n        let contained = false;\n        for(const tag of tags){\n            if(tag === el){\n                contained = true;\n                break;\n            }\n        }        \n        if(!contained){\n            return false;\n        }        \n    }\n    return true;\n};","export interface TaskContext {\n    replaceRegex:RegExp;\n    vars:any;\n}\n\nexport interface Task {\n    type:'git-repo-prepare'|'symlink'|'cmd'|'set-var'|'output'|'fs-copy'|'fs-del'|'fs-exist'|'env-var';\n    id?:string;\n    tags?:string | string[],\n    cwd?:string;\n    enabled?:boolean;\n    comment?:string;\n    __compare__elements:string[];\n}\n\nexport interface TaskGitCheckout extends Task{\n    /** Executable git binary */\n    binary?:string;\n    url?:string;\n    localPath:string;\n    branch?:string;\n    startPoint?:string;\n    updateSubmodules?:Array<string> | string | boolean;\n}\n\nexport interface TaskSymlink extends Task{\n    target:string;\n    path:string;\n    linkType?:'dir' | 'file' | 'junction';\n    forced?:boolean;\n}\n\nexport interface TaskTerminalCommand extends Task{\n    cmd:string;\n    shell?:string;\n}\n\n\nexport interface TaskSetVar extends Task{\n    key:string;\n    var:string|number|any|boolean;\n    varType:'value'|'file';\n    fileFormat:'json'|'string';\n}\n\nexport interface TaskEnvVar extends Task{\n    var:any;\n    varType:'dict'|'file';\n}\n\nexport type TaskOutputTargets = 'console'|'file-write'|'file-append'|'c'|'fw'|'fa';\nexport interface TaskOutput extends Task{\n    text:string;\n    target:TaskOutputTargets;\n    path?:string;\n}\n\nexport interface TaskFsCopy extends Task{\n    src:string;\n    dest:string;\n}\n\nexport interface TaskFsDelete extends Task{\n    path:string;\n}\n\nexport interface Config {\n    name?:string;\n    \n    env?:{\n        verbose?:boolean;\n        verboseGit?:boolean;\n        replaceRegex?:string;\n    };\n    tasks?:Array<Task>;\n}\n\nexport const TAG = \"useful-tasks\"\n\n/** e.g. ${value.key} */\nexport const DEFAULT_REPLACE_REGEX = \"\\\\$\\\\{([a-zA-Z0-9\\\\.\\\\-_]*)\\\\}\";\n\nexport const VAR_FROM_ARGUMENT_PREFIX = \"--var-\";\nexport const ENV_VAR_FROM_ARGUMENT_PREFIX = \"--env-\";","import fs from 'fs';\nimport { execSync } from 'child_process';\nimport path from 'path';\nimport {CheckRepoActions, ResetMode, simpleGit} from 'simple-git';\nimport fsExtra, { copySync, mkdirpSync } from 'fs-extra'\nimport { removeSync } from 'fs-extra';\nimport debug from 'debug';\nimport { TAG, Task, TaskContext, TaskOutput, TaskSetVar, TaskGitCheckout, TaskSymlink, TaskTerminalCommand, TaskOutputTargets, TaskFsCopy, TaskFsDelete, TaskEnvVar } from './task_data';\nimport { convertOrNotHyphenTextToCamelText, loadJson } from './utils';\nimport json5 from 'json5';\n\nconst vlog = debug(TAG);\n\nexport const handleGitRepoSetup = async (context:TaskContext, task:TaskGitCheckout)=>{\n    const localPath = path.resolve(task.localPath);\n\n    if(!fs.existsSync(localPath)){\n        fs.mkdirSync(localPath, {recursive:true});\n    }\n\n    if(fs.readdirSync(localPath).length === 0){\n        if(task.url){\n            await simpleGit().clone(task.url, localPath);\n        }\n    }\n\n    const git = simpleGit(localPath, {binary:task.binary});\n\n    const isGitRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);\n    if(!isGitRepo){\n        throw Error(`${localPath} is not a git repository!!!`);\n    }\n\n    \n    if(task.updateSubmodules){\n        await git.submoduleInit();\n        await git.submoduleUpdate();\n    }else{\n        // const submodules = task.updateSubmodules ?? [];\n        // for(var submod of submodules){\n        // }\n    }\n\n    await git.fetch();\n\n    if(task.branch){\n        let hasLocalBranch = false;\n        const branchLocal = await git.branchLocal();\n        for(var b of branchLocal.all){\n            if(b === task.branch){\n                hasLocalBranch = true;\n                break;\n            }\n        }\n\n        const branch = task.branch ?? \"\";\n        const startPoint:string = task.startPoint ?? \"\";\n\n        if(!hasLocalBranch){\n            await git.checkoutBranch(branch, startPoint)\n        }else{\n            if(branchLocal.current !== task.branch){\n                await git.checkout(branch);\n            }\n            await git.reset(ResetMode.HARD, [startPoint])\n        }\n    }\n}\n\nexport const handleSymlink = async (context:TaskContext, task:TaskSymlink)=>{\n    const target:string = path.resolve(task.target);\n    const dstPath:string = path.resolve(task.path);\n\n    if(fs.existsSync(dstPath)){\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\n        vlog(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n        if(task.forced){\n            if(lstat.isSymbolicLink() || lstat.isFile()){\n                vlog(`Unlink ${dstPath}`);\n                fs.unlinkSync(dstPath);\n            }else if(lstat.isDirectory()){\n                vlog(`Remove directory '${dstPath}'`);\n                removeSync(dstPath);\n            }\n        }\n    }\n\n    if(fs.existsSync(dstPath)){\n        vlog(`Could not create symbolic link cause '${dstPath}' already exists`);\n        // throw Error()\n    }else{\n        vlog(`Create symbolic link ${target} => ${dstPath}`);\n        fs.symlinkSync(target, dstPath, task.linkType);\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\n        vlog(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n    }\n}\n\nexport const handleTerminalCommand = async (context:TaskContext, task:TaskTerminalCommand)=>{\n    vlog(`Start execution... ${task.cmd}`);\n    execSync(task.cmd,{\n        shell: task.shell,\n        // cwd: cwd, \n        env: process.env,\n        stdio: [process.stdin, process.stdout, process.stderr],\n        encoding: 'utf-8'\n    })\n}\n\nexport const setTaskVar = (context:TaskContext, key:string, value:any)=>{\n    vlog(`Sets the variable ${key}=${value}`);\n    context.vars[key] = value;\n}\n\nexport const handleSetVar = async (context:TaskContext, task:TaskSetVar)=>{\n    if(task.key === undefined || !task.key || typeof(task.key) !== 'string' || task.key.length < 1){\n        throw new Error(`Invalid key ${task.key}. It must be a string.`);\n    }\n    \n    let taskVar = task.var;\n    if(task.varType === 'file'){\n        if(typeof(taskVar) !== 'string'){\n            throw new Error(`The \"var\" must contain path of a file with \"varType\":\"${task.varType}\"`);\n        }\n        \n        const varsPath = path.resolve(taskVar);\n        if(!fs.existsSync(varsPath)){\n            throw new Error(`File \"${varsPath}\" does not exist to use as a variable`);\n        }\n\n        taskVar = fs.readFileSync(varsPath ,{encoding:'utf8'});\n        if(task.fileFormat === 'json'){\n            taskVar = json5.parse(taskVar);\n        }\n    }\n\n    setTaskVar(context, task.key, taskVar);\n}\n\nexport const setEnvVar = (context:TaskContext, key:string, value:any)=>{\n    var valueType = typeof(value);\n    if(valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean'){\n        vlog(`Ignoring the invalid typed(${valueType}) environment variable ${key}=${value}`);\n    }else{\n        const stringVal = String(value);\n        if(stringVal.length < 1){\n            vlog(`Ignoring the invalid environment variable ${key}=${value}`);\n        }else{\n            vlog(`Sets the environment variable ${key}=${value}`);\n            process.env[key] = String(value);\n        }\n    }\n}\n\nexport const handleEnvVar = async (context:TaskContext, task:TaskEnvVar)=>{\n    let taskVar = task.var;\n    if(task.varType === 'file'){\n        if(typeof(taskVar) !== 'string'){\n            throw new Error(`The \"var\" must contain path of a file with \"varType\":\"${task.varType}\"`);\n        }\n        \n        const varsPath = path.resolve(taskVar);\n        taskVar = loadJson(varsPath);\n    }\n\n    if(typeof(taskVar) !== 'object'){\n        throw new Error(`The content of the \"var\" must be in the form of key-value pairs. For example: {\"KEY_A\":\"value_a\", \"KEY_B\":\"value_b\"}`);\n    }\n\n    Object.keys(taskVar).forEach(key => {\n        setEnvVar(context, key, taskVar[key]);\n    });\n}\n\nexport const handleOutput = async (context:TaskContext, task:TaskOutput)=>{\n    const text = task.text ?? '';\n    const target:TaskOutputTargets = (task.target ?? 'c').trim() as TaskOutputTargets;\n    const targetPath = task.path;\n    \n    if(target === 'c' || target === 'console'){\n        console.log(text);\n    }else{\n        if(!targetPath){\n            throw new Error(`The parameter 'path' is required for a target '${target}'!`);\n        }\n\n        const resolvedPath = path.resolve(targetPath);\n        const dir = path.dirname(resolvedPath);\n        if(!fs.existsSync(dir)){\n            mkdirpSync(dir);\n        }\n\n        if(target == 'fa' || target == 'file-append'){\n            let err;\n            let fd;\n            try{\n                fd = fs.openSync(resolvedPath,'a');\n                fs.appendFileSync(fd, text, 'utf8');\n            }catch(e){\n                err = e;\n            }finally{\n                if(fd !== undefined){\n                    fs.closeSync(fd);\n                }\n            }\n\n            if(err){\n                throw err;\n            }\n        }else{\n            fs.writeFileSync(resolvedPath, text);\n        }\n    }\n}\n\nexport const handleFsCopy = async (context:TaskContext, task:TaskFsCopy)=>{\n    copySync(task.src, task.dest);\n}\nexport const handleFsDelete = async (context:TaskContext, task:TaskFsDelete)=>{\n    removeSync(task.path);\n}\n\nexport const applyVariables = async (context:TaskContext, task:Task)=>{\n    const anyTypeTask:any = task as any;\n        Object.keys(anyTypeTask).forEach(key => {\n            if(anyTypeTask[key] !== undefined && typeof(anyTypeTask[key]) ==='string'){\n                let valueOfKey:string = anyTypeTask[key];\n                while(true){\n                    const match = context.replaceRegex.exec(valueOfKey);\n                    if(match === null || match === undefined){\n                        break;\n                    }\n                    \n                    const matchedStr = match[0];\n                    const varPath = match[1];\n\n                    let currentVar = context.vars;\n                    if(varPath.length > 0){\n                        const varPaths = varPath.split(\".\");\n                        for(let i=0; i<varPaths.length;i++){\n                            const varEl = varPaths[i];\n                            if(currentVar.hasOwnProperty(varEl)){\n                                currentVar = currentVar[varEl];\n                            }else{\n                                throw new Error(`The value of ${varPath} could not be found!`);\n                            }\n                        }\n                    }\n\n                    const valuePrefix = valueOfKey.substring(0, match.index);\n                    const valueReplace = `${currentVar}`;\n                    const valueSuffix = valueOfKey.substring(match.index+matchedStr.length);                    \n                    valueOfKey = `${valuePrefix}${valueReplace}${valueSuffix}`;\n                    vlog(`Updated value ${valueOfKey}`);\n                }\n                \n                anyTypeTask[key] = valueOfKey;\n            }\n        });\n};\n\n\nexport const searchExtraKeyValue = (extraArgs:string[], fmt:string, convertToCamelKeys:boolean, callback:(key:string, value:string)=>void)=>{\n    let currentVarName:string|undefined;\n    let useNextElementAsVar:boolean = false;\n    \n    for(let extraArg of extraArgs){\n        const arg = extraArg.trim();\n        if(arg === '--'){\n            vlog(\"Stop parsing by '--'\")\n            break;\n        }\n\n        if(useNextElementAsVar && currentVarName){\n            const value = extraArg.startsWith(\"-\") ? \"\":extraArg;\n            callback(currentVarName, value);\n            currentVarName = undefined;\n            useNextElementAsVar = false;\n        }else{\n            const prefixIndex = extraArg.indexOf(fmt);\n            if(prefixIndex >= 0){\n                const equalMarkIndex = extraArg.indexOf(\"=\");\n                if(equalMarkIndex >= 0){\n                    const varName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length, equalMarkIndex), convertToCamelKeys);\n                    const value = extraArg.substring(equalMarkIndex+1);\n                    callback(varName, value);\n                }else{\n                    currentVarName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length), convertToCamelKeys);\n                    useNextElementAsVar = true;\n                }\n            }    \n        }\n    }\n};"],"mappings":"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","names":["src_exports","__export","usefulTasks","__toCommonJS","import_path","import_commander","import_path","DEFAULT_CONFIG","DEFAULT_USE_CAMEL","setup","typedOptions","fixStringArrayArgument","v","path","value","skipEmptyItem","result","trimedValue","import_path","import_fs","import_path","import_json5","loadJson","filePath","fs","fileString","json5","loadJsonConfig","configJson","filePathDir","path","extendsFilePath","convertOrNotHyphenTextToCamelText","text","flag","result","textArr","i","word","containsTag","elements","tags","el","tag","containsAllTag","contained","import_debug","TAG","DEFAULT_REPLACE_REGEX","VAR_FROM_ARGUMENT_PREFIX","ENV_VAR_FROM_ARGUMENT_PREFIX","import_fs","import_child_process","import_path","import_simple_git","import_fs_extra","import_debug","import_json5","vlog","debug","TAG","handleGitRepoSetup","context","task","localPath","path","fs","git","hasLocalBranch","branchLocal","b","branch","startPoint","handleSymlink","target","dstPath","lstat","handleTerminalCommand","setTaskVar","key","value","handleSetVar","taskVar","varsPath","json5","setEnvVar","valueType","handleEnvVar","loadJson","handleOutput","text","targetPath","resolvedPath","dir","err","fd","e","handleFsCopy","handleFsDelete","applyVariables","anyTypeTask","valueOfKey","match","matchedStr","varPath","currentVar","varPaths","i","varEl","valuePrefix","valueReplace","valueSuffix","searchExtraKeyValue","extraArgs","fmt","convertToCamelKeys","callback","currentVarName","useNextElementAsVar","extraArg","equalMarkIndex","varName","convertOrNotHyphenTextToCamelText","usefulTasks","originCwd","opt","program","tasksConfig","configFilePath","path","loadJsonConfig","e","debugPat","replaceRegex","DEFAULT_REPLACE_REGEX","env","TAG","debug","vlog","baseCwd","context","searchExtraKeyValue","VAR_FROM_ARGUMENT_PREFIX","key","value","setTaskVar","ENV_VAR_FROM_ARGUMENT_PREFIX","setEnvVar","getTaskRepresentStr","task","i","tasks","j","otherTask","printInvalidTags","tags","tag","excludeItems","taskItem","index","array","containsTag","excludesItems","containsAllTag","hasIncludeFilters","hasIncludeCTAFilters","includeItems","includeCtaItems","v","taskCount","applyVariables","taskRepresentStr","taskCwd","handleGitRepoSetup","handleSymlink","handleTerminalCommand","handleSetVar","handleEnvVar","handleOutput","handleFsCopy","handleFsDelete","reason","originCwd","path","setupResult","setup","opt","program","usefulTasks"]}