{"version":3,"sources":["../src/index.ts","../src/build_cli_parser.ts","../src/useful_tasks.ts","../src/utils.ts","../src/task_data.ts","../src/loggers.ts","../src/task_utils.ts","../src/handler_sub_tasks.ts","../src/handlers.ts","../src/glob_handler.ts","../src/handler_map.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport path from 'path';\nimport { setup } from './build_cli_parser';\nimport { usefulTasks } from './useful_tasks';\nexport { usefulTasks } from './useful_tasks';\n\nconst originCwd = path.resolve(process.cwd());\nconst setupResult = setup();\nusefulTasks(originCwd, setupResult.opt, setupResult.program);","import { Command } from 'commander';\nimport path from 'path';\n\nexport const DEFAULT_CONFIG = \"useful_tasks.json\";\nexport const DEFAULT_USE_CAMEL = true;\n\nexport const CwdRestore = 'restore';\nexport const CwdKeep = 'keep';\n\nexport const cwdModes = [CwdRestore, CwdKeep] as const;\ntype CwdModeTuple = typeof cwdModes;\nexport type CwdMode = CwdModeTuple[number];\n\nconst LogLevelInfo = 'info';\nconst LogLevelDebug = 'debug';\nconst LogLevelNone = 'none';\nexport const logLevels = [LogLevelNone, LogLevelInfo, LogLevelDebug] as const;\ntype LogLevelTuple = typeof logLevels;\nexport type LogLevel = LogLevelTuple[number];\n\nexport interface Options {\n    cwd?:string;\n    config:string;\n    include?:string[];\n    includeCta?:string[];\n    exclude?:string[];\n    excludeCta?:string[];\n    camelKeys:boolean;\n    cwdMode?:CwdMode;\n    cwdModeIsContinue?:boolean;\n    logLevel?:LogLevel;\n    extraArgs?:string[];\n}\n\n\nconst argDesc = {\n    cwdMode:`Choose between ${cwdModes.map((v)=>`'${v}'`).join(' or ')}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${CwdRestore}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${CwdKeep}' mode, the CWD will remain unchanged.`\n}\n\nexport const setup = (userArgv?:string[])=> {\n    // console.log('cwd', process.cwd());\n    // console.log('argv', process.argv);\n\n    const program = new Command();\n    program.name('useful-tasks').version(process.env.npm_package_version!)\n    .option('--cwd <string>','Change working directory')\n    .option('-c, --config <string>','A path of json configuraion', DEFAULT_CONFIG)\n    .option('-i, --include <items>','Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-a, --include-cta <items>','Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-e, --exclude <items>','Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('-x, --exclude-cta <items>','Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02')\n    .option('--camel-keys <boolean>','Specify whether to use camel case for the key of the variable. If the value is true, the paramter \"--var-my-key\" will be converted to \"myKey\" otherwise it will be \"my-key\"', DEFAULT_USE_CAMEL)\n    .option('--cwd-mode <string>',argDesc.cwdMode, CwdRestore)\n    .option('--log-level <string>', `Specify the logging level as ${logLevels.join(',')}. This parameter takes higher priority than the 'json' configuration.`)\n    .allowUnknownOption(true);\n    \n    if(userArgv !== undefined){\n        program.parse(userArgv, {from:'user'});\n    }else{\n        program.parse();\n    }\n\n    const opts = program.opts();\n    // console.log(opts);\n\n    const typedOptions = opts as Options;\n    typedOptions.include = fixStringArrayArgument(typedOptions.include);\n    typedOptions.includeCta = fixStringArrayArgument(typedOptions.includeCta);\n    typedOptions.exclude = fixStringArrayArgument(typedOptions.exclude);\n    typedOptions.excludeCta = fixStringArrayArgument(typedOptions.excludeCta);\n    \n    typedOptions.cwdModeIsContinue = typedOptions.cwdMode === CwdKeep;\n    \n    if(typedOptions.camelKeys !== undefined && typeof(typedOptions.camelKeys) === 'string'){\n        let v:string = typedOptions.camelKeys;\n        v = v.trim().toLowerCase();\n        if(v === 'false' || v === '0' || v === 'no'){\n            typedOptions.camelKeys = false;\n        }else if(v==='true' || v==='1' || v === 'yes'){\n            typedOptions.camelKeys = true;\n        }else{\n            typedOptions.camelKeys = DEFAULT_USE_CAMEL;\n        }\n    }\n    typedOptions.extraArgs = [...program.args ?? []];\n\n    // console.log(`Using options : ${JSON.stringify(typedOptions, undefined, 2)}`);\n    // console.log(`Extra arguments`, program.args);\n\n    if(typedOptions.cwd){\n        process.chdir(path.resolve(typedOptions.cwd));\n    }\n\n    // console.log(\"######################################################################\")\n\n    return {opt:typedOptions, program};\n}\n\nconst fixStringArrayArgument = (value:string|string[]|undefined, skipEmptyItem:boolean = true)=>{\n    if(!value){\n        return [];\n    }\n    \n    if(typeof value === 'string'){\n        const result:string[] = [];\n        const arr = value.split(',');\n        arr.forEach((value)=>{\n            const trimedValue = value.trim();\n            if(skipEmptyItem){\n                if(trimedValue.length > 0){\n                    result.push(trimedValue);\n                }\n            }else{\n                result.push(trimedValue);\n            }\n        });\n        return result;\n    }\n    \n    return [];\n};\n","import path from 'path';\nimport { LogLevel, Options, logLevels } from './build_cli_parser';\nimport { containsAllTag, containsTag, loadJsonConfig } from './utils';\nimport debug from 'debug';\nimport { Config, TAG_DEBUG, Task, TaskContext, DEFAULT_REPLACE_REGEX, VAR_FROM_ARGUMENT_PREFIX,  ENV_VAR_FROM_ARGUMENT_PREFIX, LOG_TAG, TAG_INFO } from './task_data';\nimport { applyVariables, searchExtraKeyValue, setTaskVar, setEnvVar } from './task_utils';\nimport { Command } from 'commander';\nimport { handlerMap } from './handler_map';\nimport { logi, logv } from './loggers';\n\nexport const usefulTasks = (originCwd:string, opt:Options, program:Command)=>{\n    let tasksConfig:Config = {};\n\n    let configFilePath = path.resolve(opt.config);\n    try{\n        tasksConfig = loadJsonConfig(configFilePath);\n    }catch(e:any){\n        if(e instanceof Error){\n            console.log(e.message);\n        }else{\n            console.log(e);\n        }\n        console.log(\"\");\n        program.help();\n    }\n    \n    let debugPat:string | undefined;\n    \n    let logLevel:LogLevel = 'info';\n    let replaceRegex = DEFAULT_REPLACE_REGEX;\n    if(tasksConfig.env && typeof(tasksConfig.env) === 'object'){\n        const env = tasksConfig.env;\n        \n        if(env.verbose || env.verboseGit){\n            logLevel = 'debug';\n        }\n\n        if(env.logLevel && logLevels.includes(env.logLevel)){\n            logLevel = env.logLevel;\n        }\n    \n        if(env.replaceRegex){\n            replaceRegex = env.replaceRegex;\n        }\n    }\n\n    //cli argument can overwrite json's logLeve\n    if(opt.logLevel && logLevels.includes(opt.logLevel)){\n        logLevel = opt.logLevel;\n    }\n\n    if(logLevel === 'debug'){\n        // debugPat = `${LOG_TAG}:*`;\n        debugPat = `${TAG_INFO},${TAG_DEBUG}`;\n        debugPat = `${debugPat},simple-git,simple-git:*`;\n    }else if(logLevel === 'info'){\n        debugPat = `${TAG_INFO}`;\n    }\n    \n    if(debugPat){\n        debug.enable(debugPat);\n    }\n\n    logv(`CLI Options`, opt);\n\n    if(typeof(replaceRegex) !== 'string'){\n        throw new Error(`replaceRegex '${replaceRegex}'  must be a string`);\n    }\n    if(replaceRegex.length < 1){\n        throw new Error(`replaceRegex '${replaceRegex}' cannot be empty`);\n    }\n    if(replaceRegex.indexOf('(') < 0 || replaceRegex.indexOf(')') < 0){\n        throw new Error(`replaceRegex '${replaceRegex}' must contain regex group express '(' and ')'`);\n    }\n    \n    const baseCwd = path.resolve(process.cwd());\n    \n    const context:TaskContext = {\n        originCwd,\n        baseCwd,\n        replaceRegex:new RegExp(replaceRegex),\n        vars:{\n            __env:{\n                cwd_startup:originCwd,\n                cwd_base:baseCwd\n            }\n        }\n    };\n    \n    if(opt.extraArgs){\n        logv(\"Setting up the variables from the additional arguments\");\n        searchExtraKeyValue(opt.extraArgs, VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\n            setTaskVar(context, key, value, false);\n        });\n    \n        logv(\"Setting up the environment variables from the additional arguments\");\n        searchExtraKeyValue(opt.extraArgs, ENV_VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key:string, value:string)=>{\n            setEnvVar(context, key, value, false);\n        });\n    }\n    \n    logi(\"\");\n    logi(`[${tasksConfig.name}] Start task processing`);\n    \n    const getTaskRepresentStr = (task:Task, i?:number)=>{ \n        if(i !== undefined && i !== null){\n            return task.id !== undefined ? `[${i}]${task.id}/${task.type}` : `[${i}]${task.type}`;\n        }else{\n            return task.id !== undefined ? `${task.id}/${task.type}` : `${task.type}`;\n        }\n    };\n    \n    const runTasks = async ()=>{\n        let tasks:Array<Task> = tasksConfig.tasks ?? [];\n    \n        for(let i=0;i<tasks.length;i++){\n            const task = tasks[i];\n\n            // Validate task IDs\n            if(task.id !== undefined && task.id !== null){\n                if(typeof(task.id) !== 'string'){\n                    throw new Error(`The task id must be a 'string' type`);\n                }\n    \n                if(task.id.length<1){\n                    throw new Error(`The task id cannot be empty`);\n                }\n    \n                for(let j=i+1;j<tasks.length;j++){\n                    const otherTask = tasks[j];\n                    if(otherTask.id !== undefined && otherTask.id === task.id){\n                        throw new Error(`The task id '${task.id}' must be unique`);\n                    }\n                }\n            }\n\n            if(!task.type || !(task.type in handlerMap)){\n                throw new Error(`Found the invalid task type '${task.type}'`);\n            }\n            \n            task.__compare__elements = [];\n            if(task.id){\n                task.id = task.id.trim()\n                task.__compare__elements.push(task.id.trim());\n            }\n            if(task.tags){\n                const printInvalidTags = (tags:any)=>{\n                    logv(`Ignoring invalid tags '${tags}'`);\n                };\n                if(typeof(task.tags) === 'string'){\n                    if(task.tags.length > 0){\n                        task.tags = task.tags.trim();\n                        task.__compare__elements.push(task.tags);\n                    }else{\n                        printInvalidTags(task.tags);\n                    }\n                }else if(Array.isArray(task.tags)){\n                    task.tags = task.tags.map((value:string)=>value.trim());\n                    for(const tag of task.tags){\n                        if(typeof(tag) === 'string' && tag.length>0){\n                            task.__compare__elements.push(tag);\n                        }else{\n                            printInvalidTags(tag);\n                        }\n                    }\n                }else{\n                    printInvalidTags(task.tags);\n                }\n            }\n        }\n    \n        if(opt.exclude && opt.exclude.length > 0){\n            const excludeItems = opt.exclude;\n    \n            logv(`Excluding tasks by specified IDs or Tags : --exclude=${excludeItems}`);\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(containsTag(excludeItems, taskItem.__compare__elements) === false){\n                    return taskItem;\n                }\n            });\n        }\n        if(opt.excludeCta && opt.excludeCta.length > 0){\n            const excludesItems = opt.excludeCta;\n    \n            logv(`Excluding tasks by specified IDs or Tags : --exclude-cta=${excludesItems}`);\n                tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(containsAllTag(excludesItems, taskItem.__compare__elements) === false){\n                    return taskItem;\n                }\n            });\n        }\n        const hasIncludeFilters = opt.include && opt.include.length > 0;\n        const hasIncludeCTAFilters = opt.includeCta && opt.includeCta.length > 0;\n        if(hasIncludeFilters || hasIncludeCTAFilters){\n            const includeItems = opt.include;\n            const includeCtaItems = opt.includeCta;\n    \n            logv(`Including tasks by specified IDs or Tags : --include=${includeItems} / --include-cta=${includeCtaItems}`);\n            tasks = tasks.filter((taskItem:Task, index:number, array:Task[])=>{\n                if(\n                    (hasIncludeFilters && containsTag(includeItems!, taskItem.__compare__elements) === true)\n                    ||\n                    (hasIncludeCTAFilters && containsAllTag(includeCtaItems!, taskItem.__compare__elements) === true)\n                ){\n                    return taskItem;\n                }\n            });\n        }\n    \n        logi(`Tasks : ${tasks.map((v,i)=>{ return getTaskRepresentStr(v,i);})}`);\n    \n        const taskCount = tasks.length ?? 0;\n        for(let i=0;i<taskCount; i++){\n            const task = tasks[i];\n            applyVariables(context, task);\n    \n            const taskRepresentStr = getTaskRepresentStr(task,i);\n            if(task.enabled === false){\n                logi(`\\n### Skip the task without execution => ${taskRepresentStr}`);\n                continue;\n            }else{\n                logi(`\\n### Task : ${taskRepresentStr}`)\n            }\n    \n            if(task.comment){\n                logi(task.comment);\n            }\n    \n            let cwdHasChanges = false;\n            if(task.cwd){\n                const taskCwd = path.resolve(task.cwd);\n                logi(`Changing the current working directory => ${taskCwd}`);\n                cwdHasChanges = true;\n                process.chdir(taskCwd);\n            }\n            \n            const taskHandler = handlerMap[task.type];\n            await taskHandler(context, task);\n    \n            if(!opt.cwdModeIsContinue){\n                if(cwdHasChanges){\n                    logi(`Restoring the current working directory => ${baseCwd}`);\n                }\n                process.chdir(baseCwd);\n            }\n        }\n    };\n    \n    runTasks().then(()=>{}).catch((reason:any)=>{\n        throw reason;\n    }).finally(()=>{\n        process.chdir(baseCwd);\n        logi(`[${tasksConfig.name}] Tasks done\\n`);\n    });\n};\n","import fs from 'fs';\nimport path from 'path';\nimport json5 from 'json5';\n\nexport const loadJson = (filePath:string)=>{\n    if(!fs.existsSync(filePath)){\n        throw new Error(`ERROR: The Path '${filePath}' does not exists!`);\n    }\n\n    const fileString = fs.readFileSync(filePath, {encoding:'utf-8'});\n    return json5.parse(fileString);\n};\n\n\nexport const loadJsonConfig = (filePath:string)=>{\n    let configJson = loadJson(filePath);\n    if(configJson.extends){\n        const filePathDir = path.dirname(filePath);\n        const extendsFilePath = path.resolve(filePathDir, configJson.extends);\n        configJson = Object.assign({}, configJson, loadJsonConfig(extendsFilePath));\n    }\n    \n    return configJson;\n};\n\nexport const convertOrNotHyphenTextToCamelText=(text:string, flag:boolean)=>{\n    if(!flag){\n        return text;\n    }\n\n    let result = '';\n    let textArr = text.split(\"-\");\n    for(let i=0;i<textArr.length;i++){\n        let word = textArr[i];\n        if(i===0){\n            result = word;\n        }else{\n            if(word.length>0){\n                word = `${word[0].toUpperCase()}${word.substring(1)}`;\n            }\n            result = `${result}${word}`;\n        }\n    }\n    return result;\n}\n\n\n\nexport const containsTag = (elements:string[], tags:string[])=>{\n    if(elements.length < 1){\n        return false;\n    }\n    \n    for(const el of elements){\n        for(const tag of tags){\n            if(el === tag){\n                return true;    \n            }\n        }        \n    }\n\n    return false;\n};\n\nexport const containsAllTag = (elements:string[], tags:string[])=>{\n    if(elements.length < 1){\n        return false;\n    }\n    for(const el of elements){\n        let contained = false;\n        for(const tag of tags){\n            if(tag === el){\n                contained = true;\n                break;\n            }\n        }        \n        if(!contained){\n            return false;\n        }        \n    }\n    return true;\n};","import { LogLevel } from './build_cli_parser';\n\nexport interface TaskContext {\n    originCwd:string;\n    baseCwd:string;\n    replaceRegex:RegExp;\n    vars:any;\n}\n\nexport const allTaskTypes = ['git-repo-prepare','symlink','cmd','set-var','output','fs-copy','fs-del','env-var','sub-tasks', 'content-replace'] as const;\ntype TasksTuple = typeof allTaskTypes;\nexport type TaskType = TasksTuple[number];\n\nexport interface Task {\n    type:TaskType;\n    id?:string;\n    tags?:string | string[],\n    cwd?:string;\n    enabled?:boolean;\n    comment?:string;\n    __compare__elements:string[];\n}\n\nexport interface TaskGitCheckout extends Task{\n    /** Executable git binary */\n    binary?:string;\n    url?:string;\n    localPath:string;\n    branch?:string;\n    startPoint?:string;\n    updateSubmodules?:Array<string> | string | boolean;\n}\n\nexport interface TaskSymlink extends Task{\n    target:string;\n    path:string;\n    linkType?:'dir' | 'file' | 'junction';\n    forced?:boolean;\n}\n\nexport interface TaskTerminalCommand extends Task{\n    cmd:string;\n    shell?:string;\n}\n\nexport interface TaskSetVar extends Task{\n    key:string;\n    value:string|number|any|boolean;\n    varType:'value'|'file';\n    fileFormat:'json'|'string';\n    isFallback?:boolean;\n\n    /** @deprecated */\n    var?:string|number|any|boolean;\n}\n\nexport interface TaskEnvVar extends Task{\n    value:any;\n    varType:'dict'|'file';\n    isFallback?:boolean;\n    /** @deprecated */\n    var?:any;\n}\n\nexport type TaskOutputTargets = 'console'|'file-write'|'file-append'|'c'|'fw'|'fa';\nexport interface TaskOutput extends Task{\n    text:string;\n    target:TaskOutputTargets;\n    path?:string;\n}\n\nexport interface GlobFilters {\n    include?:string | string[];\n    exclude?:string | string[];\n}\n\nexport type TaskFsCopyOptions = {\n    conflict?:'overwrite'|'skip';\n};\n\nexport interface TaskFsCopy extends Task, GlobFilters {\n    src:string;\n    dest:string;\n    options?:TaskFsCopyOptions;\n}\n\nexport interface TaskFsDelete extends Task, GlobFilters{\n    path:string;\n}\n\nexport interface TaskSubTasks extends Task{\n    args:string;\n}\n\n/**\n * TODO: implements\n */\nexport interface RegexData {\n    pattern:string;\n    flags?:string;\n}\n\n/**\n * TODO: implements\n */\nexport interface TaskContentReplace extends Task, GlobFilters {\n    path:string;\n\n    find:string | RegexData;\n    replace:string;\n    loop?:number;\n}\n\nexport interface Config {\n    name?:string;\n    \n    env?:{\n        logLevel?:LogLevel;\n        /** @deprecated */\n        verbose?:boolean;\n        /** @deprecated */\n        verboseGit?:boolean;\n        replaceRegex?:string;\n    };\n    tasks?:Array<Task>;\n}\n\nexport const LOG_TAG = \"useful-tasks\";\nexport const TAG_DEBUG = `${LOG_TAG}:debug`;\nexport const TAG_INFO = `${LOG_TAG}:info`;\n\n/** e.g. ${value.key} */\nexport const DEFAULT_REPLACE_REGEX = \"\\\\$\\\\{([a-zA-Z0-9\\\\.\\\\-_]*)\\\\}\";\n\nexport const VAR_FROM_ARGUMENT_PREFIX = \"--var-\";\nexport const ENV_VAR_FROM_ARGUMENT_PREFIX = \"--env-\";","import debug from \"debug\";\nimport { TAG_DEBUG, TAG_INFO } from \"./task_data\";\n\nexport const logv = debug(TAG_DEBUG);\nexport const logi = debug(TAG_INFO);","import { logv } from \"./loggers\";\nimport { Task, TaskContext } from \"./task_data\";\nimport { convertOrNotHyphenTextToCamelText, loadJson } from './utils';\n\nexport const applyVariables = async (context:TaskContext, task:Task)=>{\n    const anyTypeTask:any = task as any;\n    for(const key of Object.keys(anyTypeTask)) {\n        if(typeof(key) !== 'string'){\n            continue;\n        }\n        \n        if(key === 'id' || key === 'tags'){\n            continue;   \n        }\n        \n        if(anyTypeTask[key] !== undefined && typeof(anyTypeTask[key]) ==='string'){\n            let valueOfKey:string = anyTypeTask[key];\n            while(true){\n                const match = context.replaceRegex.exec(valueOfKey);\n                if(match === null || match === undefined){\n                    break;\n                }\n                \n                const matchedStr = match[0];\n                const varPath = match[1];\n\n                let currentVar = context.vars;\n                if(varPath.length > 0){\n                    const varPaths = varPath.split(\".\");\n                    for(let i=0; i<varPaths.length;i++){\n                        const varEl = varPaths[i];\n                        if(currentVar.hasOwnProperty(varEl)){\n                            currentVar = currentVar[varEl];\n                        }else{\n                            throw new Error(`The value of ${varPath} could not be found!`);\n                        }\n                    }\n                }\n\n                const valuePrefix = valueOfKey.substring(0, match.index);\n                const valueReplace = `${currentVar}`;\n                const valueSuffix = valueOfKey.substring(match.index+matchedStr.length);                    \n                valueOfKey = `${valuePrefix}${valueReplace}${valueSuffix}`;\n                logv(`Variable injection: '${key}'=>'${valueOfKey}'`);\n            }\n            \n            anyTypeTask[key] = valueOfKey;\n        }\n    }\n};\n\n\nexport const searchExtraKeyValue = (extraArgs:string[], fmt:string, convertToCamelKeys:boolean, callback:(key:string, value:string)=>void)=>{\n    let currentVarName:string|undefined;\n    let useNextElementAsVar:boolean = false;\n    \n    for(let extraArg of extraArgs){\n        const arg = extraArg.trim();\n        if(arg === '--'){\n            logv(\"Stop parsing by '--'\")\n            break;\n        }\n\n        if(useNextElementAsVar && currentVarName){\n            const value = extraArg.startsWith(\"-\") ? \"\":extraArg;\n            callback(currentVarName, value);\n            currentVarName = undefined;\n            useNextElementAsVar = false;\n        }else{\n            const prefixIndex = extraArg.indexOf(fmt);\n            if(prefixIndex >= 0){\n                const equalMarkIndex = extraArg.indexOf(\"=\");\n                if(equalMarkIndex >= 0){\n                    const varName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length, equalMarkIndex), convertToCamelKeys);\n                    const value = extraArg.substring(equalMarkIndex+1);\n                    callback(varName, value);\n                }else{\n                    currentVarName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length), convertToCamelKeys);\n                    useNextElementAsVar = true;\n                }\n            }    \n        }\n    }\n};\n\n\nexport const setTaskVar = (context:TaskContext, key:string, value:any, skipForExists:boolean)=>{\n    if(skipForExists && context.vars[key] !== undefined){\n        logv(`Skips assigning the variable ${key}=${value} because it already exists.`);\n        return;\n    }\n\n    logv(`Sets the variable ${key}=${value}`);\n    context.vars[key] = value;\n}\n\nexport const setEnvVar = (context:TaskContext, key:string, value:any, skipForExists:boolean)=>{\n    var valueType = typeof(value);\n    if(valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean'){\n        logv(`Ignoring the invalid typed(${valueType}) environment variable ${key}=${value}`);\n    }else{\n        const stringVal = String(value);\n        if(stringVal.length < 1){\n            logv(`Ignoring the invalid environment variable ${key}=${value}`);\n        }else{\n            if(skipForExists && process.env[key] !== undefined){\n                logv(`Skips assigning the environment variable ${key}=${value} because it already exists.`);\n                return;\n            }\n\n            logv(`Sets the environment variable ${key}=${value}`);\n            process.env[key] = String(value);\n        }\n    }\n}\n","import stringArgv from 'string-argv';\nimport { TaskContext, TaskSubTasks } from './task_data';\nimport { usefulTasks } from './useful_tasks';\nimport { setup } from './build_cli_parser';\n\nexport const handleSubTasks = async (context:TaskContext, task:TaskSubTasks)=>{\n    if(!task.args || typeof(task.args) !== 'string'){\n        throw new Error(`Found missing or invalid property 'args' that is required`);\n    }\n\n    const subArgv = stringArgv(task.args);\n    const setupResult = setup(subArgv);\n    usefulTasks(context.originCwd, setupResult.opt, setupResult.program);\n}\n","import fs from 'fs';\nimport { execSync } from 'child_process';\nimport path from 'path';\nimport {CheckRepoActions, ResetMode, simpleGit} from 'simple-git';\nimport { CopyOptionsSync, CopySyncOptions, copyFileSync, copySync, mkdirpSync, removeSync } from 'fs-extra'\nimport { TaskContext, TaskOutput, TaskSetVar, TaskGitCheckout, TaskSymlink, TaskTerminalCommand, TaskOutputTargets, TaskFsCopy, TaskFsDelete, TaskEnvVar, TaskContentReplace, RegexData } from './task_data';\nimport { loadJson } from './utils';\nimport json5 from 'json5';\nimport { setEnvVar, setTaskVar } from './task_utils';\nimport { logi, logv } from './loggers';\nimport { processWithGlobSync } from './glob_handler';\n\nconst throwInvalidParamError = <T, K extends keyof T>(obj:T, key:K) => {\n    throw new Error(`The parameter '${String(key)}' has an invalid value ${obj[key]}`);\n};\n\nexport const handleGitRepoSetup = async (context:TaskContext, task:TaskGitCheckout)=>{\n    const localPath = path.resolve(task.localPath);\n\n    if(!fs.existsSync(localPath)){\n        fs.mkdirSync(localPath, {recursive:true});\n    }\n\n    if(fs.readdirSync(localPath).length === 0){\n        if(task.url){\n            await simpleGit().clone(task.url, localPath);\n        }\n    }\n\n    const git = simpleGit(localPath, {binary:task.binary});\n\n    const isGitRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);\n    if(!isGitRepo){\n        throw Error(`${localPath} is not a git repository!!!`);\n    }\n\n    \n    if(task.updateSubmodules){\n        await git.submoduleInit();\n        await git.submoduleUpdate();\n    }else{\n        // const submodules = task.updateSubmodules ?? [];\n        // for(var submod of submodules){\n        // }\n    }\n\n    await git.fetch();\n\n    if(task.branch){\n        let hasLocalBranch = false;\n        const branchLocal = await git.branchLocal();\n        for(var b of branchLocal.all){\n            if(b === task.branch){\n                hasLocalBranch = true;\n                break;\n            }\n        }\n\n        const branch = task.branch ?? \"\";\n        const startPoint:string = task.startPoint ?? \"\";\n\n        if(!hasLocalBranch){\n            await git.checkoutBranch(branch, startPoint)\n        }else{\n            if(branchLocal.current !== task.branch){\n                await git.checkout(branch);\n            }\n            await git.reset(ResetMode.HARD, [startPoint])\n        }\n    }\n}\n\nexport const handleSymlink = async (context:TaskContext, task:TaskSymlink)=>{\n    const target:string = path.resolve(task.target);\n    const dstPath:string = path.resolve(task.path);\n\n    if(fs.existsSync(dstPath)){\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\n        logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n        if(task.forced){\n            if(lstat.isSymbolicLink() || lstat.isFile()){\n                logv(`Unlink ${dstPath}`);\n                fs.unlinkSync(dstPath);\n            }else if(lstat.isDirectory()){\n                logv(`Remove directory '${dstPath}'`);\n                removeSync(dstPath);\n            }\n        }\n    }\n\n    if(fs.existsSync(dstPath)){\n        logv(`Could not create symbolic link cause '${dstPath}' already exists`);\n        // throw Error()\n    }else{\n        logv(`Create symbolic link ${target} => ${dstPath}`);\n        fs.symlinkSync(target, dstPath, task.linkType);\n        const lstat:fs.Stats = fs.lstatSync(dstPath);\n        logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n    }\n}\n\nexport const handleTerminalCommand = async (context:TaskContext, task:TaskTerminalCommand)=>{\n    logv(`Start execution... ${task.cmd}`);\n    execSync(task.cmd,{\n        shell: task.shell,\n        // cwd: cwd, \n        env: process.env,\n        stdio: [process.stdin, process.stdout, process.stderr],\n        encoding: 'utf-8'\n    })\n}\n\n\nexport const handleSetVar = async (context:TaskContext, task:TaskSetVar)=>{\n    if(task.key === undefined || !task.key || typeof(task.key) !== 'string' || task.key.length < 1){\n        throw new Error(`Invalid key ${task.key}. It must be a string.`);\n    }\n    \n    let value = task.value;\n    //old version support\n    if((value === undefined || value === null) && task.var){\n        value = task.var;\n    }\n\n    if(task.isFallback !== true){\n        task.isFallback = false;\n    }\n\n    if(task.varType === 'file'){\n        if(typeof(value) !== 'string'){\n            throw new Error(`The \"value\" must contain path of a file with \"varType\":\"${task.varType}\"`);\n        }\n        \n        const varsPath = path.resolve(value);\n        if(!fs.existsSync(varsPath)){\n            throw new Error(`File \"${varsPath}\" does not exist to use as a variable`);\n        }\n\n        value = fs.readFileSync(varsPath ,{encoding:'utf8'});\n        if(task.fileFormat === 'json'){\n            value = json5.parse(value);\n        }\n    }\n\n    setTaskVar(context, task.key, value, task.isFallback);\n}\n\n\nexport const handleEnvVar = async (context:TaskContext, task:TaskEnvVar)=>{\n    let value = task.value;\n\n    //old version support\n    if((value === undefined || value === null) && task.var){\n        value = task.var;\n    }\n\n    if(task.isFallback !== true){\n        task.isFallback = false;\n    }\n    const isFallback:boolean = task.isFallback;\n    \n    if(task.varType === 'file'){\n        if(typeof(value) !== 'string'){\n            throw new Error(`The \"value\" must contain path of a file with \"varType\":\"${task.varType}\"`);\n        }\n        \n        const varsPath = path.resolve(value);\n        value = loadJson(varsPath);\n    }\n\n    if(typeof(value) !== 'object'){\n        throw new Error(`The content of the \"value\" must be in the form of key-value pairs. For example: {\"KEY_A\":\"value_a\", \"KEY_B\":\"value_b\"}`);\n    }\n\n    Object.keys(value).forEach(key => {\n        setEnvVar(context, key, value[key], isFallback);\n    });\n}\n\nexport const handleOutput = async (context:TaskContext, task:TaskOutput)=>{\n    const text = task.text ?? '';\n    const target:TaskOutputTargets = (task.target ?? 'c').trim() as TaskOutputTargets;\n    const targetPath = task.path;\n    \n    if(target === 'c' || target === 'console'){\n        console.log(text);\n    }else{\n        if(!targetPath){\n            throw new Error(`The parameter 'path' is required for a target '${target}'!`);\n        }\n\n        const resolvedPath = path.resolve(targetPath);\n        const dir = path.dirname(resolvedPath);\n        if(!fs.existsSync(dir)){\n            mkdirpSync(dir);\n        }\n\n        if(target == 'fa' || target == 'file-append'){\n            let err;\n            let fd;\n            try{\n                fd = fs.openSync(resolvedPath,'a');\n                fs.appendFileSync(fd, text, 'utf8');\n            }catch(e){\n                err = e;\n            }finally{\n                if(fd !== undefined){\n                    fs.closeSync(fd);\n                }\n            }\n\n            if(err){\n                throw err;\n            }\n        }else{\n            fs.writeFileSync(resolvedPath, text);\n        }\n    }\n}\n\nconst resolveStringArray = (val:string | string[] | undefined | null, defaultValue:string[]):string[]=>{\n    if(val !== undefined && val !== null){\n        if(typeof(val) === 'string'){\n            return [val];\n        }else if(Array.isArray(val)){\n            return val.filter((v)=>typeof(v)==='string');\n        }\n    }\n\n    return [];\n};\n\n\nconst runCopy = (src:string, dst:string, options:CopySyncOptions)=>{\n    logv(`Copy: ${src} => ${dst}`);\n    copySync(src,dst,options);\n};\n\nexport const handleFsCopy = async (context:TaskContext, task:TaskFsCopy)=>{\n    if(!fs.existsSync(task.src)){\n        throw new Error(`The source '${task.src}' does not exist`);\n    }\n    \n    const conflict = task?.options?.conflict;\n    let overwrite = conflict === undefined || conflict === null || (typeof(conflict) === 'string' && conflict.trim() === 'overwrite');\n\n    /** @deprecated support migrate from '0.1.18' */ \n    if(task.options && 'overwrite' in task?.options && typeof(task?.options?.overwrite) === 'boolean'){\n        overwrite = task.options.overwrite;\n    }\n\n    const cpOpt:CopyOptionsSync = { overwrite };\n    \n    const runGlobSync = (items:string[])=>{\n        for(const f of items){\n            const from = path.join(task.src, f);\n            const to = path.join(task.dest, f);\n            runCopy(from, to, cpOpt);\n        }\n    };\n\n    const handled = processWithGlobSync(runGlobSync, task.src, \n        resolveStringArray(task.include, []),\n        resolveStringArray(task.exclude, []),\n        false, false);\n\n    if(!handled){\n        runCopy(task.src, task.dest, cpOpt);\n    }\n}\n\nconst runDelete = (path:string)=>{\n    logv(`Delete: ${path}`);\n    removeSync(path);\n};\n\nexport const handleFsDelete = async (context:TaskContext, task:TaskFsDelete)=>{\n    if(!fs.existsSync(task.path)){\n        logv(`The '${task.path}' does not exist and cannot be deleted`);\n        return;\n    }\n\n    const runGlobSync = (items:string[])=>{\n        for(const f of items){\n            runDelete(path.join(task.path, f));\n        }\n    };\n\n    const handled = processWithGlobSync(runGlobSync, task.path, \n        resolveStringArray(task.include, []),\n        resolveStringArray(task.exclude, []),\n        false, false);\n\n    if(!handled){\n        runDelete(task.path);\n    }\n}\n\nconst runFindAndReplaceWithRegex = (content:string, find:RegExp, replace:string, repeat:number):string=>{\n    var text:string = content;\n    if(repeat < 1){\n        while(find.test(text)){\n            text = text.replace(find, replace);\n        }\n    }else{\n        for(var i=0;i<repeat;i++){\n            if(find.test(text)){\n                text = text.replace(find, replace);\n            }\n        }\n    }\n    return text;\n};\n\nconst runFindAndReplaceWithText = (content:string, find:string, replace:string, repeat:number):string=>{\n    var text:string = content;\n    if(repeat < 1){\n        while(text.indexOf(find) >= 0){\n            text = text.replace(find, replace);\n        }\n    }else{\n        for(var i=0;i<repeat;i++){\n            if(text.indexOf(find) >= 0){\n                text  = text.replace(find, replace);\n            }\n        }\n    }\n    return text;\n};\n\nconst isRegexData = (v:any)=>{\n    if(v !== undefined && v !== null && typeof(v) === 'object' && 'pattern' in v && typeof(v.pattern) === 'string'){\n        return true;\n    }\n    return false;\n};\n\ntype FindAndReplaceFunc = ((content:string, find:any, replace:string, repeat:number)=>string);\n\nconst findAndReplaceWithFile = (path:string, replaceFunc:FindAndReplaceFunc, find:string | RegExp, replace:string, repeat:number) => {\n    logv(`Find and Replace: ${path}`);\n    const content:string = fs.readFileSync(path, 'utf-8');\n    const newContent = replaceFunc(content, find, replace, repeat);\n    fs.writeFileSync(path, newContent, 'utf-8');\n};\n\nexport const handleContentReplace = async (context:TaskContext, task:TaskContentReplace)=>{\n    if(!fs.existsSync(task.path)){\n        logv(`The '${task.path}' does not exist`);\n        return;\n    }\n\n    if(task.replace === undefined || typeof(task.replace) !== 'string'){\n        throwInvalidParamError(task, 'replace');\n    }\n\n    let loop:number = task.loop === undefined || task.loop === null? 1 : task.loop;\n    if(typeof(loop) === 'string'){\n        loop = parseInt(loop, 10);\n    }else if(typeof(loop) !== 'number'){\n        throwInvalidParamError(task, 'loop');\n    }\n\n    let find:string | RegExp;\n    let replaceFunc:FindAndReplaceFunc;\n    if(isRegexData(task.find)){\n        const regexData = task.find as RegexData;\n        find = new RegExp(regexData.pattern, regexData.flags);\n        replaceFunc = runFindAndReplaceWithRegex;\n    }else if(typeof(task.find) === 'string'){\n        find = task.find;\n        replaceFunc = runFindAndReplaceWithText;\n    }else{\n        throwInvalidParamError(task, 'find');\n        return;\n    }\n\n    const runGlobSync = (items:string[])=>{\n        for(const f of items){\n            const itemPath:string = path.join(task.path, f);\n            if(fs.statSync(itemPath).isDirectory()){\n                continue;\n            }\n            findAndReplaceWithFile(path.join(task.path, f), replaceFunc, find, task.replace, loop);\n        }\n    };\n\n    const handled = processWithGlobSync(runGlobSync, task.path, \n        resolveStringArray(task.include, []),\n        resolveStringArray(task.exclude, []),\n        true, true);\n\n    if(!handled){\n        findAndReplaceWithFile(task.path, replaceFunc, find, task.replace, loop);\n    }\n}\n\n","import fs from 'fs';\nimport { globSync } from 'glob';\n\n/**\n * \n * @param handler \n * @param cwd \n * @param includes \n * @param excludes \n * @param includeAllForNonFilter \n * @param subOptions \n * @returns true - filters are applied, false - there was no filter to apply\n */\nexport const processWithGlobSync = (\n    handler:(items:string[])=>void, cwd:string, \n    includes:string[], excludes:string[],\n    skipDirs:boolean,\n    includeAllForNonFilters:boolean\n    ):boolean =>{\n\n    if(fs.statSync(cwd).isDirectory() === false){\n        return false;\n    }\n\n\n    //pre apply filter for faster performance\n    const nodir:boolean = skipDirs === true;\n\n    const ilen:boolean = includes.length > 0;\n    const elen:boolean = excludes.length > 0;\n    if(!ilen && elen){\n        //include all to apply excludes\n        handler(globSync('**', {ignore:['.', ...excludes], cwd, nodir}));\n        return true;\n    }else if(ilen && !elen){\n        //apply includes only\n        handler(globSync(includes, { cwd, nodir}));\n        return true;\n    }else if(ilen && elen){\n        //apply include and exclude\n        handler(globSync(includes, {ignore:excludes, cwd, nodir}));\n        return true;\n    }else if(includeAllForNonFilters){\n        //include all to apply skipDirs, skipFiles\n        handler(globSync('**', {ignore:['.'], cwd, nodir}));\n        return true;\n    }\n\n    return false;\n};","import { handleSubTasks } from \"./handler_sub_tasks\";\nimport { handleContentReplace, handleEnvVar, handleFsCopy, handleFsDelete, handleGitRepoSetup, handleOutput, handleSetVar, handleSymlink, handleTerminalCommand } from \"./handlers\";\nimport { TaskContext, TaskType } from \"./task_data\";\n\nexport const handlerMap:{\n    [k in TaskType]:(context:TaskContext, task:any)=>Promise<void>\n} = {\n    \"git-repo-prepare\": handleGitRepoSetup,\n    symlink: handleSymlink,\n    cmd: handleTerminalCommand,\n    \"set-var\": handleSetVar,\n    output: handleOutput,\n    \"fs-copy\":handleFsCopy,\n    \"fs-del\":handleFsDelete,\n    \"env-var\":handleEnvVar,\n    \"sub-tasks\": handleSubTasks,\n    \"content-replace\":handleContentReplace\n};"],"mappings":"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","names":["src_exports","__export","usefulTasks","__toCommonJS","import_path","import_commander","import_path","DEFAULT_CONFIG","DEFAULT_USE_CAMEL","CwdRestore","CwdKeep","cwdModes","LogLevelInfo","LogLevelDebug","LogLevelNone","logLevels","argDesc","v","setup","userArgv","program","typedOptions","fixStringArrayArgument","path","value","skipEmptyItem","result","trimedValue","import_path","import_fs","import_path","import_json5","loadJson","filePath","fs","fileString","json5","loadJsonConfig","configJson","filePathDir","path","extendsFilePath","convertOrNotHyphenTextToCamelText","text","flag","result","textArr","i","word","containsTag","elements","tags","el","tag","containsAllTag","contained","import_debug","LOG_TAG","TAG_DEBUG","TAG_INFO","DEFAULT_REPLACE_REGEX","VAR_FROM_ARGUMENT_PREFIX","ENV_VAR_FROM_ARGUMENT_PREFIX","import_debug","logv","debug","TAG_DEBUG","logi","TAG_INFO","applyVariables","context","task","anyTypeTask","key","valueOfKey","match","matchedStr","varPath","currentVar","varPaths","i","varEl","valuePrefix","valueReplace","valueSuffix","logv","searchExtraKeyValue","extraArgs","fmt","convertToCamelKeys","callback","currentVarName","useNextElementAsVar","extraArg","value","equalMarkIndex","varName","convertOrNotHyphenTextToCamelText","setTaskVar","skipForExists","setEnvVar","valueType","import_string_argv","handleSubTasks","context","task","subArgv","stringArgv","setupResult","setup","usefulTasks","import_fs","import_child_process","import_path","import_simple_git","import_fs_extra","import_json5","import_fs","import_glob","processWithGlobSync","handler","cwd","includes","excludes","skipDirs","includeAllForNonFilters","fs","nodir","ilen","elen","throwInvalidParamError","obj","key","handleGitRepoSetup","context","task","localPath","path","fs","git","hasLocalBranch","branchLocal","b","branch","startPoint","handleSymlink","target","dstPath","lstat","logv","handleTerminalCommand","handleSetVar","value","varsPath","json5","setTaskVar","handleEnvVar","isFallback","loadJson","setEnvVar","handleOutput","text","targetPath","resolvedPath","dir","err","fd","e","resolveStringArray","val","defaultValue","v","runCopy","src","dst","options","handleFsCopy","conflict","overwrite","cpOpt","processWithGlobSync","items","f","from","to","runDelete","handleFsDelete","runFindAndReplaceWithRegex","content","find","replace","repeat","runFindAndReplaceWithText","isRegexData","findAndReplaceWithFile","replaceFunc","newContent","handleContentReplace","loop","regexData","itemPath","handlerMap","handleGitRepoSetup","handleSymlink","handleTerminalCommand","handleSetVar","handleOutput","handleFsCopy","handleFsDelete","handleEnvVar","handleSubTasks","handleContentReplace","usefulTasks","originCwd","opt","program","tasksConfig","configFilePath","path","loadJsonConfig","e","debugPat","logLevel","replaceRegex","DEFAULT_REPLACE_REGEX","env","logLevels","TAG_INFO","TAG_DEBUG","debug","logv","baseCwd","context","searchExtraKeyValue","VAR_FROM_ARGUMENT_PREFIX","key","value","setTaskVar","ENV_VAR_FROM_ARGUMENT_PREFIX","setEnvVar","logi","getTaskRepresentStr","task","i","tasks","j","otherTask","handlerMap","printInvalidTags","tags","tag","excludeItems","taskItem","index","array","containsTag","excludesItems","containsAllTag","hasIncludeFilters","hasIncludeCTAFilters","includeItems","includeCtaItems","v","taskCount","applyVariables","taskRepresentStr","cwdHasChanges","taskCwd","taskHandler","reason","originCwd","path","setupResult","setup","usefulTasks"]}