{"version":3,"sources":["../src/index.ts","../src/build_cli_parser.ts","../package.json","../src/useful_tasks.ts","../src/utils.ts","../src/loggers.ts","../src/task_data.ts","../src/task_utils.ts","../src/tasks/handleSubTasks.ts","../src/tasks/handleContentReplace.ts","../src/glob_handler.ts","../src/tasks/handleFsMkdir.ts","../src/tasks/handleFsDelete.ts","../src/tasks/handleFsCopy.ts","../src/tasks/handleOutput.ts","../src/tasks/handleEnvVar.ts","../src/tasks/handleSetVar.ts","../src/tasks/handleTerminalCommand.ts","../src/tasks/handleFsSymlink.ts","../src/tasks/handleGitRepoSetup.ts","../src/handler_map.ts"],"sourcesContent":["#!/usr/bin/env node\r\n\r\nimport path from 'path';\r\nimport { setup } from './build_cli_parser';\r\nimport { initUsefulTasks, usefulTasks } from './useful_tasks';\r\n\r\nexport { initUsefulTasks, usefulTasks };\r\n\r\nconst originCwd = path.resolve(process.cwd());\r\nconst setupResult = setup();\r\ninitUsefulTasks(originCwd, setupResult.opt, setupResult.program);\r\n","import { Command } from 'commander';\r\nimport path from 'path';\r\nimport * as packageJson from '../package.json';\r\n\r\nexport const DEFAULT_CONFIG = 'useful_tasks.json';\r\nexport const DEFAULT_USE_CAMEL = true;\r\n\r\nexport const CWD_RESTORE = 'restore';\r\nexport const CWD_KEEP = 'keep';\r\n\r\nexport const CWD_MODES = [CWD_RESTORE, CWD_KEEP] as const;\r\ntype CwdModeTuple = typeof CWD_MODES;\r\nexport type CwdMode = CwdModeTuple[number];\r\n\r\nconst LogLevelInfo = 'info';\r\nconst LogLevelDebug = 'debug';\r\nconst LogLevelNone = 'none';\r\nexport const logLevels = [LogLevelNone, LogLevelInfo, LogLevelDebug] as const;\r\ntype LogLevelTuple = typeof logLevels;\r\nexport type LogLevel = LogLevelTuple[number];\r\n\r\nexport interface Options {\r\n  cwd?: string;\r\n  config: string;\r\n  include?: string[];\r\n  includeCta?: string[];\r\n  exclude?: string[];\r\n  excludeCta?: string[];\r\n  camelKeys: boolean;\r\n  cwdMode?: CwdMode;\r\n  logLevel?: LogLevel;\r\n  extraArgs?: string[];\r\n}\r\n\r\nconst argDesc = {\r\n  cwdMode: `Choose between ${CWD_MODES.map((v) => `'${v}'`).join(\r\n    ' or '\r\n  )}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${CWD_RESTORE}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${CWD_KEEP}' mode, the CWD will remain unchanged.`,\r\n};\r\n\r\n/**\r\n * Initialize the command line parser and parse the arguments.\r\n * @param userArgv - The command line arguments to parse. If not provided, it will use the current process arguments.\r\n * @returns\r\n */\r\nexport const setup = (userArgv?: string[]) => {\r\n  // console.log('cwd', process.cwd());\r\n  // console.log('argv', process.argv);\r\n\r\n  const program = new Command();\r\n  program\r\n    .name('useful-tasks')\r\n    .version(packageJson.version)\r\n    .option('--cwd <string>', 'Change working directory')\r\n    .option('-c, --config <string>', 'A path of json configuraion', DEFAULT_CONFIG)\r\n    .option(\r\n      '-i, --include <items>',\r\n      'Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '-a, --include-cta <items>',\r\n      'Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '-e, --exclude <items>',\r\n      'Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '-x, --exclude-cta <items>',\r\n      'Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02'\r\n    )\r\n    .option(\r\n      '--camel-keys <boolean>',\r\n      'Specify whether to use camel case for the key of the variable. If the value is true, the paramter \"--var-my-key\" will be converted to \"myKey\" otherwise it will be \"my-key\"',\r\n      DEFAULT_USE_CAMEL\r\n    )\r\n    .option('--cwd-mode <string>', argDesc.cwdMode)\r\n    .option(\r\n      '--log-level <string>',\r\n      `Specify the logging level as ${logLevels.join(\r\n        ','\r\n      )}. This parameter takes higher priority than the 'json' configuration.`\r\n    )\r\n    // Allow unknown option to allow syntax such as \"--var-my-key\" to be passed to the program\r\n    .allowUnknownOption(true);\r\n\r\n  if (userArgv !== undefined) {\r\n    program.parse(userArgv, { from: 'user' });\r\n  } else {\r\n    program.parse();\r\n  }\r\n\r\n  const opts = program.opts();\r\n  // console.log(opts);\r\n\r\n  const typedOptions = opts as Options;\r\n  typedOptions.include = fixStringArrayArgument(typedOptions.include);\r\n  typedOptions.includeCta = fixStringArrayArgument(typedOptions.includeCta);\r\n  typedOptions.exclude = fixStringArrayArgument(typedOptions.exclude);\r\n  typedOptions.excludeCta = fixStringArrayArgument(typedOptions.excludeCta);\r\n\r\n  if (typedOptions.camelKeys !== undefined && typeof typedOptions.camelKeys === 'string') {\r\n    let v: string = typedOptions.camelKeys;\r\n    v = v.trim().toLowerCase();\r\n    if (v === 'false' || v === '0' || v === 'no') {\r\n      typedOptions.camelKeys = false;\r\n    } else if (v === 'true' || v === '1' || v === 'yes') {\r\n      typedOptions.camelKeys = true;\r\n    } else {\r\n      typedOptions.camelKeys = DEFAULT_USE_CAMEL;\r\n    }\r\n  }\r\n  typedOptions.extraArgs = [...(program.args ?? [])];\r\n\r\n  // console.log(`Using options : ${JSON.stringify(typedOptions, undefined, 2)}`);\r\n  // console.log(`Extra arguments`, program.args);\r\n\r\n  if (typedOptions.cwd) {\r\n    process.chdir(path.resolve(typedOptions.cwd));\r\n  }\r\n\r\n  // console.log(\"######################################################################\")\r\n\r\n  return { opt: typedOptions, program };\r\n};\r\n\r\nconst fixStringArrayArgument = (value: string | string[] | undefined, skipEmptyItem: boolean = true) => {\r\n  if (!value) {\r\n    return [];\r\n  }\r\n\r\n  if (typeof value === 'string') {\r\n    const result: string[] = [];\r\n    const arr = value.split(',');\r\n    arr.forEach((value) => {\r\n      const trimedValue = value.trim();\r\n      if (skipEmptyItem) {\r\n        if (trimedValue.length > 0) {\r\n          result.push(trimedValue);\r\n        }\r\n      } else {\r\n        result.push(trimedValue);\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  return [];\r\n};\r\n","{\r\n  \"name\": \"useful-tasks\",\r\n  \"version\": \"0.3.0\",\r\n  \"description\": \"A CLI task runner that utilizes JSON-based configuration and processes tasks sequentially\",\r\n  \"author\": {\r\n    \"name\": \"Jinho Yun\",\r\n    \"email\": \"owlflyx12@gmail.com\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"https://github.com/luxmargos/useful-tasks.git\"\r\n  },\r\n  \"type\": \"commonjs\",\r\n  \"engines\": {},\r\n  \"main\": \"./dist/index.js\",\r\n  \"module\": \"./dist/index.mjs\",\r\n  \"entryPoint\": \"dist/index.js\",\r\n  \"bin\": {\r\n    \"useful-tasks\": \"dist/index.js\"\r\n  },\r\n  \"exports\": {\r\n    \".\": {\r\n      \"require\": \"./dist/index.js\",\r\n      \"import\": \"./dist/index.mjs\"\r\n    }\r\n  },\r\n  \"files\": [\r\n    \"LICENSE\",\r\n    \"README.md\",\r\n    \"dist/**\"\r\n  ],\r\n  \"license\": \"MIT\",\r\n  \"keywords\": [\r\n    \"cli\",\r\n    \"terminal\",\r\n    \"task\",\r\n    \"fs\",\r\n    \"git\",\r\n    \"symlink\",\r\n    \"regex\",\r\n    \"batch\",\r\n    \"node-js\",\r\n    \"javascript\",\r\n    \"typescript\",\r\n    \"dependency\",\r\n    \"command\"\r\n  ],\r\n  \"scripts\": {\r\n    \"start\": \"npm run build && node dist/index.js\",\r\n    \"start:ts\": \"tsx src/index.ts\",\r\n    \"build\": \"tsup\",\r\n    \"watch\": \"tsup --watch\",\r\n    \"prepare\": \"husky && npm run build\",\r\n    \"print_help\": \"tsx src/index.ts --help\",\r\n    \"test\": \"jest\",\r\n    \"test:all\": \"npm run test:fs && npm run test:fs2 && npm run test:vars && npm run test:vars_parsers && npm run test:exclude && npm run test:include && npm run test:exclude_include && npm run test:exclude_tag && npm run test:include_tag && npm run test:exclude_include_tag && npm run test:outputs && npm run test:custom_regex && npm run test:sub_tasks && npm run test:fs_cp_filter && npm run test:fs_del_filter\",\r\n    \"test:fs\": \"tsx src/index.ts --cwd=./test --config=test_fs.json\",\r\n    \"test:fs2\": \"tsx src/index.ts --cwd=./test --config=test_fs2.json\",\r\n    \"test:fs_cp_filter\": \"tsx src/index.ts --cwd=./test --config=test_fs_copy_filter.json\",\r\n    \"test:fs_del_filter\": \"tsx src/index.ts --cwd=./test --config=test_fs_del_filter.json\",\r\n    \"test:fs_mkdir\": \"tsx src/index.ts --cwd=./test --config=test_fs_mkdir.json\",\r\n    \"test:fs_mkdir_error\": \"tsx src/index.ts --cwd=./test --config=test_fs_mkdir_error.json\",\r\n    \"test:vars\": \"tsx src/index.ts --cwd=./test --config=test_vars.json\",\r\n    \"test:vars_parsers\": \"tsx src/index.ts --cwd=./test --config=test_vars_parsers.json\",\r\n    \"test:exclude\": \"tsx src/index.ts --cwd=./test --config=test_outputs.json --exclude=task-1,task-3\",\r\n    \"test:include\": \"tsx src/index.ts --cwd=./test --config=test_outputs.json --include=task-2\",\r\n    \"test:exclude_include\": \"tsx src/index.ts --cwd=./test --config=test_outputs.json --exclude=task-2 --include=task-2\",\r\n    \"test:exclude_tag\": \"tsx src/index.ts --cwd=./test --config=test_outputs.json --exclude=tag-a\",\r\n    \"test:include_tag\": \"tsx src/index.ts --cwd=./test --config=test_outputs.json --include=tag-a\",\r\n    \"test:exclude_include_tag\": \"tsx src/index.ts --cwd=./test --config=test_outputs.json --exclude=tag-a --include=tag-b\",\r\n    \"test:outputs\": \"tsx src/index.ts --cwd=./test --config=test_outputs.json\",\r\n    \"test:sub_tasks\": \"tsx src/index.ts --cwd=./test --config=test_sub_tasks.json\",\r\n    \"test:env_var\": \"tsx src/index.ts --cwd=./test --config=test_env_vars.json\"\r\n  },\r\n  \"dependencies\": {\r\n    \"commander\": \"^13.1.0\",\r\n    \"debug\": \"^4.4.0\",\r\n    \"es-toolkit\": \"^1.36.0\",\r\n    \"fs-extra\": \"^11.3.0\",\r\n    \"glob\": \"^11.0.1\",\r\n    \"json5\": \"^2.2.3\",\r\n    \"nanoid4\": \"npm:nanoid@^4.0.2\",\r\n    \"simple-git\": \"^3.18.0\",\r\n    \"string-argv\": \"^0.3.2\",\r\n    \"zod\": \"^3.24.3\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@types/debug\": \"^4.1.12\",\r\n    \"@types/fs-extra\": \"^11.0.4\",\r\n    \"@types/glob\": \"^8.1.0\",\r\n    \"@types/jest\": \"^29.5.14\",\r\n    \"husky\": \"^9.1.7\",\r\n    \"jest\": \"^29.7.0\",\r\n    \"nanoid3\": \"npm:nanoid@^3.3.11\",\r\n    \"ts-jest\": \"^29.3.1\",\r\n    \"tsup\": \"^8.4.0\",\r\n    \"tsx\": \"^4.19.3\",\r\n    \"typescript\": \"^5.8.2\"\r\n  }\r\n}\r\n","import path from 'path';\r\nimport { CWD_KEEP, LogLevel, Options, logLevels } from './build_cli_parser';\r\nimport { containsAllTag, containsTag, loadJsonConfig } from './utils';\r\nimport debug from 'debug';\r\nimport os from 'os';\r\nimport {\r\n  TasksConfig,\r\n  TAG_DEBUG,\r\n  Task,\r\n  TaskContext,\r\n  VAR_FROM_ARGUMENT_PREFIX,\r\n  ENV_VAR_FROM_ARGUMENT_PREFIX,\r\n  TAG_INFO,\r\n  TAG_WARN,\r\n  TasksConfigInput,\r\n  TasksConfigSchema,\r\n  convertToRuntimeTask,\r\n  RuntimeTask,\r\n  AnyRuntimeTask,\r\n} from './task_data';\r\nimport { replaceVarLiterals, searchExtraKeyValue, setTaskVar, setEnvVar } from './task_utils';\r\nimport { Command } from 'commander';\r\nimport { handlerMap } from './handler_map';\r\nimport { logi, logv, logw } from './loggers';\r\nimport { isNil, isNotNil } from 'es-toolkit';\r\n\r\nexport const usefulTasks = async (\r\n  originCwd: string,\r\n  opts: Options,\r\n  tasksConfigInput: TasksConfigInput,\r\n  program: Command\r\n) => {\r\n  const tasksConfig: TasksConfig = TasksConfigSchema.parse(tasksConfigInput);\r\n\r\n  // cli argument can overwrite json's cwdMode\r\n  const cwdModeIsKeep = opts.cwdMode ? opts.cwdMode === CWD_KEEP : tasksConfig.env.cwdMode === CWD_KEEP;\r\n\r\n  let debugPat: string | undefined;\r\n  let logLevel: LogLevel = tasksConfig.env.logLevel;\r\n\r\n  const varReplaceRegex = tasksConfig.env.varReplaceRegex;\r\n  const envReplaceRegex = tasksConfig.env.envReplaceRegex;\r\n\r\n  //cli argument can overwrite json's logLeve\r\n  if (opts.logLevel && logLevels.includes(opts.logLevel)) {\r\n    logLevel = opts.logLevel;\r\n  }\r\n\r\n  if (logLevel === 'debug') {\r\n    // debugPat = `${LOG_TAG}:*`;\r\n    debugPat = `${TAG_WARN},${TAG_INFO},${TAG_DEBUG}`;\r\n    debugPat = `${debugPat},simple-git,simple-git:*`;\r\n  } else if (logLevel === 'info') {\r\n    debugPat = `${TAG_WARN},${TAG_INFO}`;\r\n  }\r\n\r\n  if (debugPat) {\r\n    debug.enable(debugPat);\r\n  }\r\n\r\n  logv(`CLI Options`, opts);\r\n\r\n  const baseCwd = path.resolve(process.cwd());\r\n\r\n  const context: TaskContext = {\r\n    os: {\r\n      platform: process.platform,\r\n      architecture: process.arch,\r\n      machine: os.machine(),\r\n    },\r\n\r\n    originCwd,\r\n    baseCwd,\r\n    varReplaceRegex: new RegExp(varReplaceRegex),\r\n    envVarReplaceRegex: new RegExp(envReplaceRegex),\r\n    systemVars: {\r\n      __env: {\r\n        cwd_startup: originCwd,\r\n        cwd_base: baseCwd,\r\n      },\r\n    },\r\n    vars: {},\r\n    opts,\r\n    program,\r\n  };\r\n\r\n  if (opts.extraArgs) {\r\n    logv('Setting up the variables from the additional arguments');\r\n    searchExtraKeyValue(opts.extraArgs, VAR_FROM_ARGUMENT_PREFIX, opts.camelKeys, (key: string, value: string) => {\r\n      setTaskVar(context, key, value, false);\r\n    });\r\n\r\n    logv('Setting up the environment variables from the additional arguments');\r\n    searchExtraKeyValue(opts.extraArgs, ENV_VAR_FROM_ARGUMENT_PREFIX, opts.camelKeys, (key: string, value: string) => {\r\n      setEnvVar(context, key, value, false);\r\n    });\r\n  }\r\n\r\n  logi('');\r\n  logi(`[${tasksConfig.name}] Start task processing`);\r\n\r\n  const getTaskRepresentStr = (task: Task, i?: number) => {\r\n    if (i !== undefined && i !== null) {\r\n      return task.id !== undefined ? `[${i}]${task.id}/${task.type}` : `[${i}]${task.type}`;\r\n    } else {\r\n      return task.id !== undefined ? `${task.id}/${task.type}` : `${task.type}`;\r\n    }\r\n  };\r\n\r\n  const runTasks = async () => {\r\n    let tasks: AnyRuntimeTask[] = (tasksConfig.tasks ?? []).map(convertToRuntimeTask);\r\n\r\n    for (let i = 0; i < tasks.length; i++) {\r\n      const task = tasks[i];\r\n\r\n      // Validate task IDs\r\n      if (isNotNil(task.id)) {\r\n        for (let j = i + 1; j < tasks.length; j++) {\r\n          const otherTask = tasks[j];\r\n          if (otherTask.id !== undefined && otherTask.id === task.id) {\r\n            throw new Error(`The task id '${task.id}' must be unique`);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!task.type || !(task.type in handlerMap)) {\r\n        throw new Error(`Found the invalid task type '${task.type}'`);\r\n      }\r\n\r\n      if (task.id) task.__compare__elements.push(task.id);\r\n      if (task.tags) task.__compare__elements.push(...task.tags);\r\n    }\r\n\r\n    if (opts.exclude && opts.exclude.length > 0) {\r\n      const excludeItems = opts.exclude;\r\n\r\n      logv(`Excluding tasks by specified IDs or Tags : --exclude=${excludeItems}`);\r\n      tasks = tasks.filter((taskItem: AnyRuntimeTask) => {\r\n        if (containsTag(excludeItems, taskItem.__compare__elements) === false) {\r\n          return taskItem;\r\n        }\r\n      });\r\n    }\r\n\r\n    tasks = tasks.filter((taskItem: AnyRuntimeTask) => {\r\n      if (isNil(taskItem.when)) return true;\r\n\r\n      const { platform, architecture, machine } = taskItem.when;\r\n      if (isNotNil(platform)) {\r\n        if (platform.startsWith('!')) {\r\n          if (platform.substring(1) === context.os.platform) {\r\n            return false;\r\n          }\r\n        } else {\r\n          if (platform !== context.os.platform) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      if (isNotNil(architecture)) {\r\n        if (architecture.startsWith('!')) {\r\n          if (architecture.substring(1) === context.os.architecture) {\r\n            return false;\r\n          }\r\n        } else {\r\n          if (architecture !== context.os.architecture) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      if (isNotNil(machine)) {\r\n        if (machine.startsWith('!')) {\r\n          if (machine.substring(1) === context.os.machine) {\r\n            return false;\r\n          }\r\n        } else {\r\n          if (machine !== context.os.machine) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    });\r\n\r\n    if (opts.excludeCta && opts.excludeCta.length > 0) {\r\n      const excludesItems = opts.excludeCta;\r\n      logv(`Excluding tasks by specified IDs or Tags : --exclude-cta=${excludesItems}`);\r\n      tasks = tasks.filter((taskItem: AnyRuntimeTask) => {\r\n        if (containsAllTag(excludesItems, taskItem.__compare__elements) === false) {\r\n          return taskItem;\r\n        }\r\n      });\r\n    }\r\n    const hasIncludeFilters = opts.include && opts.include.length > 0;\r\n    const hasIncludeCTAFilters = opts.includeCta && opts.includeCta.length > 0;\r\n    if (hasIncludeFilters || hasIncludeCTAFilters) {\r\n      const includeItems = opts.include;\r\n      const includeCtaItems = opts.includeCta;\r\n\r\n      logv(`Including tasks by specified IDs or Tags : --include=${includeItems} / --include-cta=${includeCtaItems}`);\r\n      tasks = tasks.filter((taskItem: AnyRuntimeTask) => {\r\n        if (\r\n          (hasIncludeFilters && containsTag(includeItems!, taskItem.__compare__elements) === true) ||\r\n          (hasIncludeCTAFilters && containsAllTag(includeCtaItems!, taskItem.__compare__elements) === true)\r\n        ) {\r\n          return taskItem;\r\n        }\r\n      });\r\n    }\r\n\r\n    logi(\r\n      `Tasks : ${tasks.map((v, i) => {\r\n        return getTaskRepresentStr(v, i);\r\n      })}`\r\n    );\r\n\r\n    const taskCount = tasks.length ?? 0;\r\n    for (let i = 0; i < taskCount; i++) {\r\n      const task = tasks[i];\r\n      await replaceVarLiterals(context, task);\r\n\r\n      const taskRepresentStr = getTaskRepresentStr(task, i);\r\n      if (task.enabled === false) {\r\n        logi(`\\n### Skip the task without execution => ${taskRepresentStr}`);\r\n        continue;\r\n      } else {\r\n        logi(`\\n### Task : ${taskRepresentStr}`);\r\n      }\r\n\r\n      if (task.comment) {\r\n        logi(task.comment);\r\n      }\r\n\r\n      let cwdHasChanges = false;\r\n      if (task.cwd) {\r\n        const taskCwd = path.resolve(task.cwd);\r\n        logi(`Changing the current working directory => ${taskCwd}`);\r\n        cwdHasChanges = true;\r\n        process.chdir(taskCwd);\r\n      }\r\n\r\n      const taskHandler = handlerMap[task.type];\r\n      try {\r\n        await taskHandler(context, task);\r\n      } catch (e) {\r\n        if (task.onError === 'skip') {\r\n          logv(`Skip the failed task => ${taskRepresentStr}`, e);\r\n        } else if (task.onError === 'warn') {\r\n          logw(`Warn about the failed task => ${taskRepresentStr}`, e);\r\n        } else {\r\n          throw e;\r\n        }\r\n      }\r\n\r\n      if (!cwdModeIsKeep) {\r\n        if (cwdHasChanges) {\r\n          logi(`Restoring the current working directory => ${baseCwd}`);\r\n        }\r\n        process.chdir(baseCwd);\r\n      }\r\n    }\r\n  };\r\n\r\n  let hasError = false;\r\n  let error: unknown;\r\n  try {\r\n    await runTasks();\r\n  } catch (e) {\r\n    hasError = true;\r\n    error = e;\r\n  }\r\n\r\n  if (hasError) {\r\n    throw error;\r\n  } else {\r\n    process.chdir(baseCwd);\r\n    logi(`[${tasksConfig.name}] Tasks done\\n`);\r\n  }\r\n};\r\n\r\nexport const initUsefulTasks = (originCwd: string, opts: Options, program: Command) => {\r\n  let tasksConfigInput: TasksConfigInput = {};\r\n\r\n  let configFilePath = path.resolve(opts.config);\r\n  try {\r\n    tasksConfigInput = loadJsonConfig(configFilePath);\r\n  } catch (e: any) {\r\n    if (e instanceof Error) {\r\n      console.log(e.message);\r\n    } else {\r\n      console.log(e);\r\n    }\r\n    console.log('');\r\n    program.help();\r\n  }\r\n\r\n  return usefulTasks(originCwd, opts, tasksConfigInput, program);\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\nimport json5 from 'json5';\r\nimport { Task, type TasksConfigInput } from 'task_data';\r\nimport { logw, logv } from './loggers';\r\nimport { assignIn } from 'es-toolkit/compat';\r\n\r\nexport const loadFileOrThrow = (filePath: string) => {\r\n  logv(`Loading file: ${filePath}`);\r\n  if (!fs.existsSync(filePath)) {\r\n    throw new Error(`ERROR: The Path '${filePath}' does not exists!`);\r\n  }\r\n\r\n  return fs.readFileSync(filePath, { encoding: 'utf-8' });\r\n};\r\n\r\nexport const loadJson = (filePath: string) => {\r\n  return parseJson(loadFileOrThrow(filePath));\r\n};\r\n\r\nexport const parseJson = (content: string) => json5.parse(content);\r\n\r\nexport const loadJsonConfig = (filePath: string): TasksConfigInput => {\r\n  let configJson = loadJson(filePath);\r\n  if (configJson.extends) {\r\n    const filePathDir = path.dirname(filePath);\r\n    const extendsFilePath = path.resolve(filePathDir, configJson.extends);\r\n    configJson = assignIn({}, configJson, loadJsonConfig(extendsFilePath));\r\n  }\r\n\r\n  return configJson;\r\n};\r\n\r\nexport const convertOrNotHyphenTextToCamelText = (text: string, flag: boolean) => {\r\n  if (!flag) {\r\n    return text;\r\n  }\r\n\r\n  let result = '';\r\n  let textArr = text.split('-');\r\n  for (let i = 0; i < textArr.length; i++) {\r\n    let word = textArr[i];\r\n    if (i === 0) {\r\n      result = word;\r\n    } else {\r\n      if (word.length > 0) {\r\n        word = `${word[0].toUpperCase()}${word.substring(1)}`;\r\n      }\r\n      result = `${result}${word}`;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nexport const containsTag = (elements: string[], tags?: string[]) => {\r\n  if (elements.length < 1) {\r\n    return false;\r\n  }\r\n\r\n  for (const el of elements) {\r\n    if (tags) {\r\n      for (const tag of tags) {\r\n        if (el === tag) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const containsAllTag = (elements: string[], tags?: string[]) => {\r\n  if (elements.length < 1) {\r\n    return false;\r\n  }\r\n  for (const el of elements) {\r\n    let contained = false;\r\n    if (tags) {\r\n      for (const tag of tags) {\r\n        if (tag === el) {\r\n          contained = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!contained) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nexport const checkEmptyStringOrThrow = (name: string, value: string) => {\r\n  if (!value) {\r\n    throw new Error(`The '${name}' property must not be empty.`);\r\n  }\r\n};\r\n\r\nexport const checkLegacyUsage = (task: Task, key: string) => {\r\n  if ((task as any)[key] !== undefined) logw(`The key '${key}' has been deprecated.`);\r\n};\r\n\r\ntype TypeString = 'string' | 'number' | 'boolean' | 'undefined' | 'object' | 'function' | 'bigint' | 'symbol';\r\nexport const checkType = (value: any, allowedTypes: TypeString[]): boolean => {\r\n  if (allowedTypes.length <= 0) return true;\r\n  return allowedTypes.includes(typeof value);\r\n};\r\n\r\nexport const checkTypeOrThrow = (name: string, value: any, allowedTypes: TypeString[]): boolean => {\r\n  if (checkType(value, allowedTypes)) {\r\n    return true;\r\n  }\r\n\r\n  const valueType = typeof value;\r\n  throw new Error(\r\n    `The '${name}' property has an invalid type '${valueType}' with the value '${value}'. The allowed types are [${allowedTypes}].`\r\n  );\r\n};\r\n\r\nconst ENV_LINE =\r\n  /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/gm;\r\n\r\n/**  Parse src into an Object */\r\nexport function parseLines(src: string) {\r\n  const obj: any = {};\r\n\r\n  // Convert buffer to string\r\n  let lines = src.toString();\r\n\r\n  // Convert line breaks to same format\r\n  lines = lines.replace(/\\r\\n?/gm, '\\n');\r\n\r\n  let match: RegExpExecArray | null;\r\n  while ((match = ENV_LINE.exec(lines)) != null) {\r\n    const key = match[1];\r\n    // Default undefined or null to empty string\r\n    let value = match[2] || '';\r\n    // Remove whitespace\r\n    value = value.trim();\r\n    // Check if double quoted\r\n    const maybeQuote = value[0];\r\n    // Remove surrounding quotes\r\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/gm, '$2');\r\n    // Expand newlines if double quoted\r\n    if (maybeQuote === '\"') {\r\n      value = value.replace(/\\\\n/g, '\\n');\r\n      value = value.replace(/\\\\r/g, '\\r');\r\n    }\r\n\r\n    // Add to object\r\n    obj[key] = value;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nexport const throwInvalidParamError = <T, K extends keyof T>(obj: T, key: K) => {\r\n  throw new Error(`The parameter '${String(key)}' has an invalid value ${obj[key]}`);\r\n};\r\n\r\nexport const resolveStringArray = (val: string | string[] | undefined | null, defaultValue: string[]): string[] => {\r\n  if (val !== undefined && val !== null) {\r\n    if (typeof val === 'string') {\r\n      return [val];\r\n    } else if (Array.isArray(val)) {\r\n      return val.filter((v) => typeof v === 'string');\r\n    }\r\n  }\r\n\r\n  return defaultValue;\r\n};\r\n","import debug from \"debug\";\r\nimport { TAG_DEBUG, TAG_INFO, TAG_WARN } from \"./task_data\";\r\n\r\nexport const logw = debug(TAG_WARN);\r\nexport const logi = debug(TAG_INFO);\r\nexport const logv = debug(TAG_DEBUG);\r\n","import { Command } from 'commander';\r\nimport { CWD_KEEP, CWD_RESTORE, logLevels, Options } from './build_cli_parser';\r\nimport { string, z, ZodObject, ZodRawShape } from 'zod';\r\nimport os from 'os';\r\nimport { Runtime } from 'inspector';\r\n\r\n/** e.g. ${value.key} */\r\nexport const DEFAULT_REPLACE_REGEX = '\\\\$\\\\{([a-zA-Z0-9\\\\.\\\\-_]*)\\\\}';\r\n\r\ntype TaskHandler<T> = (context: TaskContext, task: T) => Promise<void>;\r\n\r\nconst newTaskSchema = <T, Type extends TaskType>(type: Type, obj: T) => {\r\n  return TaskBaseSchema.extend({\r\n    type: z.literal(type),\r\n    ...obj,\r\n  });\r\n};\r\n\r\nexport const GlobFilterSchema = z.union([z.string().nonempty(), z.array(z.string().nonempty())]).optional();\r\nexport const GlobFiltersSchema = z.object({\r\n  include: GlobFilterSchema,\r\n  exclude: GlobFilterSchema,\r\n});\r\n\r\nconst newTaskSchemaWithGlobFilters = <T, Type extends TaskType>(type: Type, obj: T) => {\r\n  return TaskBaseSchema.extend({\r\n    type: z.literal(type),\r\n    ...obj,\r\n    include: GlobFilterSchema,\r\n    exclude: GlobFilterSchema,\r\n  });\r\n};\r\n\r\nexport const convertToRuntimeTask = <T extends Task>(task: T): RuntimeTask<T> => {\r\n  return {\r\n    ...task,\r\n    __compare__elements: [],\r\n  };\r\n};\r\n\r\n/** NOTE: Future feature implementation */\r\nconst setHandler = <T extends ZodObject<ZodRawShape>, O extends z.infer<T>>(\r\n  originSchema: T,\r\n  handler: TaskHandler<O>\r\n) => {\r\n  const handlerSchema = z.custom<TaskHandler<O>>().default(handler);\r\n  return originSchema.extend({\r\n    handler: handlerSchema,\r\n  });\r\n};\r\n\r\nexport interface TaskContext {\r\n  os: {\r\n    platform: NodeJS.Platform;\r\n    architecture: NodeJS.Architecture;\r\n    machine: string;\r\n  };\r\n\r\n  originCwd: string;\r\n  baseCwd: string;\r\n\r\n  /** The regex to replace variable literal */\r\n  varReplaceRegex: RegExp;\r\n  /** The regex to replace environment variable literal */\r\n  envVarReplaceRegex: RegExp;\r\n\r\n  /** The system variables used by the tasks */\r\n  systemVars: {\r\n    __env: {\r\n      cwd_startup: string;\r\n      cwd_base: string;\r\n    };\r\n  };\r\n\r\n  /** The shared object to store variable values */\r\n  vars: {\r\n    [key: string]: any;\r\n  };\r\n\r\n  opts: Options;\r\n  program: Command;\r\n}\r\n\r\nexport const TaskTypeSchema = z.union([\r\n  z.literal('git-setup'),\r\n  z.literal('cmd'),\r\n  z.literal('set-var'),\r\n  z.literal('output'),\r\n  z.literal('symlink'),\r\n  z.literal('fs-copy'),\r\n  z.literal('fs-del'),\r\n  z.literal('fs-mkdir'),\r\n  z.literal('env-var'),\r\n  z.literal('sub-tasks'),\r\n  z.literal('content-replace'),\r\n]);\r\n\r\nexport type TaskType = z.infer<typeof TaskTypeSchema>;\r\n\r\n/** {@link NodeJS.Platform} */\r\nconst BasePlatforms = [\r\n  'aix',\r\n  'android',\r\n  'darwin',\r\n  'freebsd',\r\n  'haiku',\r\n  'linux',\r\n  'openbsd',\r\n  'sunos',\r\n  'win32',\r\n  'cygwin',\r\n  'netbsd',\r\n] as const;\r\nconst Platforms = [...BasePlatforms, ...BasePlatforms.map((item) => `!${item}`)] as const;\r\ntype Platform = (typeof Platforms)[number];\r\n\r\n/** {@link NodeJS.Architecture} */\r\nconst BaseArchitectures = ['arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x64'] as const;\r\nconst Architectures = [...BaseArchitectures, ...BaseArchitectures.map((item) => `!${item}`)] as const;\r\ntype Architecture = (typeof Architectures)[number];\r\n\r\n/** {@link NodeJS.Machine} */\r\nconst BaseMachines = [\r\n  'arm',\r\n  'arm64',\r\n  'aarch64',\r\n  'mips',\r\n  'mips64',\r\n  'ppc64',\r\n  'ppc64le',\r\n  's390',\r\n  's390x',\r\n  'i386',\r\n  'i686',\r\n  'x86_64',\r\n] as const;\r\nconst Machines = [...BaseMachines, ...BaseMachines.map((item) => `!${item}`)] as const;\r\ntype Machine = (typeof Machines)[number];\r\n\r\nos.machine();\r\n\r\nexport const TaskWhenSchema = z.object({\r\n  platform: z.custom<Platform>().optional(),\r\n  architecture: z.custom<Architecture>().optional(),\r\n  machine: z.custom<Machine>().optional(),\r\n});\r\n\r\nexport const TaskBaseSchema = z.object({\r\n  type: TaskTypeSchema,\r\n  id: z.string().trim().nonempty().optional(),\r\n  tags: z\r\n    .union([z.string().trim().nonempty(), z.array(z.string().trim().nonempty())])\r\n    .optional()\r\n    .transform((value) => {\r\n      if (!value) return [];\r\n      if (typeof value === 'string') return [value];\r\n      return value;\r\n    }),\r\n  cwd: z.string().nonempty().optional(),\r\n  enabled: z.boolean().default(true),\r\n  when: TaskWhenSchema.optional(),\r\n  comment: z.string().optional(),\r\n  onError: z.union([z.literal('skip'), z.literal('throw'), z.literal('warn')]).default('throw'),\r\n});\r\n\r\nexport type TaskBase = z.infer<typeof TaskBaseSchema>;\r\nexport type GlobFilters = z.infer<typeof GlobFiltersSchema>;\r\n\r\nexport const TaskGitSetupSchema = newTaskSchema('git-setup', {\r\n  localPath: z.string().nonempty(),\r\n  /** Executable git binary */\r\n  binary: z.string().nonempty().optional(),\r\n  url: z.string().nonempty().optional(),\r\n  branch: z.string().nonempty().optional(),\r\n  startPoint: z.string().nonempty().optional(),\r\n  updateSubmodules: z.union([z.string().nonempty(), z.string().nonempty(), z.boolean()]).optional(),\r\n});\r\nexport type TaskGitSetup = z.infer<typeof TaskGitSetupSchema>;\r\n\r\nexport const TaskSymlinkSchema = newTaskSchema('symlink', {\r\n  type: z.literal('symlink'),\r\n  target: z.string().nonempty(),\r\n  path: z.string().nonempty(),\r\n  linkType: z.union([z.literal('dir'), z.literal('file'), z.literal('junction')]).optional(),\r\n  forced: z.boolean().optional(),\r\n});\r\nexport type TaskSymlink = z.infer<typeof TaskSymlinkSchema>;\r\n\r\nexport const TaskTerminalCommandSchema = newTaskSchema('cmd', { cmd: z.string(), shell: z.string().optional() });\r\nexport type TaskTerminalCommand = z.infer<typeof TaskTerminalCommandSchema>;\r\n\r\nexport const TaskSetVarSchema = newTaskSchemaWithGlobFilters('set-var', {\r\n  key: z.string().nonempty(),\r\n  value: z.union([z.string(), z.number(), z.boolean(), z.any()]),\r\n  src: z.string().nonempty().optional(),\r\n  parser: z.union([z.literal('json'), z.literal('lines'), z.literal('string'), z.literal('auto')]).optional(),\r\n  /** If the variable already exists, assigning will be skipped */\r\n  isFallback: z.boolean().optional().describe('If the variable already exists, assigning will be skipped'),\r\n});\r\nexport type TaskSetVar = z.infer<typeof TaskSetVarSchema>;\r\n\r\nexport const TaskEnvVarSchema = newTaskSchemaWithGlobFilters('env-var', {\r\n  map: z.map(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),\r\n  src: z.string().nonempty().optional(),\r\n  parser: z.union([z.literal('json'), z.literal('lines'), z.literal('auto')]).default('auto'),\r\n  /** If the environment variable already exists, assigning will be skipped */\r\n  isFallback: z.boolean().optional().describe('If the environment variable already exists, assigning will be skipped'),\r\n});\r\nexport type TaskEnvVar = z.infer<typeof TaskEnvVarSchema>;\r\n\r\nexport const TaskOutputTargetsSchema = z.union([\r\n  z.literal('console').describe('Output to console'),\r\n  z.literal('file-write').describe('Output to file (overwriting)'),\r\n  z.literal('file-append').describe('Output to file (appending)'),\r\n  z.literal('c').describe('Output to console'),\r\n  z.literal('fw').describe('Output to file (overwriting)'),\r\n  z.literal('fa').describe('Output to file (appending)'),\r\n]);\r\n\r\nexport type TaskOutputTargets = z.infer<typeof TaskOutputTargetsSchema>;\r\n\r\nexport const TaskOutputSchema = newTaskSchema('output', {\r\n  target: TaskOutputTargetsSchema,\r\n  text: z.string(),\r\n  path: z.string().nonempty().optional(),\r\n});\r\nexport type TaskOutput = z.infer<typeof TaskOutputSchema>;\r\n\r\nexport const TaskFsCopyOptionsSchema = z.object({\r\n  conflict: z\r\n    .union([\r\n      z.literal('overwrite'),\r\n      z.literal('skip'),\r\n      /**\r\n       * @reserved - feature in future:\r\n       * z.literal('prompt')*/\r\n    ])\r\n    .default('overwrite'),\r\n});\r\nexport type TaskFsCopyOptions = z.infer<typeof TaskFsCopyOptionsSchema>;\r\n\r\nexport const TaskFsCopySchema = newTaskSchemaWithGlobFilters('fs-copy', {\r\n  src: z.string().nonempty(),\r\n  dest: z.string().nonempty(),\r\n  options: TaskFsCopyOptionsSchema.default({ conflict: 'overwrite' }),\r\n});\r\nexport type TaskFsCopy = z.infer<typeof TaskFsCopySchema>;\r\n\r\nexport const TaskFsDeleteSchema = newTaskSchemaWithGlobFilters('fs-del', {\r\n  path: z.string().nonempty(),\r\n});\r\nexport type TaskFsDelete = z.infer<typeof TaskFsDeleteSchema>;\r\n\r\nexport const TaskFsMakeDirSchema = newTaskSchema('fs-mkdir', {\r\n  path: z.string().nonempty(),\r\n});\r\nexport type TaskFsMakeDir = z.infer<typeof TaskFsMakeDirSchema>;\r\n\r\nexport const TaskSubTasksSchema = newTaskSchema('sub-tasks', {\r\n  args: z.string().optional(),\r\n  inherits: z\r\n    .object({ args: z.boolean().default(true), vars: z.boolean().default(true) })\r\n    .optional()\r\n    .describe('Whether to inherit args and vars from the parent task.'),\r\n});\r\nexport type TaskSubTasks = z.infer<typeof TaskSubTasksSchema>;\r\n\r\nexport const RegexDataSchema = z.object({ pattern: z.string(), flags: z.string().optional() });\r\nexport const TaskContentFindSchema = z.union([z.string().nonempty(), RegexDataSchema]);\r\nexport type RegexData = z.infer<typeof RegexDataSchema>;\r\n\r\nexport const TaskContentReplaceSchema = newTaskSchemaWithGlobFilters('content-replace', {\r\n  path: z\r\n    .string()\r\n    .nonempty()\r\n    .describe(\r\n      `If the task includes 'include' or 'exclude', \\\r\n      it will be handled as a directory. \r\n      Otherwise, it will be processed as a file.`\r\n    ),\r\n  find: TaskContentFindSchema,\r\n  replace: z.string(),\r\n  loop: z.number().optional(),\r\n});\r\nexport type TaskContentReplace = z.infer<typeof TaskContentReplaceSchema>;\r\n\r\nexport const TaskSchema = z.union([\r\n  TaskGitSetupSchema,\r\n  TaskTerminalCommandSchema,\r\n  TaskSetVarSchema,\r\n  TaskEnvVarSchema,\r\n  TaskOutputSchema,\r\n  TaskFsCopySchema,\r\n  TaskFsDeleteSchema,\r\n  TaskFsMakeDirSchema,\r\n  TaskSymlinkSchema,\r\n  TaskSubTasksSchema,\r\n  TaskContentReplaceSchema,\r\n]);\r\nexport type Task = z.infer<typeof TaskSchema>;\r\nexport type RuntimeTask<T extends Task> = T & {\r\n  __compare__elements: string[];\r\n};\r\nexport type AnyRuntimeTask = RuntimeTask<Task>;\r\n\r\nexport type TaskInput = z.input<typeof TaskSchema>;\r\n\r\nexport const TasksConfigSchema = z.object({\r\n  /** The name of the tasks file */\r\n  name: z.string().optional(),\r\n  env: z\r\n    .object({\r\n      /** The specific log level for the tasks */\r\n      logLevel: z.enum(logLevels).default('info'),\r\n\r\n      /** The regex to replace text with variable values */\r\n      varReplaceRegex: z\r\n        .string()\r\n        .nonempty()\r\n        .default(DEFAULT_REPLACE_REGEX)\r\n        .describe('The regex to replace text with variable values')\r\n        .refine((value) => value.indexOf('(') >= 0 && value.indexOf(')') >= 0, {\r\n          message: `The Regex must contains regex group express '(' and ')'`,\r\n        }),\r\n\r\n      /** The regex to replace text with environment variable values */\r\n      envReplaceRegex: z\r\n        .string()\r\n        .nonempty()\r\n        .default(DEFAULT_REPLACE_REGEX)\r\n        .describe('The regex to replace text with environment variable values')\r\n        .refine((value) => value.indexOf('(') >= 0 && value.indexOf(')') >= 0, {\r\n          message: `The Regex must contains regex group express '(' and ')'`,\r\n        }),\r\n\r\n      cwdMode: z.union([z.literal(CWD_RESTORE), z.literal(CWD_KEEP)]).default(CWD_RESTORE),\r\n    })\r\n    .default({ logLevel: 'info', varReplaceRegex: DEFAULT_REPLACE_REGEX, envReplaceRegex: DEFAULT_REPLACE_REGEX }),\r\n  tasks: z.array(TaskSchema).default([]),\r\n});\r\nexport type TasksConfig = z.infer<typeof TasksConfigSchema>;\r\nexport type TasksConfigInput = z.input<typeof TasksConfigSchema>;\r\n\r\nexport const LOG_TAG = 'useful-tasks';\r\nexport const TAG_DEBUG = `${LOG_TAG}:debug`;\r\nexport const TAG_INFO = `${LOG_TAG}:info`;\r\nexport const TAG_WARN = `${LOG_TAG}:warn`;\r\n\r\nexport const VAR_FROM_ARGUMENT_PREFIX = '--var-';\r\nexport const ENV_VAR_FROM_ARGUMENT_PREFIX = '--env-';\r\n","import { isNil } from 'es-toolkit';\r\nimport { logv, logw } from './loggers';\r\nimport { Task, TaskContext } from './task_data';\r\nimport { convertOrNotHyphenTextToCamelText, loadJson } from './utils';\r\nimport { get, isNotNil } from 'es-toolkit/compat';\r\n\r\nexport const replaceVarLiterals = async (context: TaskContext, task: Task) => {\r\n  const anyTypeTask: any = task as any;\r\n  for (const key of Object.keys(anyTypeTask)) {\r\n    if (typeof key !== 'string') {\r\n      continue;\r\n    }\r\n\r\n    if (key === 'id' || key === 'tags') {\r\n      continue;\r\n    }\r\n\r\n    if (anyTypeTask[key] !== undefined && typeof anyTypeTask[key] === 'string') {\r\n      let valueOfKey: string = anyTypeTask[key];\r\n      while (true) {\r\n        const envVarHandler = (value: string) => {\r\n          context.envVarReplaceRegex.lastIndex = 0;\r\n          const execArr = context.envVarReplaceRegex.exec(value);\r\n\r\n          const isMatched = isNotNil(execArr);\r\n          // example: ${var_name}, ${var_name.sub_name}, ${var_name[0]}\r\n          const matchedStr = execArr?.[0];\r\n          // example: var_name, var_name.sub_name, var_name[0]\r\n          const varPath = execArr?.[1];\r\n          const matchedVar = varPath ? get(process.env, varPath) : undefined;\r\n\r\n          const replaceText = () => {\r\n            const valuePrefix = value.substring(0, execArr!.index);\r\n            const valueReplace = `${matchedVar}`;\r\n            const valueSuffix = value.substring(execArr!.index + matchedStr!.length);\r\n            return `${valuePrefix}${valueReplace}${valueSuffix}`;\r\n          };\r\n          return {\r\n            isMatched,\r\n            matchedStr,\r\n            varPath,\r\n            matchedVar,\r\n            replaceText,\r\n          };\r\n        };\r\n\r\n        const varHandler = (value: string) => {\r\n          context.varReplaceRegex.lastIndex = 0;\r\n          const execArr = context.varReplaceRegex.exec(value);\r\n\r\n          const isMatched = isNotNil(execArr);\r\n          // example: ${var_name}, ${var_name.sub_name}, ${var_name[0]}\r\n          const matchedStr = execArr?.[0];\r\n          // example: var_name, var_name.sub_name, var_name[0]\r\n          const varPath = execArr?.[1];\r\n          const matchedVar = varPath ? get(context.systemVars, varPath) || get(context.vars, varPath) : undefined;\r\n\r\n          const replaceText = () => {\r\n            const valuePrefix = value.substring(0, execArr!.index);\r\n            const valueReplace = `${matchedVar}`;\r\n            const valueSuffix = value.substring(execArr!.index + matchedStr!.length);\r\n            return `${valuePrefix}${valueReplace}${valueSuffix}`;\r\n          };\r\n          return {\r\n            isMatched,\r\n            matchedStr,\r\n            varPath,\r\n            matchedVar,\r\n            replaceText,\r\n          };\r\n        };\r\n\r\n        const varHandlerResult = varHandler(valueOfKey);\r\n        const envVarHandlerResult = envVarHandler(valueOfKey);\r\n\r\n        if (varHandlerResult.isMatched) {\r\n          logv(`Variable injection: '${key}'=>'${valueOfKey}'`);\r\n          valueOfKey = varHandlerResult.replaceText();\r\n        } else if (envVarHandlerResult.isMatched) {\r\n          logv(`Variable injection: '${key}'=>'${valueOfKey}'`);\r\n          valueOfKey = envVarHandlerResult.replaceText();\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      anyTypeTask[key] = valueOfKey;\r\n    }\r\n  }\r\n};\r\n\r\nexport const searchExtraKeyValue = (\r\n  extraArgs: string[],\r\n  fmt: string,\r\n  convertToCamelKeys: boolean,\r\n  callback: (key: string, value: string) => void\r\n) => {\r\n  let currentVarName: string | undefined;\r\n  let useNextElementAsVar: boolean = false;\r\n\r\n  for (let extraArg of extraArgs) {\r\n    const arg = extraArg.trim();\r\n    if (arg === '--') {\r\n      logv(\"Stop parsing by '--'\");\r\n      break;\r\n    }\r\n\r\n    if (useNextElementAsVar && currentVarName) {\r\n      const value = extraArg.startsWith('-') ? '' : extraArg;\r\n      callback(currentVarName, value);\r\n      currentVarName = undefined;\r\n      useNextElementAsVar = false;\r\n    } else {\r\n      const prefixIndex = extraArg.indexOf(fmt);\r\n      if (prefixIndex >= 0) {\r\n        const equalMarkIndex = extraArg.indexOf('=');\r\n        if (equalMarkIndex >= 0) {\r\n          const varName = convertOrNotHyphenTextToCamelText(\r\n            extraArg.substring(fmt.length, equalMarkIndex),\r\n            convertToCamelKeys\r\n          );\r\n          const value = extraArg.substring(equalMarkIndex + 1);\r\n          callback(varName, value);\r\n        } else {\r\n          currentVarName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length), convertToCamelKeys);\r\n          useNextElementAsVar = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const setTaskVar = (context: TaskContext, key: string, value: any, skipForExists: boolean) => {\r\n  if (skipForExists && context.vars[key] !== undefined) {\r\n    logv(`Skips assigning the variable ${key}=${value} because it already exists.`);\r\n    return;\r\n  }\r\n\r\n  logv(`Sets the variable ${key}=${value}`);\r\n  context.vars[key] = value;\r\n};\r\n\r\nexport const setEnvVar = (context: TaskContext, key: string, value: any, skipForExists: boolean) => {\r\n  var valueType = typeof value;\r\n  if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') {\r\n    logv(`Ignoring the invalid typed(${valueType}) environment variable ${key}=${value}`);\r\n  } else {\r\n    const stringVal = String(value);\r\n    if (stringVal.length < 1) {\r\n      logv(`Ignoring the invalid environment variable ${key}=${value}`);\r\n    } else {\r\n      if (skipForExists && process.env[key] !== undefined) {\r\n        logv(`Skips assigning the environment variable ${key}=${value} because it already exists.`);\r\n        return;\r\n      }\r\n\r\n      logv(`Sets the environment variable ${key}=${value}`);\r\n      process.env[key] = String(value);\r\n    }\r\n  }\r\n};\r\n","import stringArgv from 'string-argv';\r\nimport { TaskContext, TaskSubTasks } from '../task_data';\r\nimport { initUsefulTasks } from '../useful_tasks';\r\nimport { setup } from '../build_cli_parser';\r\n\r\nexport const handleSubTasks = async (context: TaskContext, task: TaskSubTasks) => {\r\n  if (!task.args || typeof task.args !== 'string') {\r\n    throw new Error(`Found missing or invalid property 'args' that is required`);\r\n  }\r\n\r\n  const subArgv = stringArgv(task.args);\r\n  const setupResult = setup(subArgv);\r\n  initUsefulTasks(context.originCwd, setupResult.opt, setupResult.program);\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\nimport { TaskContext, TaskContentReplace, RegexData } from '../task_data';\r\nimport { logi, logv } from '../loggers';\r\nimport { processWithGlobSync } from '../glob_handler';\r\nimport { resolveStringArray, throwInvalidParamError } from '../utils';\r\n\r\nconst runFindAndReplaceWithRegex = (content: string, find: RegExp, replace: string, repeat: number): string => {\r\n  var text: string = content;\r\n  if (repeat < 1) {\r\n    while (find.test(text)) {\r\n      text = text.replace(find, replace);\r\n    }\r\n  } else {\r\n    for (var i = 0; i < repeat; i++) {\r\n      if (find.test(text)) {\r\n        text = text.replace(find, replace);\r\n      }\r\n    }\r\n  }\r\n  return text;\r\n};\r\n\r\nconst runFindAndReplaceWithText = (content: string, find: string, replace: string, repeat: number): string => {\r\n  var text: string = content;\r\n  if (repeat < 1) {\r\n    while (text.indexOf(find) >= 0) {\r\n      text = text.replace(find, replace);\r\n    }\r\n  } else {\r\n    for (var i = 0; i < repeat; i++) {\r\n      if (text.indexOf(find) >= 0) {\r\n        text = text.replace(find, replace);\r\n      }\r\n    }\r\n  }\r\n  return text;\r\n};\r\n\r\nconst isRegexData = (v: any) => {\r\n  if (v !== undefined && v !== null && typeof v === 'object' && 'pattern' in v && typeof v.pattern === 'string') {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n\r\ntype FindAndReplaceFunc = (content: string, find: any, replace: string, repeat: number) => string;\r\n\r\nconst findAndReplaceWithFile = (\r\n  path: string,\r\n  replaceFunc: FindAndReplaceFunc,\r\n  find: string | RegExp,\r\n  replace: string,\r\n  repeat: number\r\n) => {\r\n  logv(`Find and Replace: ${path}`);\r\n  const content: string = fs.readFileSync(path, 'utf-8');\r\n  const newContent = replaceFunc(content, find, replace, repeat);\r\n  fs.writeFileSync(path, newContent, 'utf-8');\r\n};\r\n\r\nexport const handleContentReplace = async (context: TaskContext, task: TaskContentReplace) => {\r\n  if (!fs.existsSync(task.path)) {\r\n    logv(`The '${task.path}' does not exist`);\r\n    return;\r\n  }\r\n\r\n  if (task.replace === undefined || typeof task.replace !== 'string') {\r\n    throwInvalidParamError(task, 'replace');\r\n  }\r\n\r\n  let loop: number = task.loop === undefined || task.loop === null ? 1 : task.loop;\r\n  if (typeof loop === 'string') {\r\n    loop = parseInt(loop, 10);\r\n  } else if (typeof loop !== 'number') {\r\n    throwInvalidParamError(task, 'loop');\r\n  }\r\n\r\n  let find: string | RegExp;\r\n  let replaceFunc: FindAndReplaceFunc;\r\n  if (isRegexData(task.find)) {\r\n    const regexData = task.find as RegexData;\r\n    find = new RegExp(regexData.pattern, regexData.flags);\r\n    replaceFunc = runFindAndReplaceWithRegex;\r\n  } else if (typeof task.find === 'string') {\r\n    find = task.find;\r\n    replaceFunc = runFindAndReplaceWithText;\r\n  } else {\r\n    throwInvalidParamError(task, 'find');\r\n    return;\r\n  }\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const itemPath: string = path.join(task.path, f);\r\n\r\n      if (fs.existsSync(itemPath) && fs.statSync(itemPath).isDirectory()) {\r\n        continue;\r\n      }\r\n\r\n      findAndReplaceWithFile(path.join(task.path, f), replaceFunc, find, task.replace, loop);\r\n    }\r\n  };\r\n\r\n  // ignore dirs, include all files on empty filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    task.path,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    true,\r\n    true\r\n  );\r\n\r\n  // expect it is a single file\r\n  if (!handled) {\r\n    findAndReplaceWithFile(task.path, replaceFunc, find, task.replace, loop);\r\n  }\r\n};\r\n","import fs from 'fs';\r\nimport { globSync } from 'glob';\r\n\r\n/**\r\n *\r\n * @param handler\r\n * @param cwd\r\n * @param includes\r\n * @param excludes\r\n * @param includeAllForNonFilter\r\n * @param subOptions\r\n * @returns true - filters are applied, false - there was no filter to apply\r\n */\r\nexport const processWithGlobSync = (\r\n  handler: (items: string[]) => void,\r\n  cwd: string,\r\n  includes: string[],\r\n  excludes: string[],\r\n  skipDirs: boolean,\r\n  includeAllIfNonFilters: boolean\r\n): boolean => {\r\n  if (fs.statSync(cwd).isDirectory() === false) {\r\n    return false;\r\n  }\r\n\r\n  //pre apply filter for faster performance\r\n  const nodir: boolean = skipDirs === true;\r\n\r\n  const hasIncludes: boolean = includes.length > 0;\r\n  const hasExcludes: boolean = excludes.length > 0;\r\n  if (!hasIncludes && hasExcludes) {\r\n    //include all to apply excludes\r\n    handler(globSync(['**'], { ignore: [...excludes], cwd, nodir }).filter((item) => item !== '.'));\r\n    return true;\r\n  } else if (hasIncludes && !hasExcludes) {\r\n    //apply includes only\r\n    handler(globSync(includes, { cwd, nodir }));\r\n    return true;\r\n  } else if (hasIncludes && hasExcludes) {\r\n    //apply include and exclude\r\n    handler(globSync(includes, { ignore: excludes, cwd, nodir }));\r\n    return true;\r\n  } else if (includeAllIfNonFilters) {\r\n    //include all to apply skipDirs, skipFiles\r\n    handler(globSync(['**'], { cwd, nodir }).filter((item) => item !== '.'));\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n","import { mkdirpSync } from 'fs-extra';\r\nimport { logv } from '@/loggers';\r\nimport { TaskContext, TaskFsMakeDir } from '@/task_data';\r\nimport { checkTypeOrThrow } from '@/utils';\r\n\r\nexport const handleMkdir = async (context: TaskContext, task: TaskFsMakeDir) => {\r\n  checkTypeOrThrow('path', task.path, ['string']);\r\n  logv(`Make a directory at : ${task.path}`);\r\n  mkdirpSync(task.path);\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\n// import { removeSync } from 'fs-extra';\r\nimport fse from 'fs-extra';\r\n\r\nimport { processWithGlobSync } from '@/glob_handler';\r\nimport { logv } from '@/loggers';\r\nimport { TaskContext, TaskFsDelete } from '@/task_data';\r\nimport { resolveStringArray } from '@/utils';\r\n\r\nexport const runDelete = (path: string) => {\r\n  logv(`Delete: ${path}`);\r\n  fse.removeSync(path);\r\n};\r\n\r\nexport const handleFsDelete = async (context: TaskContext, task: TaskFsDelete) => {\r\n  if (!fs.existsSync(task.path)) {\r\n    logv(`The '${task.path}' does not exist and cannot be deleted`);\r\n    return;\r\n  }\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      runDelete(path.join(task.path, f));\r\n    }\r\n  };\r\n\r\n  // allow dir with glob, do nothing withtout filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    task.path,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    false,\r\n    false\r\n  );\r\n\r\n  // delete the path is whatever\r\n  if (!handled) {\r\n    runDelete(task.path);\r\n  }\r\n};\r\n","import { processWithGlobSync } from '../glob_handler';\r\nimport path from 'path';\r\nimport { TaskContext, TaskFsCopy } from '../task_data';\r\nimport { logi, logv } from '../loggers';\r\nimport fse from 'fs-extra';\r\nimport { resolveStringArray } from '../utils';\r\n\r\nexport const runCopy = (src: string, dst: string, options: fse.CopyOptionsSync) => {\r\n  logv(`Copy: ${src} => ${dst}`);\r\n  fse.copySync(src, dst, options);\r\n};\r\n\r\nexport const handleFsCopy = async (context: TaskContext, task: TaskFsCopy) => {\r\n  if (!fse.existsSync(task.src)) {\r\n    throw new Error(`The source '${task.src}' does not exist`);\r\n  }\r\n\r\n  const conflict = task?.options?.conflict;\r\n  let overwrite =\r\n    conflict === undefined || conflict === null || (typeof conflict === 'string' && conflict.trim() === 'overwrite');\r\n\r\n  /** @deprecated support migrate from '0.1.18' */\r\n  if (task.options && 'overwrite' in task?.options && typeof task?.options?.overwrite === 'boolean') {\r\n    overwrite = task.options.overwrite;\r\n  }\r\n\r\n  const cpOpt: fse.CopyOptionsSync = { overwrite };\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const from = path.join(task.src, f);\r\n      const to = path.join(task.dest, f);\r\n      runCopy(from, to, cpOpt);\r\n    }\r\n  };\r\n\r\n  // allow dir with glob, do nothing withtout filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    task.src,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    false,\r\n    false\r\n  );\r\n\r\n  // copy the path is whatever\r\n  if (!handled) {\r\n    runCopy(task.src, task.dest, cpOpt);\r\n  }\r\n};\r\n","import fs from \"fs\";\r\nimport { mkdirpSync } from \"fs-extra\";\r\nimport path from \"path\";\r\nimport { TaskContext, TaskOutput, TaskOutputTargets } from \"task_data\";\r\n\r\nexport const handleOutput = async (context: TaskContext, task: TaskOutput) => {\r\n  const text = task.text ?? \"\";\r\n  const target: TaskOutputTargets = (task.target ?? \"c\").trim() as TaskOutputTargets;\r\n  const targetPath = task.path;\r\n\r\n  if (target === \"c\" || target === \"console\") {\r\n    console.log(text);\r\n  } else {\r\n    if (!targetPath) {\r\n      throw new Error(`The parameter 'path' is required for a target '${target}'!`);\r\n    }\r\n\r\n    const resolvedPath = path.resolve(targetPath);\r\n    const dir = path.dirname(resolvedPath);\r\n    if (!fs.existsSync(dir)) {\r\n      mkdirpSync(dir);\r\n    }\r\n\r\n    if (target == \"fa\" || target == \"file-append\") {\r\n      let err;\r\n      let fd;\r\n      try {\r\n        fd = fs.openSync(resolvedPath, \"a\");\r\n        fs.appendFileSync(fd, text, \"utf8\");\r\n      } catch (e) {\r\n        err = e;\r\n      } finally {\r\n        if (fd !== undefined) {\r\n          fs.closeSync(fd);\r\n        }\r\n      }\r\n\r\n      if (err) {\r\n        throw err;\r\n      }\r\n    } else {\r\n      fs.writeFileSync(resolvedPath, text);\r\n    }\r\n  }\r\n};\r\n","import fse from 'fs-extra';\r\nimport path from 'path';\r\nimport { processWithGlobSync } from '@/glob_handler';\r\nimport { logv } from '@/loggers';\r\nimport { TaskContext, TaskEnvVar } from '@/task_data';\r\nimport { setEnvVar } from '@/task_utils';\r\nimport {\r\n  checkLegacyUsage,\r\n  parseLines,\r\n  checkTypeOrThrow,\r\n  loadFileOrThrow,\r\n  parseJson,\r\n  resolveStringArray,\r\n} from '@/utils';\r\nimport { isNotNil } from 'es-toolkit';\r\nimport { isArray } from 'es-toolkit/compat';\r\n\r\nexport const handleEnvVar = async (context: TaskContext, task: TaskEnvVar) => {\r\n  checkLegacyUsage(task, 'var');\r\n  checkLegacyUsage(task, 'varType');\r\n  checkLegacyUsage(task, 'fileFormat');\r\n\r\n  if (task.isFallback !== true) {\r\n    task.isFallback = false;\r\n  }\r\n  const isFallback: boolean = task.isFallback;\r\n\r\n  if (isNotNil(task.map)) {\r\n    let map: any = task.map;\r\n    if (typeof map === 'string') {\r\n      logv('Trying to parse as lines.');\r\n      map = parseLines(map);\r\n    } else if (typeof map === 'object' || Array.isArray(map)) {\r\n      Object.keys(map).forEach((key) => {\r\n        setEnvVar(context, key, map[key], isFallback);\r\n      });\r\n    }\r\n  }\r\n\r\n  if (!task.src) return;\r\n\r\n  checkTypeOrThrow('src', task.src, ['string']);\r\n  const src = task.src as string;\r\n  const parser = task.parser || 'auto';\r\n  logv(`Parser = ${parser}`);\r\n\r\n  const runFunc = (filePath: string) => {\r\n    const varsPath = path.resolve(filePath);\r\n    let obj: Record<string, any> | undefined;\r\n    const content = loadFileOrThrow(varsPath);\r\n\r\n    if (parser === 'auto' || parser === 'json') {\r\n      try {\r\n        logv('Trying to parse as JSON.');\r\n        obj = parseJson(content);\r\n      } catch (e) {\r\n        if (parser === 'json') throw e;\r\n      }\r\n    }\r\n\r\n    if (!obj && (parser === 'auto' || parser === 'lines')) {\r\n      logv('Trying to parse as lines.');\r\n      obj = parseLines(content);\r\n    }\r\n\r\n    if (obj) {\r\n      const finalObj = obj;\r\n      Object.keys(finalObj).forEach((key) => {\r\n        setEnvVar(context, key, finalObj[key], isFallback);\r\n      });\r\n    }\r\n  };\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const itemPath: string = path.join(src, f);\r\n\r\n      if (fse.statSync(itemPath).isDirectory()) {\r\n        continue;\r\n      }\r\n      runFunc(itemPath);\r\n    }\r\n  };\r\n\r\n  // ignore dirs, include all files on empty filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    src,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    true,\r\n    true\r\n  );\r\n\r\n  // expect it is a single file\r\n  if (!handled) {\r\n    runFunc(src);\r\n  }\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\nimport { processWithGlobSync } from '@/glob_handler';\r\nimport { logv } from '@/loggers';\r\nimport { TaskContext, TaskSetVar } from '@/task_data';\r\nimport { setTaskVar } from '@/task_utils';\r\nimport {\r\n  checkLegacyUsage,\r\n  checkTypeOrThrow,\r\n  checkEmptyStringOrThrow,\r\n  loadFileOrThrow,\r\n  parseJson,\r\n  parseLines,\r\n  resolveStringArray,\r\n} from '@/utils';\r\n\r\nexport const handleSetVar = async (context: TaskContext, task: TaskSetVar) => {\r\n  checkLegacyUsage(task, 'var');\r\n  checkLegacyUsage(task, 'varType');\r\n  checkLegacyUsage(task, 'fileFormat');\r\n\r\n  checkTypeOrThrow('key', task.key, ['string']);\r\n  checkEmptyStringOrThrow('key', task.key);\r\n\r\n  if (task.isFallback !== true) {\r\n    task.isFallback = false;\r\n  }\r\n  const isFallback: boolean = task.isFallback;\r\n\r\n  if (task.value !== undefined) {\r\n    const value = task.value;\r\n    setTaskVar(context, task.key, value, isFallback);\r\n  }\r\n\r\n  if (!task.src) return;\r\n  checkTypeOrThrow('src', task.src, ['string']);\r\n\r\n  const src = task.src as string;\r\n  const parser = task.parser || 'auto';\r\n  logv(`Parser = ${parser}`);\r\n\r\n  const runFunc = (filePath: string) => {\r\n    const varsPath = path.resolve(filePath);\r\n    let obj: any | undefined;\r\n    const content = loadFileOrThrow(varsPath);\r\n\r\n    if (parser === 'auto' || parser === 'json') {\r\n      try {\r\n        logv('Trying to parse as JSON.');\r\n        obj = parseJson(content);\r\n      } catch (e) {\r\n        if (parser === 'json') throw e;\r\n      }\r\n    }\r\n\r\n    if (!obj && (parser === 'auto' || parser === 'lines')) {\r\n      logv('Trying to parse as lines.');\r\n      obj = parseLines(content);\r\n    }\r\n\r\n    if (!obj && (parser === 'auto' || parser === 'string')) {\r\n      obj = content;\r\n    }\r\n\r\n    setTaskVar(context, task.key, obj, isFallback);\r\n  };\r\n\r\n  const runGlobSync = (items: string[]) => {\r\n    for (const f of items) {\r\n      const itemPath: string = path.join(src, f);\r\n      if (fs.statSync(itemPath).isDirectory()) {\r\n        continue;\r\n      }\r\n      runFunc(itemPath);\r\n    }\r\n  };\r\n\r\n  // ignore dirs, include all files on empty filters\r\n  const handled = processWithGlobSync(\r\n    runGlobSync,\r\n    src,\r\n    resolveStringArray(task.include, []),\r\n    resolveStringArray(task.exclude, []),\r\n    true,\r\n    true\r\n  );\r\n\r\n  // expect it is a single file\r\n  if (!handled) {\r\n    runFunc(src);\r\n  }\r\n};\r\n","import { execSync } from 'child_process';\r\nimport { logv } from '@/loggers';\r\nimport { TaskContext, TaskTerminalCommand } from '@/task_data';\r\n\r\nexport const handleTerminalCommand = async (context: TaskContext, task: TaskTerminalCommand) => {\r\n  logv(`Start execution... ${task.cmd}`);\r\n  execSync(task.cmd, {\r\n    shell: task.shell,\r\n    // cwd: cwd,\r\n    env: process.env,\r\n    stdio: [process.stdin, process.stdout, process.stderr],\r\n    encoding: 'utf-8',\r\n  });\r\n};\r\n","import path from 'path';\r\nimport fs from 'fs';\r\nimport fse from 'fs-extra';\r\nimport { logv } from '@/loggers';\r\nimport { TaskContext, TaskSymlink } from '@/task_data';\r\n\r\nexport const handleFsSymlink = async (context: TaskContext, task: TaskSymlink) => {\r\n  const target: string = path.resolve(task.target);\r\n  const dstPath: string = path.resolve(task.path);\r\n\r\n  if (fs.existsSync(dstPath)) {\r\n    const lstat: fs.Stats = fs.lstatSync(dstPath);\r\n    logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\r\n    if (task.forced) {\r\n      if (lstat.isSymbolicLink() || lstat.isFile()) {\r\n        logv(`Unlink ${dstPath}`);\r\n        fs.unlinkSync(dstPath);\r\n      } else if (lstat.isDirectory()) {\r\n        logv(`Remove directory '${dstPath}'`);\r\n        fse.removeSync(dstPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (fs.existsSync(dstPath)) {\r\n    logv(`Could not create symbolic link cause '${dstPath}' already exists`);\r\n    // throw Error()\r\n  } else {\r\n    logv(`Create symbolic link ${target} => ${dstPath}`);\r\n    fs.symlinkSync(target, dstPath, task.linkType);\r\n    const lstat: fs.Stats = fs.lstatSync(dstPath);\r\n    logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\r\n  }\r\n};\r\n","import fs from 'fs';\r\nimport path from 'path';\r\nimport simpleGit, { CheckRepoActions, ResetMode } from 'simple-git';\r\nimport { TaskContext, TaskGitSetup } from 'task_data';\r\n\r\nexport const handleGitSetup = async (context: TaskContext, task: TaskGitSetup) => {\r\n  const localPath = path.resolve(task.localPath);\r\n\r\n  if (!fs.existsSync(localPath)) {\r\n    fs.mkdirSync(localPath, { recursive: true });\r\n  }\r\n\r\n  if (fs.readdirSync(localPath).length === 0) {\r\n    if (task.url) {\r\n      await simpleGit().clone(task.url, localPath);\r\n    }\r\n  }\r\n\r\n  const git = simpleGit(localPath, { binary: task.binary });\r\n\r\n  const isGitRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);\r\n  if (!isGitRepo) {\r\n    throw Error(`${localPath} is not a git repository!!!`);\r\n  }\r\n\r\n  if (task.updateSubmodules) {\r\n    await git.submoduleInit();\r\n    await git.submoduleUpdate();\r\n  } else {\r\n    // const submodules = task.updateSubmodules ?? [];\r\n    // for(var submod of submodules){\r\n    // }\r\n  }\r\n\r\n  await git.fetch();\r\n\r\n  if (task.branch) {\r\n    let hasLocalBranch = false;\r\n    const branchLocal = await git.branchLocal();\r\n    for (var b of branchLocal.all) {\r\n      if (b === task.branch) {\r\n        hasLocalBranch = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    const branch = task.branch ?? '';\r\n    const startPoint: string = task.startPoint ?? '';\r\n\r\n    if (!hasLocalBranch) {\r\n      await git.checkoutBranch(branch, startPoint);\r\n    } else {\r\n      if (branchLocal.current !== task.branch) {\r\n        await git.checkout(branch);\r\n      }\r\n      await git.reset(ResetMode.HARD, [startPoint]);\r\n    }\r\n  }\r\n};\r\n","import { handleSubTasks } from './tasks/handleSubTasks';\r\nimport { handleContentReplace } from './tasks/handleContentReplace';\r\nimport { handleMkdir } from './tasks/handleFsMkdir';\r\nimport { handleFsDelete } from './tasks/handleFsDelete';\r\nimport { handleFsCopy } from './tasks/handleFsCopy';\r\nimport { handleOutput } from './tasks/handleOutput';\r\nimport { handleEnvVar } from './tasks/handleEnvVar';\r\nimport { handleSetVar } from './tasks/handleSetVar';\r\nimport { handleTerminalCommand } from './tasks/handleTerminalCommand';\r\nimport { handleFsSymlink } from './tasks/handleFsSymlink';\r\nimport { handleGitSetup } from './tasks/handleGitRepoSetup';\r\nimport { TaskContext, TaskType } from './task_data';\r\n\r\nexport const handlerMap: {\r\n  [k in TaskType]: (context: TaskContext, task: any) => Promise<void>;\r\n} = {\r\n  'git-setup': handleGitSetup,\r\n  cmd: handleTerminalCommand,\r\n  'set-var': handleSetVar,\r\n  output: handleOutput,\r\n  symlink: handleFsSymlink,\r\n  'fs-copy': handleFsCopy,\r\n  'fs-del': handleFsDelete,\r\n  'fs-mkdir': handleMkdir,\r\n  'env-var': handleEnvVar,\r\n  'sub-tasks': handleSubTasks,\r\n  'content-replace': handleContentReplace,\r\n};\r\n"],"mappings":";ykBAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,qBAAAE,EAAA,gBAAAC,KAAA,eAAAC,GAAAJ,IAEA,IAAAK,GAAiB,mBCFjB,IAAAC,GAAwB,qBACxBC,GAAiB,mBCCf,IAAAC,GAAW,QDEN,IAAMC,GAAiB,oBACjBC,GAAoB,GAEpBC,EAAc,UACdC,EAAW,OAEXC,GAAY,CAACF,EAAaC,CAAQ,EAIzCE,GAAe,OACfC,GAAgB,QAChBC,GAAe,OACRC,EAAY,CAACD,GAAcF,GAAcC,EAAa,EAiB7DG,GAAU,CACd,QAAS,kBAAkBL,GAAU,IAAKM,GAAM,IAAIA,CAAC,GAAG,EAAE,KACxD,MACF,CAAC,yLAAyLR,CAAW,yHAAyHC,CAAQ,wCACxU,EAOaQ,GAASC,GAAwB,CAI5C,IAAMC,EAAU,IAAI,WACpBA,EACG,KAAK,cAAc,EACnB,QAAoBC,EAAO,EAC3B,OAAO,iBAAkB,0BAA0B,EACnD,OAAO,wBAAyB,8BAA+Bd,EAAc,EAC7E,OACC,wBACA,uJACF,EACC,OACC,4BACA,8IACF,EACC,OACC,wBACA,uJACF,EACC,OACC,4BACA,8IACF,EACC,OACC,yBACA,8KACAC,EACF,EACC,OAAO,sBAAuBQ,GAAQ,OAAO,EAC7C,OACC,uBACA,gCAAgCD,EAAU,KACxC,GACF,CAAC,uEACH,EAEC,mBAAmB,EAAI,EAEtBI,IAAa,OACfC,EAAQ,MAAMD,EAAU,CAAE,KAAM,MAAO,CAAC,EAExCC,EAAQ,MAAM,EAMhB,IAAME,EAHOF,EAAQ,KAAK,EAS1B,GALAE,EAAa,QAAUC,EAAuBD,EAAa,OAAO,EAClEA,EAAa,WAAaC,EAAuBD,EAAa,UAAU,EACxEA,EAAa,QAAUC,EAAuBD,EAAa,OAAO,EAClEA,EAAa,WAAaC,EAAuBD,EAAa,UAAU,EAEpEA,EAAa,YAAc,QAAa,OAAOA,EAAa,WAAc,SAAU,CACtF,IAAIL,EAAYK,EAAa,UAC7BL,EAAIA,EAAE,KAAK,EAAE,YAAY,EACrBA,IAAM,SAAWA,IAAM,KAAOA,IAAM,KACtCK,EAAa,UAAY,GAChBL,IAAM,QAAUA,IAAM,KAAOA,IAAM,MAC5CK,EAAa,UAAY,GAEzBA,EAAa,UAAYd,EAE7B,CACA,OAAAc,EAAa,UAAY,CAAC,GAAIF,EAAQ,MAAQ,CAAC,CAAE,EAK7CE,EAAa,KACf,QAAQ,MAAM,GAAAE,QAAK,QAAQF,EAAa,GAAG,CAAC,EAKvC,CAAE,IAAKA,EAAc,QAAAF,CAAQ,CACtC,EAEMG,EAAyB,CAACE,EAAsCC,EAAyB,KAAS,CACtG,GAAI,CAACD,EACH,MAAO,CAAC,EAGV,GAAI,OAAOA,GAAU,SAAU,CAC7B,IAAME,EAAmB,CAAC,EAE1B,OADYF,EAAM,MAAM,GAAG,EACvB,QAASA,GAAU,CACrB,IAAMG,EAAcH,EAAM,KAAK,EAC3BC,EACEE,EAAY,OAAS,GACvBD,EAAO,KAAKC,CAAW,EAGzBD,EAAO,KAAKC,CAAW,CAE3B,CAAC,EACMD,CACT,CAEA,MAAO,CAAC,CACV,EEpJA,IAAAE,GAAiB,mBCAjB,IAAAC,GAAe,iBACfC,GAAiB,mBACjBC,GAAkB,oBCFlB,IAAAC,GAAkB,oBCElB,IAAAC,EAAkD,eAClDC,GAAe,iBAIFC,GAAwB,iCAI/BC,EAAgB,CAA2BC,EAAYC,IACpDC,GAAe,OAAO,CAC3B,KAAM,IAAE,QAAQF,CAAI,EACpB,GAAGC,CACL,CAAC,EAGUE,GAAmB,IAAE,MAAM,CAAC,IAAE,OAAO,EAAE,SAAS,EAAG,IAAE,MAAM,IAAE,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE,SAAS,EAC7FC,GAAoB,IAAE,OAAO,CACxC,QAASD,GACT,QAASA,EACX,CAAC,EAEKE,EAA+B,CAA2BL,EAAYC,IACnEC,GAAe,OAAO,CAC3B,KAAM,IAAE,QAAQF,CAAI,EACpB,GAAGC,EACH,QAASE,GACT,QAASA,EACX,CAAC,EAGUG,GAAwCC,IAC5C,CACL,GAAGA,EACH,oBAAqB,CAAC,CACxB,GA8CK,IAAMC,GAAiB,IAAE,MAAM,CACpC,IAAE,QAAQ,WAAW,EACrB,IAAE,QAAQ,KAAK,EACf,IAAE,QAAQ,SAAS,EACnB,IAAE,QAAQ,QAAQ,EAClB,IAAE,QAAQ,SAAS,EACnB,IAAE,QAAQ,SAAS,EACnB,IAAE,QAAQ,QAAQ,EAClB,IAAE,QAAQ,UAAU,EACpB,IAAE,QAAQ,SAAS,EACnB,IAAE,QAAQ,WAAW,EACrB,IAAE,QAAQ,iBAAiB,CAC7B,CAAC,EAKKC,GAAgB,CACpB,MACA,UACA,SACA,UACA,QACA,QACA,UACA,QACA,QACA,SACA,QACF,EACMC,GAAY,CAAC,GAAGD,GAAe,GAAGA,GAAc,IAAKE,GAAS,IAAIA,CAAI,EAAE,CAAC,EAIzEC,GAAoB,CAAC,MAAO,QAAS,OAAQ,OAAQ,SAAU,MAAO,QAAS,OAAQ,QAAS,KAAK,EACrGC,GAAgB,CAAC,GAAGD,GAAmB,GAAGA,GAAkB,IAAKD,GAAS,IAAIA,CAAI,EAAE,CAAC,EAIrFG,GAAe,CACnB,MACA,QACA,UACA,OACA,SACA,QACA,UACA,OACA,QACA,OACA,OACA,QACF,EACMC,GAAW,CAAC,GAAGD,GAAc,GAAGA,GAAa,IAAKH,GAAS,IAAIA,CAAI,EAAE,CAAC,EAG5E,GAAAK,QAAG,QAAQ,EAEJ,IAAMC,GAAiB,IAAE,OAAO,CACrC,SAAU,IAAE,OAAiB,EAAE,SAAS,EACxC,aAAc,IAAE,OAAqB,EAAE,SAAS,EAChD,QAAS,IAAE,OAAgB,EAAE,SAAS,CACxC,CAAC,EAEYC,GAAiB,IAAE,OAAO,CACrC,KAAMV,GACN,GAAI,IAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAC1C,KAAM,IACH,MAAM,CAAC,IAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAG,IAAE,MAAM,IAAE,OAAO,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC,EAC3E,SAAS,EACT,UAAWW,GACLA,EACD,OAAOA,GAAU,SAAiB,CAACA,CAAK,EACrCA,EAFY,CAAC,CAGrB,EACH,IAAK,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EACpC,QAAS,IAAE,QAAQ,EAAE,QAAQ,EAAI,EACjC,KAAMF,GAAe,SAAS,EAC9B,QAAS,IAAE,OAAO,EAAE,SAAS,EAC7B,QAAS,IAAE,MAAM,CAAC,IAAE,QAAQ,MAAM,EAAG,IAAE,QAAQ,OAAO,EAAG,IAAE,QAAQ,MAAM,CAAC,CAAC,EAAE,QAAQ,OAAO,CAC9F,CAAC,EAKYG,GAAqBC,EAAc,YAAa,CAC3D,UAAW,IAAE,OAAO,EAAE,SAAS,EAE/B,OAAQ,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EACvC,IAAK,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EACpC,OAAQ,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EACvC,WAAY,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAC3C,iBAAkB,IAAE,MAAM,CAAC,IAAE,OAAO,EAAE,SAAS,EAAG,IAAE,OAAO,EAAE,SAAS,EAAG,IAAE,QAAQ,CAAC,CAAC,EAAE,SAAS,CAClG,CAAC,EAGYC,GAAoBD,EAAc,UAAW,CACxD,KAAM,IAAE,QAAQ,SAAS,EACzB,OAAQ,IAAE,OAAO,EAAE,SAAS,EAC5B,KAAM,IAAE,OAAO,EAAE,SAAS,EAC1B,SAAU,IAAE,MAAM,CAAC,IAAE,QAAQ,KAAK,EAAG,IAAE,QAAQ,MAAM,EAAG,IAAE,QAAQ,UAAU,CAAC,CAAC,EAAE,SAAS,EACzF,OAAQ,IAAE,QAAQ,EAAE,SAAS,CAC/B,CAAC,EAGYE,GAA4BF,EAAc,MAAO,CAAE,IAAK,IAAE,OAAO,EAAG,MAAO,IAAE,OAAO,EAAE,SAAS,CAAE,CAAC,EAGlGG,GAAmBC,EAA6B,UAAW,CACtE,IAAK,IAAE,OAAO,EAAE,SAAS,EACzB,MAAO,IAAE,MAAM,CAAC,IAAE,OAAO,EAAG,IAAE,OAAO,EAAG,IAAE,QAAQ,EAAG,IAAE,IAAI,CAAC,CAAC,EAC7D,IAAK,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EACpC,OAAQ,IAAE,MAAM,CAAC,IAAE,QAAQ,MAAM,EAAG,IAAE,QAAQ,OAAO,EAAG,IAAE,QAAQ,QAAQ,EAAG,IAAE,QAAQ,MAAM,CAAC,CAAC,EAAE,SAAS,EAE1G,WAAY,IAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,2DAA2D,CACzG,CAAC,EAGYC,GAAmBD,EAA6B,UAAW,CACtE,IAAK,IAAE,IAAI,IAAE,OAAO,EAAG,IAAE,MAAM,CAAC,IAAE,OAAO,EAAG,IAAE,OAAO,EAAG,IAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,SAAS,EAChF,IAAK,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EACpC,OAAQ,IAAE,MAAM,CAAC,IAAE,QAAQ,MAAM,EAAG,IAAE,QAAQ,OAAO,EAAG,IAAE,QAAQ,MAAM,CAAC,CAAC,EAAE,QAAQ,MAAM,EAE1F,WAAY,IAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,uEAAuE,CACrH,CAAC,EAGYE,GAA0B,IAAE,MAAM,CAC7C,IAAE,QAAQ,SAAS,EAAE,SAAS,mBAAmB,EACjD,IAAE,QAAQ,YAAY,EAAE,SAAS,8BAA8B,EAC/D,IAAE,QAAQ,aAAa,EAAE,SAAS,4BAA4B,EAC9D,IAAE,QAAQ,GAAG,EAAE,SAAS,mBAAmB,EAC3C,IAAE,QAAQ,IAAI,EAAE,SAAS,8BAA8B,EACvD,IAAE,QAAQ,IAAI,EAAE,SAAS,4BAA4B,CACvD,CAAC,EAIYC,GAAmBP,EAAc,SAAU,CACtD,OAAQM,GACR,KAAM,IAAE,OAAO,EACf,KAAM,IAAE,OAAO,EAAE,SAAS,EAAE,SAAS,CACvC,CAAC,EAGYE,GAA0B,IAAE,OAAO,CAC9C,SAAU,IACP,MAAM,CACL,IAAE,QAAQ,WAAW,EACrB,IAAE,QAAQ,MAAM,CAIlB,CAAC,EACA,QAAQ,WAAW,CACxB,CAAC,EAGYC,GAAmBL,EAA6B,UAAW,CACtE,IAAK,IAAE,OAAO,EAAE,SAAS,EACzB,KAAM,IAAE,OAAO,EAAE,SAAS,EAC1B,QAASI,GAAwB,QAAQ,CAAE,SAAU,WAAY,CAAC,CACpE,CAAC,EAGYE,GAAqBN,EAA6B,SAAU,CACvE,KAAM,IAAE,OAAO,EAAE,SAAS,CAC5B,CAAC,EAGYO,GAAsBX,EAAc,WAAY,CAC3D,KAAM,IAAE,OAAO,EAAE,SAAS,CAC5B,CAAC,EAGYY,GAAqBZ,EAAc,YAAa,CAC3D,KAAM,IAAE,OAAO,EAAE,SAAS,EAC1B,SAAU,IACP,OAAO,CAAE,KAAM,IAAE,QAAQ,EAAE,QAAQ,EAAI,EAAG,KAAM,IAAE,QAAQ,EAAE,QAAQ,EAAI,CAAE,CAAC,EAC3E,SAAS,EACT,SAAS,wDAAwD,CACtE,CAAC,EAGYa,GAAkB,IAAE,OAAO,CAAE,QAAS,IAAE,OAAO,EAAG,MAAO,IAAE,OAAO,EAAE,SAAS,CAAE,CAAC,EAChFC,GAAwB,IAAE,MAAM,CAAC,IAAE,OAAO,EAAE,SAAS,EAAGD,EAAe,CAAC,EAGxEE,GAA2BX,EAA6B,kBAAmB,CACtF,KAAM,IACH,OAAO,EACP,SAAS,EACT,SACC;AAAA,iDAGF,EACF,KAAMU,GACN,QAAS,IAAE,OAAO,EAClB,KAAM,IAAE,OAAO,EAAE,SAAS,CAC5B,CAAC,EAGYE,GAAa,IAAE,MAAM,CAChCjB,GACAG,GACAC,GACAE,GACAE,GACAE,GACAC,GACAC,GACAV,GACAW,GACAG,EACF,CAAC,EASYE,GAAoB,IAAE,OAAO,CAExC,KAAM,IAAE,OAAO,EAAE,SAAS,EAC1B,IAAK,IACF,OAAO,CAEN,SAAU,IAAE,KAAKC,CAAS,EAAE,QAAQ,MAAM,EAG1C,gBAAiB,IACd,OAAO,EACP,SAAS,EACT,QAAQC,EAAqB,EAC7B,SAAS,gDAAgD,EACzD,OAAQrB,GAAUA,EAAM,QAAQ,GAAG,GAAK,GAAKA,EAAM,QAAQ,GAAG,GAAK,EAAG,CACrE,QAAS,yDACX,CAAC,EAGH,gBAAiB,IACd,OAAO,EACP,SAAS,EACT,QAAQqB,EAAqB,EAC7B,SAAS,4DAA4D,EACrE,OAAQrB,GAAUA,EAAM,QAAQ,GAAG,GAAK,GAAKA,EAAM,QAAQ,GAAG,GAAK,EAAG,CACrE,QAAS,yDACX,CAAC,EAEH,QAAS,IAAE,MAAM,CAAC,IAAE,QAAQsB,CAAW,EAAG,IAAE,QAAQC,CAAQ,CAAC,CAAC,EAAE,QAAQD,CAAW,CACrF,CAAC,EACA,QAAQ,CAAE,SAAU,OAAQ,gBAAiBD,GAAuB,gBAAiBA,EAAsB,CAAC,EAC/G,MAAO,IAAE,MAAMH,EAAU,EAAE,QAAQ,CAAC,CAAC,CACvC,CAAC,EAIYM,GAAU,eACVC,GAAY,GAAGD,EAAO,SACtBE,EAAW,GAAGF,EAAO,QACrBG,EAAW,GAAGH,EAAO,QAErBI,GAA2B,SAC3BC,GAA+B,SD1VrC,IAAMC,MAAO,GAAAC,SAAMC,CAAQ,EACrBC,KAAO,GAAAF,SAAMG,CAAQ,EACrBC,KAAO,GAAAJ,SAAMK,EAAS,EDAnC,IAAAC,GAAyB,6BAEZC,EAAmBC,GAAqB,CAEnD,GADAC,EAAK,iBAAiBD,CAAQ,EAAE,EAC5B,CAAC,GAAAE,QAAG,WAAWF,CAAQ,EACzB,MAAM,IAAI,MAAM,oBAAoBA,CAAQ,oBAAoB,EAGlE,OAAO,GAAAE,QAAG,aAAaF,EAAU,CAAE,SAAU,OAAQ,CAAC,CACxD,EAEaG,GAAYH,GAChBI,EAAUL,EAAgBC,CAAQ,CAAC,EAG/BI,EAAaC,GAAoB,GAAAC,QAAM,MAAMD,CAAO,EAEpDE,GAAkBP,GAAuC,CACpE,IAAIQ,EAAaL,GAASH,CAAQ,EAClC,GAAIQ,EAAW,QAAS,CACtB,IAAMC,EAAc,GAAAC,QAAK,QAAQV,CAAQ,EACnCW,EAAkB,GAAAD,QAAK,QAAQD,EAAaD,EAAW,OAAO,EACpEA,KAAa,aAAS,CAAC,EAAGA,EAAYD,GAAeI,CAAe,CAAC,CACvE,CAEA,OAAOH,CACT,EAEaI,GAAoC,CAACC,EAAcC,IAAkB,CAChF,GAAI,CAACA,EACH,OAAOD,EAGT,IAAIE,EAAS,GACTC,EAAUH,EAAK,MAAM,GAAG,EAC5B,QAASI,EAAI,EAAGA,EAAID,EAAQ,OAAQC,IAAK,CACvC,IAAIC,EAAOF,EAAQC,CAAC,EAChBA,IAAM,EACRF,EAASG,GAELA,EAAK,OAAS,IAChBA,EAAO,GAAGA,EAAK,CAAC,EAAE,YAAY,CAAC,GAAGA,EAAK,UAAU,CAAC,CAAC,IAErDH,EAAS,GAAGA,CAAM,GAAGG,CAAI,GAE7B,CACA,OAAOH,CACT,EAEaI,GAAc,CAACC,EAAoBC,IAAoB,CAClE,GAAID,EAAS,OAAS,EACpB,MAAO,GAGT,QAAWE,KAAMF,EACf,GAAIC,GACF,QAAWE,KAAOF,EAChB,GAAIC,IAAOC,EACT,MAAO,GAMf,MAAO,EACT,EAEaC,GAAiB,CAACJ,EAAoBC,IAAoB,CACrE,GAAID,EAAS,OAAS,EACpB,MAAO,GAET,QAAWE,KAAMF,EAAU,CACzB,IAAIK,EAAY,GAChB,GAAIJ,GACF,QAAWE,KAAOF,EAChB,GAAIE,IAAQD,EAAI,CACdG,EAAY,GACZ,KACF,EAIJ,GAAI,CAACA,EACH,MAAO,EAEX,CACA,MAAO,EACT,EAEaC,GAA0B,CAACC,EAAcC,IAAkB,CACtE,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,QAAQD,CAAI,+BAA+B,CAE/D,EAEaE,EAAmB,CAACC,EAAYC,IAAgB,CACtDD,EAAaC,CAAG,IAAM,QAAWC,GAAK,YAAYD,CAAG,wBAAwB,CACpF,EAGaE,GAAY,CAACL,EAAYM,IAChCA,EAAa,QAAU,EAAU,GAC9BA,EAAa,SAAS,OAAON,CAAK,EAG9BO,EAAmB,CAACR,EAAcC,EAAYM,IAAwC,CACjG,GAAID,GAAUL,EAAOM,CAAY,EAC/B,MAAO,GAGT,IAAME,EAAY,OAAOR,EACzB,MAAM,IAAI,MACR,QAAQD,CAAI,mCAAmCS,CAAS,qBAAqBR,CAAK,6BAA6BM,CAAY,IAC7H,CACF,EAEMG,GACJ,+IAGK,SAASC,EAAWC,EAAa,CACtC,IAAMC,EAAW,CAAC,EAGdC,EAAQF,EAAI,SAAS,EAGzBE,EAAQA,EAAM,QAAQ,UAAW;AAAA,CAAI,EAErC,IAAIC,EACJ,MAAQA,EAAQL,GAAS,KAAKI,CAAK,IAAM,MAAM,CAC7C,IAAMV,EAAMW,EAAM,CAAC,EAEfd,EAAQc,EAAM,CAAC,GAAK,GAExBd,EAAQA,EAAM,KAAK,EAEnB,IAAMe,EAAaf,EAAM,CAAC,EAE1BA,EAAQA,EAAM,QAAQ,yBAA0B,IAAI,EAEhDe,IAAe,MACjBf,EAAQA,EAAM,QAAQ,OAAQ;AAAA,CAAI,EAClCA,EAAQA,EAAM,QAAQ,OAAQ,IAAI,GAIpCY,EAAIT,CAAG,EAAIH,CACb,CAEA,OAAOY,CACT,CAEO,IAAMI,GAAyB,CAAuBJ,EAAQT,IAAW,CAC9E,MAAM,IAAI,MAAM,kBAAkB,OAAOA,CAAG,CAAC,0BAA0BS,EAAIT,CAAG,CAAC,EAAE,CACnF,EAEac,EAAqB,CAACC,EAA2CC,IAAqC,CACjH,GAAyBD,GAAQ,KAAM,CACrC,GAAI,OAAOA,GAAQ,SACjB,MAAO,CAACA,CAAG,EACN,GAAI,MAAM,QAAQA,CAAG,EAC1B,OAAOA,EAAI,OAAQE,GAAM,OAAOA,GAAM,QAAQ,CAElD,CAEA,OAAOD,CACT,EDzKA,IAAAE,GAAkB,oBAClBC,GAAe,iBIAf,IAAAC,EAA8B,6BAEjBC,GAAqB,MAAOC,EAAsBC,IAAe,CAC5E,IAAMC,EAAmBD,EACzB,QAAWE,KAAO,OAAO,KAAKD,CAAW,EACvC,GAAI,OAAOC,GAAQ,UAIf,EAAAA,IAAQ,MAAQA,IAAQ,SAIxBD,EAAYC,CAAG,IAAM,QAAa,OAAOD,EAAYC,CAAG,GAAM,SAAU,CAC1E,IAAIC,EAAqBF,EAAYC,CAAG,EACxC,OAAa,CACX,IAAME,EAAiBC,GAAkB,CACvCN,EAAQ,mBAAmB,UAAY,EACvC,IAAMO,EAAUP,EAAQ,mBAAmB,KAAKM,CAAK,EAE/CE,KAAY,YAASD,CAAO,EAE5BE,EAAaF,IAAU,CAAC,EAExBG,EAAUH,IAAU,CAAC,EACrBI,EAAaD,KAAU,OAAI,QAAQ,IAAKA,CAAO,EAAI,OAQzD,MAAO,CACL,UAAAF,EACA,WAAAC,EACA,QAAAC,EACA,WAAAC,EACA,YAXkB,IAAM,CACxB,IAAMC,EAAcN,EAAM,UAAU,EAAGC,EAAS,KAAK,EAC/CM,EAAe,GAAGF,CAAU,GAC5BG,EAAcR,EAAM,UAAUC,EAAS,MAAQE,EAAY,MAAM,EACvE,MAAO,GAAGG,CAAW,GAAGC,CAAY,GAAGC,CAAW,EACpD,CAOA,CACF,EA4BMC,GA1BcT,GAAkB,CACpCN,EAAQ,gBAAgB,UAAY,EACpC,IAAMO,EAAUP,EAAQ,gBAAgB,KAAKM,CAAK,EAE5CE,KAAY,YAASD,CAAO,EAE5BE,EAAaF,IAAU,CAAC,EAExBG,EAAUH,IAAU,CAAC,EACrBI,EAAaD,KAAU,OAAIV,EAAQ,WAAYU,CAAO,MAAK,OAAIV,EAAQ,KAAMU,CAAO,EAAI,OAQ9F,MAAO,CACL,UAAAF,EACA,WAAAC,EACA,QAAAC,EACA,WAAAC,EACA,YAXkB,IAAM,CACxB,IAAMC,EAAcN,EAAM,UAAU,EAAGC,EAAS,KAAK,EAC/CM,EAAe,GAAGF,CAAU,GAC5BG,EAAcR,EAAM,UAAUC,EAAS,MAAQE,EAAY,MAAM,EACvE,MAAO,GAAGG,CAAW,GAAGC,CAAY,GAAGC,CAAW,EACpD,CAOA,CACF,GAEoCV,CAAU,EACxCY,EAAsBX,EAAcD,CAAU,EAEpD,GAAIW,EAAiB,UACnBE,EAAK,wBAAwBd,CAAG,OAAOC,CAAU,GAAG,EACpDA,EAAaW,EAAiB,YAAY,UACjCC,EAAoB,UAC7BC,EAAK,wBAAwBd,CAAG,OAAOC,CAAU,GAAG,EACpDA,EAAaY,EAAoB,YAAY,MAE7C,MAEJ,CAEAd,EAAYC,CAAG,EAAIC,CACrB,CAEJ,EAEac,GAAsB,CACjCC,EACAC,EACAC,EACAC,IACG,CACH,IAAIC,EACAC,EAA+B,GAEnC,QAASC,KAAYN,EAAW,CAE9B,GADYM,EAAS,KAAK,IACd,KAAM,CAChBR,EAAK,sBAAsB,EAC3B,KACF,CAEA,GAAIO,GAAuBD,EAAgB,CACzC,IAAMjB,EAAQmB,EAAS,WAAW,GAAG,EAAI,GAAKA,EAC9CH,EAASC,EAAgBjB,CAAK,EAC9BiB,EAAiB,OACjBC,EAAsB,EACxB,SACsBC,EAAS,QAAQL,CAAG,GACrB,EAAG,CACpB,IAAMM,EAAiBD,EAAS,QAAQ,GAAG,EAC3C,GAAIC,GAAkB,EAAG,CACvB,IAAMC,EAAUC,GACdH,EAAS,UAAUL,EAAI,OAAQM,CAAc,EAC7CL,CACF,EACMf,EAAQmB,EAAS,UAAUC,EAAiB,CAAC,EACnDJ,EAASK,EAASrB,CAAK,CACzB,MACEiB,EAAiBK,GAAkCH,EAAS,UAAUL,EAAI,MAAM,EAAGC,CAAkB,EACrGG,EAAsB,EAE1B,CAEJ,CACF,EAEaK,EAAa,CAAC7B,EAAsBG,EAAaG,EAAYwB,IAA2B,CACnG,GAAIA,GAAiB9B,EAAQ,KAAKG,CAAG,IAAM,OAAW,CACpDc,EAAK,gCAAgCd,CAAG,IAAIG,CAAK,6BAA6B,EAC9E,MACF,CAEAW,EAAK,qBAAqBd,CAAG,IAAIG,CAAK,EAAE,EACxCN,EAAQ,KAAKG,CAAG,EAAIG,CACtB,EAEayB,EAAY,CAAC/B,EAAsBG,EAAaG,EAAYwB,IAA2B,CAClG,IAAIE,EAAY,OAAO1B,EACvB,GAAI0B,IAAc,UAAYA,IAAc,UAAYA,IAAc,UACpEf,EAAK,8BAA8Be,CAAS,0BAA0B7B,CAAG,IAAIG,CAAK,EAAE,UAElE,OAAOA,CAAK,EAChB,OAAS,EACrBW,EAAK,6CAA6Cd,CAAG,IAAIG,CAAK,EAAE,MAC3D,CACL,GAAIwB,GAAiB,QAAQ,IAAI3B,CAAG,IAAM,OAAW,CACnDc,EAAK,4CAA4Cd,CAAG,IAAIG,CAAK,6BAA6B,EAC1F,MACF,CAEAW,EAAK,iCAAiCd,CAAG,IAAIG,CAAK,EAAE,EACpD,QAAQ,IAAIH,CAAG,EAAI,OAAOG,CAAK,CACjC,CAEJ,EChKA,IAAA2B,GAAuB,0BAKhB,IAAMC,GAAiB,MAAOC,EAAsBC,IAAuB,CAChF,GAAI,CAACA,EAAK,MAAQ,OAAOA,EAAK,MAAS,SACrC,MAAM,IAAI,MAAM,2DAA2D,EAG7E,IAAMC,KAAU,GAAAC,SAAWF,EAAK,IAAI,EAC9BG,EAAcC,GAAMH,CAAO,EACjCI,EAAgBN,EAAQ,UAAWI,EAAY,IAAKA,EAAY,OAAO,CACzE,ECbA,IAAAG,EAAe,iBACfC,GAAiB,mBCDjB,IAAAC,GAAe,iBACfC,EAAyB,gBAYZC,EAAsB,CACjCC,EACAC,EACAC,EACAC,EACAC,EACAC,IACY,CACZ,GAAI,GAAAC,QAAG,SAASL,CAAG,EAAE,YAAY,IAAM,GACrC,MAAO,GAIT,IAAMM,EAAiBH,IAAa,GAE9BI,EAAuBN,EAAS,OAAS,EACzCO,EAAuBN,EAAS,OAAS,EAC/C,MAAI,CAACK,GAAeC,GAElBT,KAAQ,YAAS,CAAC,IAAI,EAAG,CAAE,OAAQ,CAAC,GAAGG,CAAQ,EAAG,IAAAF,EAAK,MAAAM,CAAM,CAAC,EAAE,OAAQG,GAASA,IAAS,GAAG,CAAC,EACvF,IACEF,GAAe,CAACC,GAEzBT,KAAQ,YAASE,EAAU,CAAE,IAAAD,EAAK,MAAAM,CAAM,CAAC,CAAC,EACnC,IACEC,GAAeC,GAExBT,KAAQ,YAASE,EAAU,CAAE,OAAQC,EAAU,IAAAF,EAAK,MAAAM,CAAM,CAAC,CAAC,EACrD,IACEF,GAETL,KAAQ,YAAS,CAAC,IAAI,EAAG,CAAE,IAAAC,EAAK,MAAAM,CAAM,CAAC,EAAE,OAAQG,GAASA,IAAS,GAAG,CAAC,EAChE,IAGF,EACT,ED1CA,IAAMC,GAA6B,CAACC,EAAiBC,EAAcC,EAAiBC,IAA2B,CAC7G,IAAIC,EAAeJ,EACnB,GAAIG,EAAS,EACX,KAAOF,EAAK,KAAKG,CAAI,GACnBA,EAAOA,EAAK,QAAQH,EAAMC,CAAO,MAGnC,SAAS,EAAI,EAAG,EAAIC,EAAQ,IACtBF,EAAK,KAAKG,CAAI,IAChBA,EAAOA,EAAK,QAAQH,EAAMC,CAAO,GAIvC,OAAOE,CACT,EAEMC,GAA4B,CAACL,EAAiBC,EAAcC,EAAiBC,IAA2B,CAC5G,IAAIC,EAAeJ,EACnB,GAAIG,EAAS,EACX,KAAOC,EAAK,QAAQH,CAAI,GAAK,GAC3BG,EAAOA,EAAK,QAAQH,EAAMC,CAAO,MAGnC,SAAS,EAAI,EAAG,EAAIC,EAAQ,IACtBC,EAAK,QAAQH,CAAI,GAAK,IACxBG,EAAOA,EAAK,QAAQH,EAAMC,CAAO,GAIvC,OAAOE,CACT,EAEME,GAAeC,GACIA,GAAM,MAAQ,OAAOA,GAAM,UAAY,YAAaA,GAAK,OAAOA,EAAE,SAAY,SAQjGC,GAAyB,CAC7BC,EACAC,EACAT,EACAC,EACAC,IACG,CACHQ,EAAK,qBAAqBF,CAAI,EAAE,EAChC,IAAMT,EAAkB,EAAAY,QAAG,aAAaH,EAAM,OAAO,EAC/CI,EAAaH,EAAYV,EAASC,EAAMC,EAASC,CAAM,EAC7D,EAAAS,QAAG,cAAcH,EAAMI,EAAY,OAAO,CAC5C,EAEaC,GAAuB,MAAOC,EAAsBC,IAA6B,CAC5F,GAAI,CAAC,EAAAJ,QAAG,WAAWI,EAAK,IAAI,EAAG,CAC7BL,EAAK,QAAQK,EAAK,IAAI,kBAAkB,EACxC,MACF,EAEIA,EAAK,UAAY,QAAa,OAAOA,EAAK,SAAY,WACxDC,GAAuBD,EAAM,SAAS,EAGxC,IAAIE,EAAeF,EAAK,OAAS,QAAaA,EAAK,OAAS,KAAO,EAAIA,EAAK,KACxE,OAAOE,GAAS,SAClBA,EAAO,SAASA,EAAM,EAAE,EACf,OAAOA,GAAS,UACzBD,GAAuBD,EAAM,MAAM,EAGrC,IAAIf,EACAS,EACJ,GAAIJ,GAAYU,EAAK,IAAI,EAAG,CAC1B,IAAMG,EAAYH,EAAK,KACvBf,EAAO,IAAI,OAAOkB,EAAU,QAASA,EAAU,KAAK,EACpDT,EAAcX,EAChB,SAAW,OAAOiB,EAAK,MAAS,SAC9Bf,EAAOe,EAAK,KACZN,EAAcL,OACT,CACLY,GAAuBD,EAAM,MAAM,EACnC,MACF,CAegBI,EAbKC,GAAoB,CACvC,QAAWC,KAAKD,EAAO,CACrB,IAAME,EAAmB,GAAAd,QAAK,KAAKO,EAAK,KAAMM,CAAC,EAE3C,EAAAV,QAAG,WAAWW,CAAQ,GAAK,EAAAX,QAAG,SAASW,CAAQ,EAAE,YAAY,GAIjEf,GAAuB,GAAAC,QAAK,KAAKO,EAAK,KAAMM,CAAC,EAAGZ,EAAaT,EAAMe,EAAK,QAASE,CAAI,CACvF,CACF,EAKEF,EAAK,KACLQ,EAAmBR,EAAK,QAAS,CAAC,CAAC,EACnCQ,EAAmBR,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIER,GAAuBQ,EAAK,KAAMN,EAAaT,EAAMe,EAAK,QAASE,CAAI,CAE3E,EEtHA,IAAAO,GAA2B,oBAKpB,IAAMC,GAAc,MAAOC,EAAsBC,IAAwB,CAC9EC,EAAiB,OAAQD,EAAK,KAAM,CAAC,QAAQ,CAAC,EAC9CE,EAAK,yBAAyBF,EAAK,IAAI,EAAE,KACzC,eAAWA,EAAK,IAAI,CACtB,ECTA,IAAAG,GAAe,iBACfC,GAAiB,mBAEjBC,GAAgB,uBAOT,IAAMC,GAAaC,GAAiB,CACzCC,EAAK,WAAWD,CAAI,EAAE,EACtB,GAAAE,QAAI,WAAWF,CAAI,CACrB,EAEaG,GAAiB,MAAOC,EAAsBC,IAAuB,CAChF,GAAI,CAAC,GAAAC,QAAG,WAAWD,EAAK,IAAI,EAAG,CAC7BJ,EAAK,QAAQI,EAAK,IAAI,wCAAwC,EAC9D,MACF,CASgBE,EAPKC,GAAoB,CACvC,QAAWC,KAAKD,EACdT,GAAU,GAAAC,QAAK,KAAKK,EAAK,KAAMI,CAAC,CAAC,CAErC,EAKEJ,EAAK,KACLK,EAAmBL,EAAK,QAAS,CAAC,CAAC,EACnCK,EAAmBL,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIEN,GAAUM,EAAK,IAAI,CAEvB,ECxCA,IAAAM,GAAiB,mBAGjB,IAAAC,GAAgB,uBAGT,IAAMC,GAAU,CAACC,EAAaC,EAAaC,IAAiC,CACjFC,EAAK,SAASH,CAAG,OAAOC,CAAG,EAAE,EAC7B,GAAAG,QAAI,SAASJ,EAAKC,EAAKC,CAAO,CAChC,EAEaG,GAAe,MAAOC,EAAsBC,IAAqB,CAC5E,GAAI,CAAC,GAAAH,QAAI,WAAWG,EAAK,GAAG,EAC1B,MAAM,IAAI,MAAM,eAAeA,EAAK,GAAG,kBAAkB,EAG3D,IAAMC,EAAWD,GAAM,SAAS,SAC5BE,EACwBD,GAAa,MAAS,OAAOA,GAAa,UAAYA,EAAS,KAAK,IAAM,YAGlGD,EAAK,SAAW,cAAeA,GAAM,SAAW,OAAOA,GAAM,SAAS,WAAc,YACtFE,EAAYF,EAAK,QAAQ,WAG3B,IAAMG,EAA6B,CAAE,UAAAD,CAAU,EAW/BE,EATKC,GAAoB,CACvC,QAAWC,KAAKD,EAAO,CACrB,IAAME,EAAO,GAAAC,QAAK,KAAKR,EAAK,IAAKM,CAAC,EAC5BG,EAAK,GAAAD,QAAK,KAAKR,EAAK,KAAMM,CAAC,EACjCd,GAAQe,EAAME,EAAIN,CAAK,CACzB,CACF,EAKEH,EAAK,IACLU,EAAmBV,EAAK,QAAS,CAAC,CAAC,EACnCU,EAAmBV,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIER,GAAQQ,EAAK,IAAKA,EAAK,KAAMG,CAAK,CAEtC,EClDA,IAAAQ,EAAe,iBACfC,GAA2B,oBAC3BC,GAAiB,mBAGJC,GAAe,MAAOC,EAAsBC,IAAqB,CAC5E,IAAMC,EAAOD,EAAK,MAAQ,GACpBE,GAA6BF,EAAK,QAAU,KAAK,KAAK,EACtDG,EAAaH,EAAK,KAExB,GAAIE,IAAW,KAAOA,IAAW,UAC/B,QAAQ,IAAID,CAAI,MACX,CACL,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,kDAAkDD,CAAM,IAAI,EAG9E,IAAME,EAAe,GAAAC,QAAK,QAAQF,CAAU,EACtCG,EAAM,GAAAD,QAAK,QAAQD,CAAY,EAKrC,GAJK,EAAAG,QAAG,WAAWD,CAAG,MACpB,eAAWA,CAAG,EAGZJ,GAAU,MAAQA,GAAU,cAAe,CAC7C,IAAIM,EACAC,EACJ,GAAI,CACFA,EAAK,EAAAF,QAAG,SAASH,EAAc,GAAG,EAClC,EAAAG,QAAG,eAAeE,EAAIR,EAAM,MAAM,CACpC,OAASS,EAAG,CACVF,EAAME,CACR,QAAE,CACID,IAAO,QACT,EAAAF,QAAG,UAAUE,CAAE,CAEnB,CAEA,GAAID,EACF,MAAMA,CAEV,MACE,EAAAD,QAAG,cAAcH,EAAcH,CAAI,CAEvC,CACF,EC5CA,IAAAU,GAAgB,uBAChBC,GAAiB,mBAajB,IAAAC,GAAyB,sBAGZC,GAAe,MAAOC,EAAsBC,IAAqB,CAC5EC,EAAiBD,EAAM,KAAK,EAC5BC,EAAiBD,EAAM,SAAS,EAChCC,EAAiBD,EAAM,YAAY,EAE/BA,EAAK,aAAe,KACtBA,EAAK,WAAa,IAEpB,IAAME,EAAsBF,EAAK,WAEjC,MAAI,aAASA,EAAK,GAAG,EAAG,CACtB,IAAIG,EAAWH,EAAK,IAChB,OAAOG,GAAQ,UACjBC,EAAK,2BAA2B,EAChCD,EAAME,EAAWF,CAAG,IACX,OAAOA,GAAQ,UAAY,MAAM,QAAQA,CAAG,IACrD,OAAO,KAAKA,CAAG,EAAE,QAASG,GAAQ,CAChCC,EAAUR,EAASO,EAAKH,EAAIG,CAAG,EAAGJ,CAAU,CAC9C,CAAC,CAEL,CAEA,GAAI,CAACF,EAAK,IAAK,OAEfQ,EAAiB,MAAOR,EAAK,IAAK,CAAC,QAAQ,CAAC,EAC5C,IAAMS,EAAMT,EAAK,IACXU,EAASV,EAAK,QAAU,OAC9BI,EAAK,YAAYM,CAAM,EAAE,EAEzB,IAAMC,EAAWC,GAAqB,CACpC,IAAMC,EAAW,GAAAC,QAAK,QAAQF,CAAQ,EAClCG,EACEC,EAAUC,EAAgBJ,CAAQ,EAExC,GAAIH,IAAW,QAAUA,IAAW,OAClC,GAAI,CACFN,EAAK,0BAA0B,EAC/BW,EAAMG,EAAUF,CAAO,CACzB,OAASG,EAAG,CACV,GAAIT,IAAW,OAAQ,MAAMS,CAC/B,CAQF,GALI,CAACJ,IAAQL,IAAW,QAAUA,IAAW,WAC3CN,EAAK,2BAA2B,EAChCW,EAAMV,EAAWW,CAAO,GAGtBD,EAAK,CACP,IAAMK,EAAWL,EACjB,OAAO,KAAKK,CAAQ,EAAE,QAASd,GAAQ,CACrCC,EAAUR,EAASO,EAAKc,EAASd,CAAG,EAAGJ,CAAU,CACnD,CAAC,CACH,CACF,EAcgBmB,EAZKC,GAAoB,CACvC,QAAW,KAAKA,EAAO,CACrB,IAAMC,EAAmB,GAAAT,QAAK,KAAKL,EAAK,CAAC,EAErC,GAAAe,QAAI,SAASD,CAAQ,EAAE,YAAY,GAGvCZ,EAAQY,CAAQ,CAClB,CACF,EAKEd,EACAgB,EAAmBzB,EAAK,QAAS,CAAC,CAAC,EACnCyB,EAAmBzB,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIEW,EAAQF,CAAG,CAEf,EClGA,IAAAiB,GAAe,iBACfC,GAAiB,mBAeV,IAAMC,GAAe,MAAOC,EAAsBC,IAAqB,CAC5EC,EAAiBD,EAAM,KAAK,EAC5BC,EAAiBD,EAAM,SAAS,EAChCC,EAAiBD,EAAM,YAAY,EAEnCE,EAAiB,MAAOF,EAAK,IAAK,CAAC,QAAQ,CAAC,EAC5CG,GAAwB,MAAOH,EAAK,GAAG,EAEnCA,EAAK,aAAe,KACtBA,EAAK,WAAa,IAEpB,IAAMI,EAAsBJ,EAAK,WAEjC,GAAIA,EAAK,QAAU,OAAW,CAC5B,IAAMK,EAAQL,EAAK,MACnBM,EAAWP,EAASC,EAAK,IAAKK,EAAOD,CAAU,CACjD,CAEA,GAAI,CAACJ,EAAK,IAAK,OACfE,EAAiB,MAAOF,EAAK,IAAK,CAAC,QAAQ,CAAC,EAE5C,IAAMO,EAAMP,EAAK,IACXQ,EAASR,EAAK,QAAU,OAC9BS,EAAK,YAAYD,CAAM,EAAE,EAEzB,IAAME,EAAWC,GAAqB,CACpC,IAAMC,EAAW,GAAAC,QAAK,QAAQF,CAAQ,EAClCG,EACEC,EAAUC,EAAgBJ,CAAQ,EAExC,GAAIJ,IAAW,QAAUA,IAAW,OAClC,GAAI,CACFC,EAAK,0BAA0B,EAC/BK,EAAMG,EAAUF,CAAO,CACzB,OAASG,EAAG,CACV,GAAIV,IAAW,OAAQ,MAAMU,CAC/B,CAGE,CAACJ,IAAQN,IAAW,QAAUA,IAAW,WAC3CC,EAAK,2BAA2B,EAChCK,EAAMK,EAAWJ,CAAO,GAGtB,CAACD,IAAQN,IAAW,QAAUA,IAAW,YAC3CM,EAAMC,GAGRT,EAAWP,EAASC,EAAK,IAAKc,EAAKV,CAAU,CAC/C,EAagBgB,EAXKC,GAAoB,CACvC,QAAW,KAAKA,EAAO,CACrB,IAAMC,EAAmB,GAAAT,QAAK,KAAKN,EAAK,CAAC,EACrC,GAAAgB,QAAG,SAASD,CAAQ,EAAE,YAAY,GAGtCZ,EAAQY,CAAQ,CAClB,CACF,EAKEf,EACAiB,EAAmBxB,EAAK,QAAS,CAAC,CAAC,EACnCwB,EAAmBxB,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIEU,EAAQH,CAAG,CAEf,EC3FA,IAAAkB,GAAyB,yBAIlB,IAAMC,GAAwB,MAAOC,EAAsBC,IAA8B,CAC9FC,EAAK,sBAAsBD,EAAK,GAAG,EAAE,KACrC,aAASA,EAAK,IAAK,CACjB,MAAOA,EAAK,MAEZ,IAAK,QAAQ,IACb,MAAO,CAAC,QAAQ,MAAO,QAAQ,OAAQ,QAAQ,MAAM,EACrD,SAAU,OACZ,CAAC,CACH,ECbA,IAAAE,GAAiB,mBACjBC,EAAe,iBACfC,GAAgB,uBAIT,IAAMC,GAAkB,MAAOC,EAAsBC,IAAsB,CAChF,IAAMC,EAAiB,GAAAC,QAAK,QAAQF,EAAK,MAAM,EACzCG,EAAkB,GAAAD,QAAK,QAAQF,EAAK,IAAI,EAE9C,GAAI,EAAAI,QAAG,WAAWD,CAAO,EAAG,CAC1B,IAAME,EAAkB,EAAAD,QAAG,UAAUD,CAAO,EAC5CG,EAAK,qBAAqBD,EAAM,eAAe,CAAC,mBAAmBA,EAAM,YAAY,CAAC,EAAE,EACpFL,EAAK,SACHK,EAAM,eAAe,GAAKA,EAAM,OAAO,GACzCC,EAAK,UAAUH,CAAO,EAAE,EACxB,EAAAC,QAAG,WAAWD,CAAO,GACZE,EAAM,YAAY,IAC3BC,EAAK,qBAAqBH,CAAO,GAAG,EACpC,GAAAI,QAAI,WAAWJ,CAAO,GAG5B,CAEA,GAAI,EAAAC,QAAG,WAAWD,CAAO,EACvBG,EAAK,yCAAyCH,CAAO,kBAAkB,MAElE,CACLG,EAAK,wBAAwBL,CAAM,OAAOE,CAAO,EAAE,EACnD,EAAAC,QAAG,YAAYH,EAAQE,EAASH,EAAK,QAAQ,EAC7C,IAAMK,EAAkB,EAAAD,QAAG,UAAUD,CAAO,EAC5CG,EAAK,qBAAqBD,EAAM,eAAe,CAAC,mBAAmBA,EAAM,YAAY,CAAC,EAAE,CAC1F,CACF,ECjCA,IAAAG,GAAe,iBACfC,GAAiB,mBACjBC,EAAuD,yBAG1CC,GAAiB,MAAOC,EAAsBC,IAAuB,CAChF,IAAMC,EAAY,GAAAC,QAAK,QAAQF,EAAK,SAAS,EAExC,GAAAG,QAAG,WAAWF,CAAS,GAC1B,GAAAE,QAAG,UAAUF,EAAW,CAAE,UAAW,EAAK,CAAC,EAGzC,GAAAE,QAAG,YAAYF,CAAS,EAAE,SAAW,GACnCD,EAAK,KACP,QAAM,EAAAI,SAAU,EAAE,MAAMJ,EAAK,IAAKC,CAAS,EAI/C,IAAMI,KAAM,EAAAD,SAAUH,EAAW,CAAE,OAAQD,EAAK,MAAO,CAAC,EAGxD,GAAI,CADc,MAAMK,EAAI,YAAY,mBAAiB,YAAY,EAEnE,MAAM,MAAM,GAAGJ,CAAS,6BAA6B,EAcvD,GAXID,EAAK,mBACP,MAAMK,EAAI,cAAc,EACxB,MAAMA,EAAI,gBAAgB,GAO5B,MAAMA,EAAI,MAAM,EAEZL,EAAK,OAAQ,CACf,IAAIM,EAAiB,GACfC,EAAc,MAAMF,EAAI,YAAY,EAC1C,QAASG,KAAKD,EAAY,IACxB,GAAIC,IAAMR,EAAK,OAAQ,CACrBM,EAAiB,GACjB,KACF,CAGF,IAAMG,EAAST,EAAK,QAAU,GACxBU,EAAqBV,EAAK,YAAc,GAEzCM,GAGCC,EAAY,UAAYP,EAAK,QAC/B,MAAMK,EAAI,SAASI,CAAM,EAE3B,MAAMJ,EAAI,MAAM,YAAU,KAAM,CAACK,CAAU,CAAC,GAL5C,MAAML,EAAI,eAAeI,EAAQC,CAAU,CAO/C,CACF,EC7CO,IAAMC,GAET,CACF,YAAaC,GACb,IAAKC,GACL,UAAWC,GACX,OAAQC,GACR,QAASC,GACT,UAAWC,GACX,SAAUC,GACV,WAAYC,GACZ,UAAWC,GACX,YAAaC,GACb,kBAAmBC,EACrB,EjBHA,IAAAC,EAAgC,sBAEnBC,GAAc,MACzBC,EACAC,EACAC,EACAC,IACG,CACH,IAAMC,EAA2BC,GAAkB,MAAMH,CAAgB,EAGnEI,EAAgBL,EAAK,QAAUA,EAAK,UAAYM,EAAWH,EAAY,IAAI,UAAYG,EAEzFC,EACAC,EAAqBL,EAAY,IAAI,SAEnCM,EAAkBN,EAAY,IAAI,gBAClCO,EAAkBP,EAAY,IAAI,gBAGpCH,EAAK,UAAYW,EAAU,SAASX,EAAK,QAAQ,IACnDQ,EAAWR,EAAK,UAGdQ,IAAa,SAEfD,EAAW,GAAGK,CAAQ,IAAIC,CAAQ,IAAIC,EAAS,GAC/CP,EAAW,GAAGA,CAAQ,4BACbC,IAAa,SACtBD,EAAW,GAAGK,CAAQ,IAAIC,CAAQ,IAGhCN,GACF,GAAAQ,QAAM,OAAOR,CAAQ,EAGvBS,EAAK,cAAehB,CAAI,EAExB,IAAMiB,EAAU,GAAAC,QAAK,QAAQ,QAAQ,IAAI,CAAC,EAEpCC,EAAuB,CAC3B,GAAI,CACF,SAAU,QAAQ,SAClB,aAAc,QAAQ,KACtB,QAAS,GAAAC,QAAG,QAAQ,CACtB,EAEA,UAAArB,EACA,QAAAkB,EACA,gBAAiB,IAAI,OAAOR,CAAe,EAC3C,mBAAoB,IAAI,OAAOC,CAAe,EAC9C,WAAY,CACV,MAAO,CACL,YAAaX,EACb,SAAUkB,CACZ,CACF,EACA,KAAM,CAAC,EACP,KAAAjB,EACA,QAAAE,CACF,EAEIF,EAAK,YACPgB,EAAK,wDAAwD,EAC7DK,GAAoBrB,EAAK,UAAWsB,GAA0BtB,EAAK,UAAW,CAACuB,EAAaC,IAAkB,CAC5GC,EAAWN,EAASI,EAAKC,EAAO,EAAK,CACvC,CAAC,EAEDR,EAAK,oEAAoE,EACzEK,GAAoBrB,EAAK,UAAW0B,GAA8B1B,EAAK,UAAW,CAACuB,EAAaC,IAAkB,CAChHG,EAAUR,EAASI,EAAKC,EAAO,EAAK,CACtC,CAAC,GAGHI,EAAK,EAAE,EACPA,EAAK,IAAIzB,EAAY,IAAI,yBAAyB,EAElD,IAAM0B,EAAsB,CAACC,EAAYC,IAChBA,GAAM,KACpBD,EAAK,KAAO,OAAY,IAAIC,CAAC,IAAID,EAAK,EAAE,IAAIA,EAAK,IAAI,GAAK,IAAIC,CAAC,IAAID,EAAK,IAAI,GAE5EA,EAAK,KAAO,OAAY,GAAGA,EAAK,EAAE,IAAIA,EAAK,IAAI,GAAK,GAAGA,EAAK,IAAI,GAIrEE,EAAW,SAAY,CAC3B,IAAIC,GAA2B9B,EAAY,OAAS,CAAC,GAAG,IAAI+B,EAAoB,EAEhF,QAASH,EAAI,EAAGA,EAAIE,EAAM,OAAQF,IAAK,CACrC,IAAMD,EAAOG,EAAMF,CAAC,EAGpB,MAAI,YAASD,EAAK,EAAE,EAClB,QAASK,EAAIJ,EAAI,EAAGI,EAAIF,EAAM,OAAQE,IAAK,CACzC,IAAMC,EAAYH,EAAME,CAAC,EACzB,GAAIC,EAAU,KAAO,QAAaA,EAAU,KAAON,EAAK,GACtD,MAAM,IAAI,MAAM,gBAAgBA,EAAK,EAAE,kBAAkB,CAE7D,CAGF,GAAI,CAACA,EAAK,MAAQ,EAAEA,EAAK,QAAQO,IAC/B,MAAM,IAAI,MAAM,gCAAgCP,EAAK,IAAI,GAAG,EAG1DA,EAAK,IAAIA,EAAK,oBAAoB,KAAKA,EAAK,EAAE,EAC9CA,EAAK,MAAMA,EAAK,oBAAoB,KAAK,GAAGA,EAAK,IAAI,CAC3D,CAEA,GAAI9B,EAAK,SAAWA,EAAK,QAAQ,OAAS,EAAG,CAC3C,IAAMsC,EAAetC,EAAK,QAE1BgB,EAAK,wDAAwDsB,CAAY,EAAE,EAC3EL,EAAQA,EAAM,OAAQM,GAA6B,CACjD,GAAIC,GAAYF,EAAcC,EAAS,mBAAmB,IAAM,GAC9D,OAAOA,CAEX,CAAC,CACH,CA0CA,GAxCAN,EAAQA,EAAM,OAAQM,GAA6B,CACjD,MAAI,SAAMA,EAAS,IAAI,EAAG,MAAO,GAEjC,GAAM,CAAE,SAAAE,EAAU,aAAAC,EAAc,QAAAC,CAAQ,EAAIJ,EAAS,KACrD,MAAI,YAASE,CAAQ,GACnB,GAAIA,EAAS,WAAW,GAAG,GACzB,GAAIA,EAAS,UAAU,CAAC,IAAMtB,EAAQ,GAAG,SACvC,MAAO,WAGLsB,IAAatB,EAAQ,GAAG,SAC1B,MAAO,GAIb,MAAI,YAASuB,CAAY,GACvB,GAAIA,EAAa,WAAW,GAAG,GAC7B,GAAIA,EAAa,UAAU,CAAC,IAAMvB,EAAQ,GAAG,aAC3C,MAAO,WAGLuB,IAAiBvB,EAAQ,GAAG,aAC9B,MAAO,GAIb,MAAI,YAASwB,CAAO,GAClB,GAAIA,EAAQ,WAAW,GAAG,GACxB,GAAIA,EAAQ,UAAU,CAAC,IAAMxB,EAAQ,GAAG,QACtC,MAAO,WAGLwB,IAAYxB,EAAQ,GAAG,QACzB,MAAO,GAIb,MAAO,EACT,CAAC,EAEGnB,EAAK,YAAcA,EAAK,WAAW,OAAS,EAAG,CACjD,IAAM4C,EAAgB5C,EAAK,WAC3BgB,EAAK,4DAA4D4B,CAAa,EAAE,EAChFX,EAAQA,EAAM,OAAQM,GAA6B,CACjD,GAAIM,GAAeD,EAAeL,EAAS,mBAAmB,IAAM,GAClE,OAAOA,CAEX,CAAC,CACH,CACA,IAAMO,EAAoB9C,EAAK,SAAWA,EAAK,QAAQ,OAAS,EAC1D+C,EAAuB/C,EAAK,YAAcA,EAAK,WAAW,OAAS,EACzE,GAAI8C,GAAqBC,EAAsB,CAC7C,IAAMC,EAAehD,EAAK,QACpBiD,EAAkBjD,EAAK,WAE7BgB,EAAK,wDAAwDgC,CAAY,oBAAoBC,CAAe,EAAE,EAC9GhB,EAAQA,EAAM,OAAQM,GAA6B,CACjD,GACGO,GAAqBN,GAAYQ,EAAeT,EAAS,mBAAmB,IAAM,IAClFQ,GAAwBF,GAAeI,EAAkBV,EAAS,mBAAmB,IAAM,GAE5F,OAAOA,CAEX,CAAC,CACH,CAEAX,EACE,WAAWK,EAAM,IAAI,CAACiB,EAAGnB,IAChBF,EAAoBqB,EAAGnB,CAAC,CAChC,CAAC,EACJ,EAEA,IAAMoB,GAAYlB,EAAM,QAAU,EAClC,QAASF,EAAI,EAAGA,EAAIoB,GAAWpB,IAAK,CAClC,IAAMD,EAAOG,EAAMF,CAAC,EACpB,MAAMqB,GAAmBjC,EAASW,CAAI,EAEtC,IAAMuB,EAAmBxB,EAAoBC,EAAMC,CAAC,EACpD,GAAID,EAAK,UAAY,GAAO,CAC1BF,EAAK;AAAA,yCAA4CyB,CAAgB,EAAE,EACnE,QACF,MACEzB,EAAK;AAAA,aAAgByB,CAAgB,EAAE,EAGrCvB,EAAK,SACPF,EAAKE,EAAK,OAAO,EAGnB,IAAIwB,EAAgB,GACpB,GAAIxB,EAAK,IAAK,CACZ,IAAMyB,EAAU,GAAArC,QAAK,QAAQY,EAAK,GAAG,EACrCF,EAAK,6CAA6C2B,CAAO,EAAE,EAC3DD,EAAgB,GAChB,QAAQ,MAAMC,CAAO,CACvB,CAEA,IAAMC,GAAcnB,GAAWP,EAAK,IAAI,EACxC,GAAI,CACF,MAAM0B,GAAYrC,EAASW,CAAI,CACjC,OAAS2B,EAAG,CACV,GAAI3B,EAAK,UAAY,OACnBd,EAAK,2BAA2BqC,CAAgB,GAAII,CAAC,UAC5C3B,EAAK,UAAY,OAC1B4B,GAAK,iCAAiCL,CAAgB,GAAII,CAAC,MAE3D,OAAMA,CAEV,CAEKpD,IACCiD,GACF1B,EAAK,8CAA8CX,CAAO,EAAE,EAE9D,QAAQ,MAAMA,CAAO,EAEzB,CACF,EAEI0C,EAAW,GACXC,EACJ,GAAI,CACF,MAAM5B,EAAS,CACjB,OAASyB,EAAG,CACVE,EAAW,GACXC,EAAQH,CACV,CAEA,GAAIE,EACF,MAAMC,EAEN,QAAQ,MAAM3C,CAAO,EACrBW,EAAK,IAAIzB,EAAY,IAAI;AAAA,CAAgB,CAE7C,EAEa0D,EAAkB,CAAC9D,EAAmBC,EAAeE,IAAqB,CACrF,IAAID,EAAqC,CAAC,EAEtC6D,EAAiB,GAAA5C,QAAK,QAAQlB,EAAK,MAAM,EAC7C,GAAI,CACFC,EAAmB8D,GAAeD,CAAc,CAClD,OAASL,EAAQ,CACXA,aAAa,MACf,QAAQ,IAAIA,EAAE,OAAO,EAErB,QAAQ,IAAIA,CAAC,EAEf,QAAQ,IAAI,EAAE,EACdvD,EAAQ,KAAK,CACf,CAEA,OAAOJ,GAAYC,EAAWC,EAAMC,EAAkBC,CAAO,CAC/D,EHjSA,IAAM8D,GAAY,GAAAC,QAAK,QAAQ,QAAQ,IAAI,CAAC,EACtCC,GAAcC,GAAM,EAC1BC,EAAgBJ,GAAWE,GAAY,IAAKA,GAAY,OAAO","names":["index_exports","__export","initUsefulTasks","usefulTasks","__toCommonJS","import_path","import_commander","import_path","version","DEFAULT_CONFIG","DEFAULT_USE_CAMEL","CWD_RESTORE","CWD_KEEP","CWD_MODES","LogLevelInfo","LogLevelDebug","LogLevelNone","logLevels","argDesc","v","setup","userArgv","program","version","typedOptions","fixStringArrayArgument","path","value","skipEmptyItem","result","trimedValue","import_path","import_fs","import_path","import_json5","import_debug","import_zod","import_os","DEFAULT_REPLACE_REGEX","newTaskSchema","type","obj","TaskBaseSchema","GlobFilterSchema","GlobFiltersSchema","newTaskSchemaWithGlobFilters","convertToRuntimeTask","task","TaskTypeSchema","BasePlatforms","Platforms","item","BaseArchitectures","Architectures","BaseMachines","Machines","os","TaskWhenSchema","TaskBaseSchema","value","TaskGitSetupSchema","newTaskSchema","TaskSymlinkSchema","TaskTerminalCommandSchema","TaskSetVarSchema","newTaskSchemaWithGlobFilters","TaskEnvVarSchema","TaskOutputTargetsSchema","TaskOutputSchema","TaskFsCopyOptionsSchema","TaskFsCopySchema","TaskFsDeleteSchema","TaskFsMakeDirSchema","TaskSubTasksSchema","RegexDataSchema","TaskContentFindSchema","TaskContentReplaceSchema","TaskSchema","TasksConfigSchema","logLevels","DEFAULT_REPLACE_REGEX","CWD_RESTORE","CWD_KEEP","LOG_TAG","TAG_DEBUG","TAG_INFO","TAG_WARN","VAR_FROM_ARGUMENT_PREFIX","ENV_VAR_FROM_ARGUMENT_PREFIX","logw","debug","TAG_WARN","logi","TAG_INFO","logv","TAG_DEBUG","import_compat","loadFileOrThrow","filePath","logv","fs","loadJson","parseJson","content","json5","loadJsonConfig","configJson","filePathDir","path","extendsFilePath","convertOrNotHyphenTextToCamelText","text","flag","result","textArr","i","word","containsTag","elements","tags","el","tag","containsAllTag","contained","checkEmptyStringOrThrow","name","value","checkLegacyUsage","task","key","logw","checkType","allowedTypes","checkTypeOrThrow","valueType","ENV_LINE","parseLines","src","obj","lines","match","maybeQuote","throwInvalidParamError","resolveStringArray","val","defaultValue","v","import_debug","import_os","import_compat","replaceVarLiterals","context","task","anyTypeTask","key","valueOfKey","envVarHandler","value","execArr","isMatched","matchedStr","varPath","matchedVar","valuePrefix","valueReplace","valueSuffix","varHandlerResult","envVarHandlerResult","logv","searchExtraKeyValue","extraArgs","fmt","convertToCamelKeys","callback","currentVarName","useNextElementAsVar","extraArg","equalMarkIndex","varName","convertOrNotHyphenTextToCamelText","setTaskVar","skipForExists","setEnvVar","valueType","import_string_argv","handleSubTasks","context","task","subArgv","stringArgv","setupResult","setup","initUsefulTasks","import_fs","import_path","import_fs","import_glob","processWithGlobSync","handler","cwd","includes","excludes","skipDirs","includeAllIfNonFilters","fs","nodir","hasIncludes","hasExcludes","item","runFindAndReplaceWithRegex","content","find","replace","repeat","text","runFindAndReplaceWithText","isRegexData","v","findAndReplaceWithFile","path","replaceFunc","logv","fs","newContent","handleContentReplace","context","task","throwInvalidParamError","loop","regexData","processWithGlobSync","items","f","itemPath","resolveStringArray","import_fs_extra","handleMkdir","context","task","checkTypeOrThrow","logv","import_fs","import_path","import_fs_extra","runDelete","path","logv","fse","handleFsDelete","context","task","fs","processWithGlobSync","items","f","resolveStringArray","import_path","import_fs_extra","runCopy","src","dst","options","logv","fse","handleFsCopy","context","task","conflict","overwrite","cpOpt","processWithGlobSync","items","f","from","path","to","resolveStringArray","import_fs","import_fs_extra","import_path","handleOutput","context","task","text","target","targetPath","resolvedPath","path","dir","fs","err","fd","e","import_fs_extra","import_path","import_es_toolkit","handleEnvVar","context","task","checkLegacyUsage","isFallback","map","logv","parseLines","key","setEnvVar","checkTypeOrThrow","src","parser","runFunc","filePath","varsPath","path","obj","content","loadFileOrThrow","parseJson","e","finalObj","processWithGlobSync","items","itemPath","fse","resolveStringArray","import_fs","import_path","handleSetVar","context","task","checkLegacyUsage","checkTypeOrThrow","checkEmptyStringOrThrow","isFallback","value","setTaskVar","src","parser","logv","runFunc","filePath","varsPath","path","obj","content","loadFileOrThrow","parseJson","e","parseLines","processWithGlobSync","items","itemPath","fs","resolveStringArray","import_child_process","handleTerminalCommand","context","task","logv","import_path","import_fs","import_fs_extra","handleFsSymlink","context","task","target","path","dstPath","fs","lstat","logv","fse","import_fs","import_path","import_simple_git","handleGitSetup","context","task","localPath","path","fs","simpleGit","git","hasLocalBranch","branchLocal","b","branch","startPoint","handlerMap","handleGitSetup","handleTerminalCommand","handleSetVar","handleOutput","handleFsSymlink","handleFsCopy","handleFsDelete","handleMkdir","handleEnvVar","handleSubTasks","handleContentReplace","import_es_toolkit","usefulTasks","originCwd","opts","tasksConfigInput","program","tasksConfig","TasksConfigSchema","cwdModeIsKeep","CWD_KEEP","debugPat","logLevel","varReplaceRegex","envReplaceRegex","logLevels","TAG_WARN","TAG_INFO","TAG_DEBUG","debug","logv","baseCwd","path","context","os","searchExtraKeyValue","VAR_FROM_ARGUMENT_PREFIX","key","value","setTaskVar","ENV_VAR_FROM_ARGUMENT_PREFIX","setEnvVar","logi","getTaskRepresentStr","task","i","runTasks","tasks","convertToRuntimeTask","j","otherTask","handlerMap","excludeItems","taskItem","containsTag","platform","architecture","machine","excludesItems","containsAllTag","hasIncludeFilters","hasIncludeCTAFilters","includeItems","includeCtaItems","v","taskCount","replaceVarLiterals","taskRepresentStr","cwdHasChanges","taskCwd","taskHandler","e","logw","hasError","error","initUsefulTasks","configFilePath","loadJsonConfig","originCwd","path","setupResult","setup","initUsefulTasks"]}