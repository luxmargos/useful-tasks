{"version":3,"sources":["../src/index.ts","../src/build_cli_parser.ts","../src/useful_tasks.ts","../src/utils.ts","../src/loggers.ts","../src/task_data.ts","../src/task_utils.ts","../src/handler_sub_tasks.ts","../src/handlers.ts","../src/glob_handler.ts","../src/handler_map.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport path from \"path\";\nimport { setup } from \"./build_cli_parser\";\nimport { usefulTasks } from \"./useful_tasks\";\nexport { usefulTasks } from \"./useful_tasks\";\n\nconst originCwd = path.resolve(process.cwd());\nconst setupResult = setup();\nusefulTasks(originCwd, setupResult.opt, setupResult.program);\n","import { Command } from \"commander\";\nimport path from \"path\";\n\nexport const DEFAULT_CONFIG = \"useful_tasks.json\";\nexport const DEFAULT_USE_CAMEL = true;\n\nexport const CwdRestore = \"restore\";\nexport const CwdKeep = \"keep\";\n\nexport const cwdModes = [CwdRestore, CwdKeep] as const;\ntype CwdModeTuple = typeof cwdModes;\nexport type CwdMode = CwdModeTuple[number];\n\nconst LogLevelInfo = \"info\";\nconst LogLevelDebug = \"debug\";\nconst LogLevelNone = \"none\";\nexport const logLevels = [LogLevelNone, LogLevelInfo, LogLevelDebug] as const;\ntype LogLevelTuple = typeof logLevels;\nexport type LogLevel = LogLevelTuple[number];\n\nexport interface Options {\n  cwd?: string;\n  config: string;\n  include?: string[];\n  includeCta?: string[];\n  exclude?: string[];\n  excludeCta?: string[];\n  camelKeys: boolean;\n  cwdMode?: CwdMode;\n  cwdModeIsContinue?: boolean;\n  logLevel?: LogLevel;\n  extraArgs?: string[];\n}\n\nconst argDesc = {\n  cwdMode: `Choose between ${cwdModes\n    .map((v) => `'${v}'`)\n    .join(\n      \" or \"\n    )}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${CwdRestore}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${CwdKeep}' mode, the CWD will remain unchanged.`,\n};\n\nexport const setup = (userArgv?: string[]) => {\n  // console.log('cwd', process.cwd());\n  // console.log('argv', process.argv);\n\n  const program = new Command();\n  program\n    .name(\"useful-tasks\")\n    .version(process.env.npm_package_version!)\n    .option(\"--cwd <string>\", \"Change working directory\")\n    .option(\"-c, --config <string>\", \"A path of json configuraion\", DEFAULT_CONFIG)\n    .option(\n      \"-i, --include <items>\",\n      \"Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02\"\n    )\n    .option(\n      \"-a, --include-cta <items>\",\n      \"Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02\"\n    )\n    .option(\n      \"-e, --exclude <items>\",\n      \"Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02\"\n    )\n    .option(\n      \"-x, --exclude-cta <items>\",\n      \"Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02\"\n    )\n    .option(\n      \"--camel-keys <boolean>\",\n      'Specify whether to use camel case for the key of the variable. If the value is true, the paramter \"--var-my-key\" will be converted to \"myKey\" otherwise it will be \"my-key\"',\n      DEFAULT_USE_CAMEL\n    )\n    .option(\"--cwd-mode <string>\", argDesc.cwdMode, CwdRestore)\n    .option(\n      \"--log-level <string>\",\n      `Specify the logging level as ${logLevels.join(\n        \",\"\n      )}. This parameter takes higher priority than the 'json' configuration.`\n    )\n    .allowUnknownOption(true);\n\n  if (userArgv !== undefined) {\n    program.parse(userArgv, { from: \"user\" });\n  } else {\n    program.parse();\n  }\n\n  const opts = program.opts();\n  // console.log(opts);\n\n  const typedOptions = opts as Options;\n  typedOptions.include = fixStringArrayArgument(typedOptions.include);\n  typedOptions.includeCta = fixStringArrayArgument(typedOptions.includeCta);\n  typedOptions.exclude = fixStringArrayArgument(typedOptions.exclude);\n  typedOptions.excludeCta = fixStringArrayArgument(typedOptions.excludeCta);\n\n  typedOptions.cwdModeIsContinue = typedOptions.cwdMode === CwdKeep;\n\n  if (typedOptions.camelKeys !== undefined && typeof typedOptions.camelKeys === \"string\") {\n    let v: string = typedOptions.camelKeys;\n    v = v.trim().toLowerCase();\n    if (v === \"false\" || v === \"0\" || v === \"no\") {\n      typedOptions.camelKeys = false;\n    } else if (v === \"true\" || v === \"1\" || v === \"yes\") {\n      typedOptions.camelKeys = true;\n    } else {\n      typedOptions.camelKeys = DEFAULT_USE_CAMEL;\n    }\n  }\n  typedOptions.extraArgs = [...(program.args ?? [])];\n\n  // console.log(`Using options : ${JSON.stringify(typedOptions, undefined, 2)}`);\n  // console.log(`Extra arguments`, program.args);\n\n  if (typedOptions.cwd) {\n    process.chdir(path.resolve(typedOptions.cwd));\n  }\n\n  // console.log(\"######################################################################\")\n\n  return { opt: typedOptions, program };\n};\n\nconst fixStringArrayArgument = (value: string | string[] | undefined, skipEmptyItem: boolean = true) => {\n  if (!value) {\n    return [];\n  }\n\n  if (typeof value === \"string\") {\n    const result: string[] = [];\n    const arr = value.split(\",\");\n    arr.forEach((value) => {\n      const trimedValue = value.trim();\n      if (skipEmptyItem) {\n        if (trimedValue.length > 0) {\n          result.push(trimedValue);\n        }\n      } else {\n        result.push(trimedValue);\n      }\n    });\n    return result;\n  }\n\n  return [];\n};\n","import path from \"path\";\nimport { LogLevel, Options, logLevels } from \"./build_cli_parser\";\nimport { containsAllTag, containsTag, loadJsonConfig } from \"./utils\";\nimport debug from \"debug\";\nimport {\n  Config,\n  TAG_DEBUG,\n  Task,\n  TaskContext,\n  DEFAULT_REPLACE_REGEX,\n  VAR_FROM_ARGUMENT_PREFIX,\n  ENV_VAR_FROM_ARGUMENT_PREFIX,\n  LOG_TAG,\n  TAG_INFO,\n  TAG_WARN,\n} from \"./task_data\";\nimport { applyVariables, searchExtraKeyValue, setTaskVar, setEnvVar } from \"./task_utils\";\nimport { Command } from \"commander\";\nimport { handlerMap } from \"./handler_map\";\nimport { logi, logv } from \"./loggers\";\n\nexport const usefulTasks = (originCwd: string, opt: Options, program: Command) => {\n  let tasksConfig: Config = {};\n\n  let configFilePath = path.resolve(opt.config);\n  try {\n    tasksConfig = loadJsonConfig(configFilePath);\n  } catch (e: any) {\n    if (e instanceof Error) {\n      console.log(e.message);\n    } else {\n      console.log(e);\n    }\n    console.log(\"\");\n    program.help();\n  }\n\n  let debugPat: string | undefined;\n\n  let logLevel: LogLevel = \"info\";\n  let replaceRegex = DEFAULT_REPLACE_REGEX;\n  if (tasksConfig.env && typeof tasksConfig.env === \"object\") {\n    const env = tasksConfig.env;\n\n    if (env.verbose || env.verboseGit) {\n      logLevel = \"debug\";\n    }\n\n    if (env.logLevel && logLevels.includes(env.logLevel)) {\n      logLevel = env.logLevel;\n    }\n\n    if (env.replaceRegex) {\n      replaceRegex = env.replaceRegex;\n    }\n  }\n\n  //cli argument can overwrite json's logLeve\n  if (opt.logLevel && logLevels.includes(opt.logLevel)) {\n    logLevel = opt.logLevel;\n  }\n\n  if (logLevel === \"debug\") {\n    // debugPat = `${LOG_TAG}:*`;\n    debugPat = `${TAG_WARN},${TAG_INFO},${TAG_DEBUG}`;\n    debugPat = `${debugPat},simple-git,simple-git:*`;\n  } else if (logLevel === \"info\") {\n    debugPat = `${TAG_WARN},${TAG_INFO}`;\n  }\n\n  if (debugPat) {\n    debug.enable(debugPat);\n  }\n\n  logv(`CLI Options`, opt);\n\n  if (typeof replaceRegex !== \"string\") {\n    throw new Error(`replaceRegex '${replaceRegex}'  must be a string`);\n  }\n  if (replaceRegex.length < 1) {\n    throw new Error(`replaceRegex '${replaceRegex}' cannot be empty`);\n  }\n  if (replaceRegex.indexOf(\"(\") < 0 || replaceRegex.indexOf(\")\") < 0) {\n    throw new Error(`replaceRegex '${replaceRegex}' must contain regex group express '(' and ')'`);\n  }\n\n  const baseCwd = path.resolve(process.cwd());\n\n  const context: TaskContext = {\n    originCwd,\n    baseCwd,\n    replaceRegex: new RegExp(replaceRegex),\n    vars: {\n      __env: {\n        cwd_startup: originCwd,\n        cwd_base: baseCwd,\n      },\n    },\n  };\n\n  if (opt.extraArgs) {\n    logv(\"Setting up the variables from the additional arguments\");\n    searchExtraKeyValue(opt.extraArgs, VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key: string, value: string) => {\n      setTaskVar(context, key, value, false);\n    });\n\n    logv(\"Setting up the environment variables from the additional arguments\");\n    searchExtraKeyValue(opt.extraArgs, ENV_VAR_FROM_ARGUMENT_PREFIX, opt.camelKeys, (key: string, value: string) => {\n      setEnvVar(context, key, value, false);\n    });\n  }\n\n  logi(\"\");\n  logi(`[${tasksConfig.name}] Start task processing`);\n\n  const getTaskRepresentStr = (task: Task, i?: number) => {\n    if (i !== undefined && i !== null) {\n      return task.id !== undefined ? `[${i}]${task.id}/${task.type}` : `[${i}]${task.type}`;\n    } else {\n      return task.id !== undefined ? `${task.id}/${task.type}` : `${task.type}`;\n    }\n  };\n\n  const runTasks = async () => {\n    let tasks: Array<Task> = tasksConfig.tasks ?? [];\n\n    for (let i = 0; i < tasks.length; i++) {\n      const task = tasks[i];\n\n      // Validate task IDs\n      if (task.id !== undefined && task.id !== null) {\n        if (typeof task.id !== \"string\") {\n          throw new Error(`The task id must be a 'string' type`);\n        }\n\n        if (task.id.length < 1) {\n          throw new Error(`The task id cannot be empty`);\n        }\n\n        for (let j = i + 1; j < tasks.length; j++) {\n          const otherTask = tasks[j];\n          if (otherTask.id !== undefined && otherTask.id === task.id) {\n            throw new Error(`The task id '${task.id}' must be unique`);\n          }\n        }\n      }\n\n      if (!task.type || !(task.type in handlerMap)) {\n        throw new Error(`Found the invalid task type '${task.type}'`);\n      }\n\n      task.__compare__elements = [];\n      if (task.id) {\n        task.id = task.id.trim();\n        task.__compare__elements.push(task.id.trim());\n      }\n      if (task.tags) {\n        const printInvalidTags = (tags: any) => {\n          logv(`Ignoring invalid tags '${tags}'`);\n        };\n        if (typeof task.tags === \"string\") {\n          if (task.tags.length > 0) {\n            task.tags = task.tags.trim();\n            task.__compare__elements.push(task.tags);\n          } else {\n            printInvalidTags(task.tags);\n          }\n        } else if (Array.isArray(task.tags)) {\n          task.tags = task.tags.map((value: string) => value.trim());\n          for (const tag of task.tags) {\n            if (typeof tag === \"string\" && tag.length > 0) {\n              task.__compare__elements.push(tag);\n            } else {\n              printInvalidTags(tag);\n            }\n          }\n        } else {\n          printInvalidTags(task.tags);\n        }\n      }\n    }\n\n    if (opt.exclude && opt.exclude.length > 0) {\n      const excludeItems = opt.exclude;\n\n      logv(`Excluding tasks by specified IDs or Tags : --exclude=${excludeItems}`);\n      tasks = tasks.filter((taskItem: Task, index: number, array: Task[]) => {\n        if (containsTag(excludeItems, taskItem.__compare__elements) === false) {\n          return taskItem;\n        }\n      });\n    }\n    if (opt.excludeCta && opt.excludeCta.length > 0) {\n      const excludesItems = opt.excludeCta;\n\n      logv(`Excluding tasks by specified IDs or Tags : --exclude-cta=${excludesItems}`);\n      tasks = tasks.filter((taskItem: Task, index: number, array: Task[]) => {\n        if (containsAllTag(excludesItems, taskItem.__compare__elements) === false) {\n          return taskItem;\n        }\n      });\n    }\n    const hasIncludeFilters = opt.include && opt.include.length > 0;\n    const hasIncludeCTAFilters = opt.includeCta && opt.includeCta.length > 0;\n    if (hasIncludeFilters || hasIncludeCTAFilters) {\n      const includeItems = opt.include;\n      const includeCtaItems = opt.includeCta;\n\n      logv(`Including tasks by specified IDs or Tags : --include=${includeItems} / --include-cta=${includeCtaItems}`);\n      tasks = tasks.filter((taskItem: Task, index: number, array: Task[]) => {\n        if (\n          (hasIncludeFilters && containsTag(includeItems!, taskItem.__compare__elements) === true) ||\n          (hasIncludeCTAFilters && containsAllTag(includeCtaItems!, taskItem.__compare__elements) === true)\n        ) {\n          return taskItem;\n        }\n      });\n    }\n\n    logi(\n      `Tasks : ${tasks.map((v, i) => {\n        return getTaskRepresentStr(v, i);\n      })}`\n    );\n\n    const taskCount = tasks.length ?? 0;\n    for (let i = 0; i < taskCount; i++) {\n      const task = tasks[i];\n      await applyVariables(context, task);\n\n      const taskRepresentStr = getTaskRepresentStr(task, i);\n      if (task.enabled === false) {\n        logi(`\\n### Skip the task without execution => ${taskRepresentStr}`);\n        continue;\n      } else {\n        logi(`\\n### Task : ${taskRepresentStr}`);\n      }\n\n      if (task.comment) {\n        logi(task.comment);\n      }\n\n      let cwdHasChanges = false;\n      if (task.cwd) {\n        const taskCwd = path.resolve(task.cwd);\n        logi(`Changing the current working directory => ${taskCwd}`);\n        cwdHasChanges = true;\n        process.chdir(taskCwd);\n      }\n\n      const taskHandler = handlerMap[task.type];\n      await taskHandler(context, task);\n\n      if (!opt.cwdModeIsContinue) {\n        if (cwdHasChanges) {\n          logi(`Restoring the current working directory => ${baseCwd}`);\n        }\n        process.chdir(baseCwd);\n      }\n    }\n  };\n\n  runTasks()\n    .then(() => {})\n    .catch((reason: any) => {\n      throw reason;\n    })\n    .finally(() => {\n      process.chdir(baseCwd);\n      logi(`[${tasksConfig.name}] Tasks done\\n`);\n    });\n};\n","import fs from \"fs\";\nimport path from \"path\";\nimport json5 from \"json5\";\nimport { Task } from \"task_data\";\nimport { logw, logv } from \"./loggers\";\n\nexport const loadFileOrThrow = (filePath: string) => {\n  logv(`Loading file: ${filePath}`);\n  if (!fs.existsSync(filePath)) {\n    throw new Error(`ERROR: The Path '${filePath}' does not exists!`);\n  }\n\n  return fs.readFileSync(filePath, { encoding: \"utf-8\" });\n};\n\nexport const loadJson = (filePath: string) => {\n  return parseJson(loadFileOrThrow(filePath));\n};\n\nexport const parseJson = (content: string) => json5.parse(content);\n\nexport const loadJsonConfig = (filePath: string) => {\n  let configJson = loadJson(filePath);\n  if (configJson.extends) {\n    const filePathDir = path.dirname(filePath);\n    const extendsFilePath = path.resolve(filePathDir, configJson.extends);\n    configJson = Object.assign({}, configJson, loadJsonConfig(extendsFilePath));\n  }\n\n  return configJson;\n};\n\nexport const convertOrNotHyphenTextToCamelText = (text: string, flag: boolean) => {\n  if (!flag) {\n    return text;\n  }\n\n  let result = \"\";\n  let textArr = text.split(\"-\");\n  for (let i = 0; i < textArr.length; i++) {\n    let word = textArr[i];\n    if (i === 0) {\n      result = word;\n    } else {\n      if (word.length > 0) {\n        word = `${word[0].toUpperCase()}${word.substring(1)}`;\n      }\n      result = `${result}${word}`;\n    }\n  }\n  return result;\n};\n\nexport const containsTag = (elements: string[], tags: string[]) => {\n  if (elements.length < 1) {\n    return false;\n  }\n\n  for (const el of elements) {\n    for (const tag of tags) {\n      if (el === tag) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nexport const containsAllTag = (elements: string[], tags: string[]) => {\n  if (elements.length < 1) {\n    return false;\n  }\n  for (const el of elements) {\n    let contained = false;\n    for (const tag of tags) {\n      if (tag === el) {\n        contained = true;\n        break;\n      }\n    }\n    if (!contained) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const checkEmptyStringOrThrow = (name: string, value: string) => {\n  if (!value) {\n    throw new Error(`The '${name}' property must not be empty.`);\n  }\n};\n\nexport const checkLegacyUsage = (task: Task, key: string) => {\n  if ((task as any)[key] !== undefined) logw(`The key '${key}' has been deprecated.`);\n};\n\ntype TypeString = \"string\" | \"number\" | \"boolean\" | \"undefined\" | \"object\" | \"function\" | \"bigint\" | \"symbol\";\nexport const checkType = (value: any, allowedTypes: TypeString[]): boolean => {\n  if (allowedTypes.length <= 0) return true;\n  return allowedTypes.includes(typeof value);\n};\n\nexport const checkTypeOrThrow = (name: string, value: any, allowedTypes: TypeString[]): boolean => {\n  if (checkType(value, allowedTypes)) {\n    return true;\n  }\n\n  const valueType = typeof value;\n  throw new Error(\n    `The '${name}' property has an invalid type '${valueType}' with the value '${value}'. The allowed types are [${allowedTypes}].`\n  );\n};\n\nconst ENV_LINE =\n  /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/gm;\n\n// Parse src into an Object\nexport function parseLines(src: string) {\n  const obj: any = {};\n\n  // Convert buffer to string\n  let lines = src.toString();\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/gm, \"\\n\");\n\n  let match: RegExpExecArray | null;\n  while ((match = ENV_LINE.exec(lines)) != null) {\n    const key = match[1];\n    // Default undefined or null to empty string\n    let value = match[2] || \"\";\n    // Remove whitespace\n    value = value.trim();\n    // Check if double quoted\n    const maybeQuote = value[0];\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/gm, \"$2\");\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, \"\\n\");\n      value = value.replace(/\\\\r/g, \"\\r\");\n    }\n\n    // Add to object\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","import debug from \"debug\";\nimport { TAG_DEBUG, TAG_INFO, TAG_WARN } from \"./task_data\";\n\nexport const logw = debug(TAG_WARN);\nexport const logi = debug(TAG_INFO);\nexport const logv = debug(TAG_DEBUG);\n","import { LogLevel } from \"./build_cli_parser\";\n\nexport interface TaskContext {\n  originCwd: string;\n  baseCwd: string;\n  replaceRegex: RegExp;\n  vars: any;\n}\n\nexport const allTaskTypes = [\n  \"git-repo-prepare\",\n  \"symlink\",\n  \"cmd\",\n  \"set-var\",\n  \"output\",\n  \"fs-copy\",\n  \"fs-del\",\n  \"fs-mkdir\",\n  \"env-var\",\n  \"sub-tasks\",\n  \"content-replace\",\n] as const;\ntype TasksTuple = typeof allTaskTypes;\nexport type TaskType = TasksTuple[number];\n\nexport interface Task {\n  type: TaskType;\n  id?: string;\n  tags?: string | string[];\n  cwd?: string;\n  enabled?: boolean;\n  comment?: string;\n  __compare__elements: string[];\n\n  //TODO:Implement allowError\n  /** The process will not be interrupted even if errors are caught from this task. */\n  allowError?: boolean;\n}\n\nexport interface TaskGitCheckout extends Task {\n  /** Executable git binary */\n  binary?: string;\n  url?: string;\n  localPath: string;\n  branch?: string;\n  startPoint?: string;\n  updateSubmodules?: Array<string> | string | boolean;\n}\n\nexport interface TaskSymlink extends Task {\n  target: string;\n  path: string;\n  linkType?: \"dir\" | \"file\" | \"junction\";\n  forced?: boolean;\n}\n\nexport interface TaskTerminalCommand extends Task {\n  cmd: string;\n  shell?: string;\n}\n\nexport interface TaskSetVar extends Task, GlobFilters {\n  key: string;\n  value?: string | number | boolean | any;\n  src?: string;\n  parser?: \"json\" | \"lines\" | \"string\" | \"auto\";\n  /** If the variable already exists, assigning will be skipped */\n  isFallback?: boolean;\n}\n\nexport interface TaskEnvVar extends Task, GlobFilters {\n  value?: any;\n  src?: string;\n  parser?: \"json\" | \"lines\" | \"auto\";\n  /** If the environment variable already exists, assigning will be skipped */\n  isFallback?: boolean;\n}\n\nexport type TaskOutputTargets = \"console\" | \"file-write\" | \"file-append\" | \"c\" | \"fw\" | \"fa\";\nexport interface TaskOutput extends Task {\n  text: string;\n  target: TaskOutputTargets;\n  path?: string;\n}\n\nexport interface GlobFilters {\n  include?: string | string[];\n  exclude?: string | string[];\n}\n\nexport type TaskFsCopyOptions = {\n  conflict?: \"overwrite\" | \"skip\";\n};\n\nexport interface TaskFsCopy extends Task, GlobFilters {\n  src: string;\n  dest: string;\n  options?: TaskFsCopyOptions;\n}\n\nexport interface TaskFsDelete extends Task, GlobFilters {\n  path: string;\n}\n\nexport interface TaskFsMakeDir extends Task {\n  path: string;\n}\n\nexport interface TaskSubTasks extends Task {\n  args: string;\n}\n\nexport interface RegexData {\n  pattern: string;\n  flags?: string;\n}\n\nexport interface TaskContentReplace extends Task, GlobFilters {\n  /**\n   * If the task includes 'include' or 'exclude', it will be handled as a directory.\n   * Otherwise, it will be processed as a file.\n   */\n  path: string;\n\n  find: string | RegexData;\n  replace: string;\n  loop?: number;\n}\n\nexport interface Config {\n  name?: string;\n\n  env?: {\n    logLevel?: LogLevel;\n    /** @deprecated */\n    verbose?: boolean;\n    /** @deprecated */\n    verboseGit?: boolean;\n    replaceRegex?: string;\n  };\n  tasks?: Array<Task>;\n}\n\nexport const LOG_TAG = \"useful-tasks\";\nexport const TAG_DEBUG = `${LOG_TAG}:debug`;\nexport const TAG_INFO = `${LOG_TAG}:info`;\nexport const TAG_WARN = `${LOG_TAG}:warn`;\n\n/** e.g. ${value.key} */\nexport const DEFAULT_REPLACE_REGEX = \"\\\\$\\\\{([a-zA-Z0-9\\\\.\\\\-_]*)\\\\}\";\n\nexport const VAR_FROM_ARGUMENT_PREFIX = \"--var-\";\nexport const ENV_VAR_FROM_ARGUMENT_PREFIX = \"--env-\";\n","import { logv } from \"./loggers\";\nimport { Task, TaskContext } from \"./task_data\";\nimport { convertOrNotHyphenTextToCamelText, loadJson } from \"./utils\";\n\nexport const applyVariables = async (context: TaskContext, task: Task) => {\n  const anyTypeTask: any = task as any;\n  for (const key of Object.keys(anyTypeTask)) {\n    if (typeof key !== \"string\") {\n      continue;\n    }\n\n    if (key === \"id\" || key === \"tags\") {\n      continue;\n    }\n\n    if (anyTypeTask[key] !== undefined && typeof anyTypeTask[key] === \"string\") {\n      let valueOfKey: string = anyTypeTask[key];\n      while (true) {\n        const match = context.replaceRegex.exec(valueOfKey);\n        if (match === null || match === undefined) {\n          break;\n        }\n\n        const matchedStr = match[0];\n        const varPath = match[1];\n\n        let currentVar = context.vars;\n        if (varPath.length > 0) {\n          const varPaths = varPath.split(\".\");\n          for (let i = 0; i < varPaths.length; i++) {\n            const varEl = varPaths[i];\n            if (currentVar.hasOwnProperty(varEl)) {\n              currentVar = currentVar[varEl];\n            } else {\n              throw new Error(`The value of ${varPath} could not be found!`);\n            }\n          }\n        }\n\n        const valuePrefix = valueOfKey.substring(0, match.index);\n        const valueReplace = `${currentVar}`;\n        const valueSuffix = valueOfKey.substring(match.index + matchedStr.length);\n        valueOfKey = `${valuePrefix}${valueReplace}${valueSuffix}`;\n        logv(`Variable injection: '${key}'=>'${valueOfKey}'`);\n      }\n\n      anyTypeTask[key] = valueOfKey;\n    }\n  }\n};\n\nexport const searchExtraKeyValue = (\n  extraArgs: string[],\n  fmt: string,\n  convertToCamelKeys: boolean,\n  callback: (key: string, value: string) => void\n) => {\n  let currentVarName: string | undefined;\n  let useNextElementAsVar: boolean = false;\n\n  for (let extraArg of extraArgs) {\n    const arg = extraArg.trim();\n    if (arg === \"--\") {\n      logv(\"Stop parsing by '--'\");\n      break;\n    }\n\n    if (useNextElementAsVar && currentVarName) {\n      const value = extraArg.startsWith(\"-\") ? \"\" : extraArg;\n      callback(currentVarName, value);\n      currentVarName = undefined;\n      useNextElementAsVar = false;\n    } else {\n      const prefixIndex = extraArg.indexOf(fmt);\n      if (prefixIndex >= 0) {\n        const equalMarkIndex = extraArg.indexOf(\"=\");\n        if (equalMarkIndex >= 0) {\n          const varName = convertOrNotHyphenTextToCamelText(\n            extraArg.substring(fmt.length, equalMarkIndex),\n            convertToCamelKeys\n          );\n          const value = extraArg.substring(equalMarkIndex + 1);\n          callback(varName, value);\n        } else {\n          currentVarName = convertOrNotHyphenTextToCamelText(extraArg.substring(fmt.length), convertToCamelKeys);\n          useNextElementAsVar = true;\n        }\n      }\n    }\n  }\n};\n\nexport const setTaskVar = (context: TaskContext, key: string, value: any, skipForExists: boolean) => {\n  if (skipForExists && context.vars[key] !== undefined) {\n    logv(`Skips assigning the variable ${key}=${value} because it already exists.`);\n    return;\n  }\n\n  logv(`Sets the variable ${key}=${value}`);\n  context.vars[key] = value;\n};\n\nexport const setEnvVar = (context: TaskContext, key: string, value: any, skipForExists: boolean) => {\n  var valueType = typeof value;\n  if (valueType !== \"string\" && valueType !== \"number\" && valueType !== \"boolean\") {\n    logv(`Ignoring the invalid typed(${valueType}) environment variable ${key}=${value}`);\n  } else {\n    const stringVal = String(value);\n    if (stringVal.length < 1) {\n      logv(`Ignoring the invalid environment variable ${key}=${value}`);\n    } else {\n      if (skipForExists && process.env[key] !== undefined) {\n        logv(`Skips assigning the environment variable ${key}=${value} because it already exists.`);\n        return;\n      }\n\n      logv(`Sets the environment variable ${key}=${value}`);\n      process.env[key] = String(value);\n    }\n  }\n};\n","import stringArgv from \"string-argv\";\nimport { TaskContext, TaskSubTasks } from \"./task_data\";\nimport { usefulTasks } from \"./useful_tasks\";\nimport { setup } from \"./build_cli_parser\";\n\nexport const handleSubTasks = async (context: TaskContext, task: TaskSubTasks) => {\n  if (!task.args || typeof task.args !== \"string\") {\n    throw new Error(`Found missing or invalid property 'args' that is required`);\n  }\n\n  const subArgv = stringArgv(task.args);\n  const setupResult = setup(subArgv);\n  usefulTasks(context.originCwd, setupResult.opt, setupResult.program);\n};\n","import fs from \"fs\";\nimport { execSync } from \"child_process\";\nimport path from \"path\";\nimport { CheckRepoActions, ResetMode, simpleGit } from \"simple-git\";\nimport { CopyOptionsSync, CopySyncOptions, copyFileSync, copySync, mkdirpSync, removeSync } from \"fs-extra\";\nimport {\n  TaskContext,\n  TaskOutput,\n  TaskSetVar,\n  TaskGitCheckout,\n  TaskSymlink,\n  TaskTerminalCommand,\n  TaskOutputTargets,\n  TaskFsCopy,\n  TaskFsDelete,\n  TaskEnvVar,\n  TaskContentReplace,\n  RegexData,\n  TaskFsMakeDir,\n} from \"./task_data\";\nimport {\n  checkEmptyStringOrThrow,\n  checkLegacyUsage,\n  checkTypeOrThrow,\n  loadFileOrThrow,\n  loadJson,\n  parseJson,\n  parseLines,\n} from \"./utils\";\nimport json5 from \"json5\";\nimport { setEnvVar, setTaskVar } from \"./task_utils\";\nimport { logi, logv } from \"./loggers\";\nimport { processWithGlobSync } from \"./glob_handler\";\n\nconst throwInvalidParamError = <T, K extends keyof T>(obj: T, key: K) => {\n  throw new Error(`The parameter '${String(key)}' has an invalid value ${obj[key]}`);\n};\n\nexport const handleGitRepoSetup = async (context: TaskContext, task: TaskGitCheckout) => {\n  const localPath = path.resolve(task.localPath);\n\n  if (!fs.existsSync(localPath)) {\n    fs.mkdirSync(localPath, { recursive: true });\n  }\n\n  if (fs.readdirSync(localPath).length === 0) {\n    if (task.url) {\n      await simpleGit().clone(task.url, localPath);\n    }\n  }\n\n  const git = simpleGit(localPath, { binary: task.binary });\n\n  const isGitRepo = await git.checkIsRepo(CheckRepoActions.IS_REPO_ROOT);\n  if (!isGitRepo) {\n    throw Error(`${localPath} is not a git repository!!!`);\n  }\n\n  if (task.updateSubmodules) {\n    await git.submoduleInit();\n    await git.submoduleUpdate();\n  } else {\n    // const submodules = task.updateSubmodules ?? [];\n    // for(var submod of submodules){\n    // }\n  }\n\n  await git.fetch();\n\n  if (task.branch) {\n    let hasLocalBranch = false;\n    const branchLocal = await git.branchLocal();\n    for (var b of branchLocal.all) {\n      if (b === task.branch) {\n        hasLocalBranch = true;\n        break;\n      }\n    }\n\n    const branch = task.branch ?? \"\";\n    const startPoint: string = task.startPoint ?? \"\";\n\n    if (!hasLocalBranch) {\n      await git.checkoutBranch(branch, startPoint);\n    } else {\n      if (branchLocal.current !== task.branch) {\n        await git.checkout(branch);\n      }\n      await git.reset(ResetMode.HARD, [startPoint]);\n    }\n  }\n};\n\nexport const handleSymlink = async (context: TaskContext, task: TaskSymlink) => {\n  const target: string = path.resolve(task.target);\n  const dstPath: string = path.resolve(task.path);\n\n  if (fs.existsSync(dstPath)) {\n    const lstat: fs.Stats = fs.lstatSync(dstPath);\n    logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n    if (task.forced) {\n      if (lstat.isSymbolicLink() || lstat.isFile()) {\n        logv(`Unlink ${dstPath}`);\n        fs.unlinkSync(dstPath);\n      } else if (lstat.isDirectory()) {\n        logv(`Remove directory '${dstPath}'`);\n        removeSync(dstPath);\n      }\n    }\n  }\n\n  if (fs.existsSync(dstPath)) {\n    logv(`Could not create symbolic link cause '${dstPath}' already exists`);\n    // throw Error()\n  } else {\n    logv(`Create symbolic link ${target} => ${dstPath}`);\n    fs.symlinkSync(target, dstPath, task.linkType);\n    const lstat: fs.Stats = fs.lstatSync(dstPath);\n    logv(`LSTAT is symlink? ${lstat.isSymbolicLink()}, is directory? ${lstat.isDirectory()}`);\n  }\n};\n\nexport const handleTerminalCommand = async (context: TaskContext, task: TaskTerminalCommand) => {\n  logv(`Start execution... ${task.cmd}`);\n  execSync(task.cmd, {\n    shell: task.shell,\n    // cwd: cwd,\n    env: process.env,\n    stdio: [process.stdin, process.stdout, process.stderr],\n    encoding: \"utf-8\",\n  });\n};\n\nexport const handleSetVar = async (context: TaskContext, task: TaskSetVar) => {\n  checkLegacyUsage(task, \"var\");\n  checkLegacyUsage(task, \"varType\");\n  checkLegacyUsage(task, \"fileFormat\");\n\n  checkTypeOrThrow(\"key\", task.key, [\"string\"]);\n  checkEmptyStringOrThrow(\"key\", task.key);\n\n  if (task.isFallback !== true) {\n    task.isFallback = false;\n  }\n  const isFallback: boolean = task.isFallback;\n\n  if (task.value !== undefined) {\n    const value = task.value;\n    setTaskVar(context, task.key, value, isFallback);\n  }\n\n  if (!task.src) return;\n  checkTypeOrThrow(\"src\", task.src, [\"string\"]);\n\n  const src = task.src as string;\n  const parser = task.parser || \"auto\";\n  logv(`Parser = ${parser}`);\n\n  const runFunc = (filePath: string) => {\n    const varsPath = path.resolve(filePath);\n    let obj: any | undefined;\n    const content = loadFileOrThrow(varsPath);\n\n    if (parser === \"auto\" || parser === \"json\") {\n      try {\n        logv(\"Trying to parse as JSON.\");\n        obj = parseJson(content);\n      } catch (e) {\n        if (parser === \"json\") throw e;\n      }\n    }\n\n    if (!obj && (parser === \"auto\" || parser === \"lines\")) {\n      logv(\"Trying to parse as lines.\");\n      obj = parseLines(content);\n    }\n\n    if (!obj && (parser === \"auto\" || parser === \"string\")) {\n      obj = content;\n    }\n\n    setTaskVar(context, task.key, obj, isFallback);\n  };\n\n  const runGlobSync = (items: string[]) => {\n    for (const f of items) {\n      const itemPath: string = path.join(src, f);\n      if (fs.statSync(itemPath).isDirectory()) {\n        continue;\n      }\n      runFunc(itemPath);\n    }\n  };\n\n  // ignore dirs, include all files on empty filters\n  const handled = processWithGlobSync(\n    runGlobSync,\n    src,\n    resolveStringArray(task.include, []),\n    resolveStringArray(task.exclude, []),\n    true,\n    true\n  );\n\n  // expect it is a single file\n  if (!handled) {\n    runFunc(src);\n  }\n};\n\nexport const handleEnvVar = async (context: TaskContext, task: TaskEnvVar) => {\n  checkLegacyUsage(task, \"var\");\n  checkLegacyUsage(task, \"varType\");\n  checkLegacyUsage(task, \"fileFormat\");\n\n  if (task.isFallback !== true) {\n    task.isFallback = false;\n  }\n  const isFallback: boolean = task.isFallback;\n\n  if (task.value !== undefined) {\n    let value: any = task.value;\n    if (typeof value === \"string\") {\n      logv(\"Trying to parse as lines.\");\n      value = parseLines(value);\n    }\n\n    Object.keys(value).forEach((key) => {\n      setEnvVar(context, key, value[key], isFallback);\n    });\n  }\n\n  if (!task.src) return;\n\n  checkTypeOrThrow(\"src\", task.src, [\"string\"]);\n  const src = task.src as string;\n  const parser = task.parser || \"auto\";\n  logv(`Parser = ${parser}`);\n\n  const runFunc = (filePath: string) => {\n    const varsPath = path.resolve(filePath);\n    let obj: Record<string, any> | undefined;\n    const content = loadFileOrThrow(varsPath);\n\n    if (parser === \"auto\" || parser === \"json\") {\n      try {\n        logv(\"Trying to parse as JSON.\");\n        obj = parseJson(content);\n      } catch (e) {\n        if (parser === \"json\") throw e;\n      }\n    }\n\n    if (!obj && (parser === \"auto\" || parser === \"lines\")) {\n      logv(\"Trying to parse as lines.\");\n      obj = parseLines(content);\n    }\n\n    if (obj) {\n      const finalObj = obj;\n      Object.keys(finalObj).forEach((key) => {\n        setEnvVar(context, key, finalObj[key], isFallback);\n      });\n    }\n  };\n\n  const runGlobSync = (items: string[]) => {\n    for (const f of items) {\n      const itemPath: string = path.join(src, f);\n      if (fs.statSync(itemPath).isDirectory()) {\n        continue;\n      }\n      runFunc(itemPath);\n    }\n  };\n\n  // ignore dirs, include all files on empty filters\n  const handled = processWithGlobSync(\n    runGlobSync,\n    src,\n    resolveStringArray(task.include, []),\n    resolveStringArray(task.exclude, []),\n    true,\n    true\n  );\n\n  // expect it is a single file\n  if (!handled) {\n    runFunc(src);\n  }\n};\n\nexport const handleOutput = async (context: TaskContext, task: TaskOutput) => {\n  const text = task.text ?? \"\";\n  const target: TaskOutputTargets = (task.target ?? \"c\").trim() as TaskOutputTargets;\n  const targetPath = task.path;\n\n  if (target === \"c\" || target === \"console\") {\n    console.log(text);\n  } else {\n    if (!targetPath) {\n      throw new Error(`The parameter 'path' is required for a target '${target}'!`);\n    }\n\n    const resolvedPath = path.resolve(targetPath);\n    const dir = path.dirname(resolvedPath);\n    if (!fs.existsSync(dir)) {\n      mkdirpSync(dir);\n    }\n\n    if (target == \"fa\" || target == \"file-append\") {\n      let err;\n      let fd;\n      try {\n        fd = fs.openSync(resolvedPath, \"a\");\n        fs.appendFileSync(fd, text, \"utf8\");\n      } catch (e) {\n        err = e;\n      } finally {\n        if (fd !== undefined) {\n          fs.closeSync(fd);\n        }\n      }\n\n      if (err) {\n        throw err;\n      }\n    } else {\n      fs.writeFileSync(resolvedPath, text);\n    }\n  }\n};\n\nconst resolveStringArray = (val: string | string[] | undefined | null, defaultValue: string[]): string[] => {\n  if (val !== undefined && val !== null) {\n    if (typeof val === \"string\") {\n      return [val];\n    } else if (Array.isArray(val)) {\n      return val.filter((v) => typeof v === \"string\");\n    }\n  }\n\n  return [];\n};\n\nconst runCopy = (src: string, dst: string, options: CopySyncOptions) => {\n  logv(`Copy: ${src} => ${dst}`);\n  copySync(src, dst, options);\n};\n\nexport const handleFsCopy = async (context: TaskContext, task: TaskFsCopy) => {\n  if (!fs.existsSync(task.src)) {\n    throw new Error(`The source '${task.src}' does not exist`);\n  }\n\n  const conflict = task?.options?.conflict;\n  let overwrite =\n    conflict === undefined || conflict === null || (typeof conflict === \"string\" && conflict.trim() === \"overwrite\");\n\n  /** @deprecated support migrate from '0.1.18' */\n  if (task.options && \"overwrite\" in task?.options && typeof task?.options?.overwrite === \"boolean\") {\n    overwrite = task.options.overwrite;\n  }\n\n  const cpOpt: CopyOptionsSync = { overwrite };\n\n  const runGlobSync = (items: string[]) => {\n    for (const f of items) {\n      const from = path.join(task.src, f);\n      const to = path.join(task.dest, f);\n      runCopy(from, to, cpOpt);\n    }\n  };\n\n  // allow dir with glob, do nothing withtout filters\n  const handled = processWithGlobSync(\n    runGlobSync,\n    task.src,\n    resolveStringArray(task.include, []),\n    resolveStringArray(task.exclude, []),\n    false,\n    false\n  );\n\n  // copy the path is whatever\n  if (!handled) {\n    runCopy(task.src, task.dest, cpOpt);\n  }\n};\n\nconst runDelete = (path: string) => {\n  logv(`Delete: ${path}`);\n  removeSync(path);\n};\n\nexport const handleFsDelete = async (context: TaskContext, task: TaskFsDelete) => {\n  if (!fs.existsSync(task.path)) {\n    logv(`The '${task.path}' does not exist and cannot be deleted`);\n    return;\n  }\n\n  const runGlobSync = (items: string[]) => {\n    for (const f of items) {\n      runDelete(path.join(task.path, f));\n    }\n  };\n\n  // allow dir with glob, do nothing withtout filters\n  const handled = processWithGlobSync(\n    runGlobSync,\n    task.path,\n    resolveStringArray(task.include, []),\n    resolveStringArray(task.exclude, []),\n    false,\n    false\n  );\n\n  // delete the path is whatever\n  if (!handled) {\n    runDelete(task.path);\n  }\n};\n\nexport const handleMkdir = async (context: TaskContext, task: TaskFsMakeDir) => {\n  checkTypeOrThrow(\"path\", task.path, [\"string\"]);\n  logv(`Make a directory at : ${task.path}`);\n  mkdirpSync(task.path);\n};\n\nconst runFindAndReplaceWithRegex = (content: string, find: RegExp, replace: string, repeat: number): string => {\n  var text: string = content;\n  if (repeat < 1) {\n    while (find.test(text)) {\n      text = text.replace(find, replace);\n    }\n  } else {\n    for (var i = 0; i < repeat; i++) {\n      if (find.test(text)) {\n        text = text.replace(find, replace);\n      }\n    }\n  }\n  return text;\n};\n\nconst runFindAndReplaceWithText = (content: string, find: string, replace: string, repeat: number): string => {\n  var text: string = content;\n  if (repeat < 1) {\n    while (text.indexOf(find) >= 0) {\n      text = text.replace(find, replace);\n    }\n  } else {\n    for (var i = 0; i < repeat; i++) {\n      if (text.indexOf(find) >= 0) {\n        text = text.replace(find, replace);\n      }\n    }\n  }\n  return text;\n};\n\nconst isRegexData = (v: any) => {\n  if (v !== undefined && v !== null && typeof v === \"object\" && \"pattern\" in v && typeof v.pattern === \"string\") {\n    return true;\n  }\n  return false;\n};\n\ntype FindAndReplaceFunc = (content: string, find: any, replace: string, repeat: number) => string;\n\nconst findAndReplaceWithFile = (\n  path: string,\n  replaceFunc: FindAndReplaceFunc,\n  find: string | RegExp,\n  replace: string,\n  repeat: number\n) => {\n  logv(`Find and Replace: ${path}`);\n  const content: string = fs.readFileSync(path, \"utf-8\");\n  const newContent = replaceFunc(content, find, replace, repeat);\n  fs.writeFileSync(path, newContent, \"utf-8\");\n};\n\nexport const handleContentReplace = async (context: TaskContext, task: TaskContentReplace) => {\n  if (!fs.existsSync(task.path)) {\n    logv(`The '${task.path}' does not exist`);\n    return;\n  }\n\n  if (task.replace === undefined || typeof task.replace !== \"string\") {\n    throwInvalidParamError(task, \"replace\");\n  }\n\n  let loop: number = task.loop === undefined || task.loop === null ? 1 : task.loop;\n  if (typeof loop === \"string\") {\n    loop = parseInt(loop, 10);\n  } else if (typeof loop !== \"number\") {\n    throwInvalidParamError(task, \"loop\");\n  }\n\n  let find: string | RegExp;\n  let replaceFunc: FindAndReplaceFunc;\n  if (isRegexData(task.find)) {\n    const regexData = task.find as RegexData;\n    find = new RegExp(regexData.pattern, regexData.flags);\n    replaceFunc = runFindAndReplaceWithRegex;\n  } else if (typeof task.find === \"string\") {\n    find = task.find;\n    replaceFunc = runFindAndReplaceWithText;\n  } else {\n    throwInvalidParamError(task, \"find\");\n    return;\n  }\n\n  const runGlobSync = (items: string[]) => {\n    for (const f of items) {\n      const itemPath: string = path.join(task.path, f);\n      if (fs.statSync(itemPath).isDirectory()) {\n        continue;\n      }\n      findAndReplaceWithFile(path.join(task.path, f), replaceFunc, find, task.replace, loop);\n    }\n  };\n\n  // ignore dirs, include all files on empty filters\n  const handled = processWithGlobSync(\n    runGlobSync,\n    task.path,\n    resolveStringArray(task.include, []),\n    resolveStringArray(task.exclude, []),\n    true,\n    true\n  );\n\n  // expect it is a single file\n  if (!handled) {\n    findAndReplaceWithFile(task.path, replaceFunc, find, task.replace, loop);\n  }\n};\n","import fs from \"fs\";\nimport { globSync } from \"glob\";\n\n/**\n *\n * @param handler\n * @param cwd\n * @param includes\n * @param excludes\n * @param includeAllForNonFilter\n * @param subOptions\n * @returns true - filters are applied, false - there was no filter to apply\n */\nexport const processWithGlobSync = (\n  handler: (items: string[]) => void,\n  cwd: string,\n  includes: string[],\n  excludes: string[],\n  skipDirs: boolean,\n  includeAllIfNonFilters: boolean\n): boolean => {\n  if (fs.statSync(cwd).isDirectory() === false) {\n    return false;\n  }\n\n  //pre apply filter for faster performance\n  const nodir: boolean = skipDirs === true;\n\n  const ilen: boolean = includes.length > 0;\n  const elen: boolean = excludes.length > 0;\n  if (!ilen && elen) {\n    //include all to apply excludes\n    handler(globSync(\"**\", { ignore: [\".\", ...excludes], cwd, nodir }));\n    return true;\n  } else if (ilen && !elen) {\n    //apply includes only\n    handler(globSync(includes, { cwd, nodir }));\n    return true;\n  } else if (ilen && elen) {\n    //apply include and exclude\n    handler(globSync(includes, { ignore: excludes, cwd, nodir }));\n    return true;\n  } else if (includeAllIfNonFilters) {\n    //include all to apply skipDirs, skipFiles\n    handler(globSync(\"**\", { ignore: [\".\"], cwd, nodir }));\n    return true;\n  }\n\n  return false;\n};\n","import { handleSubTasks } from \"./handler_sub_tasks\";\nimport {\n  handleContentReplace,\n  handleEnvVar,\n  handleFsCopy,\n  handleFsDelete,\n  handleGitRepoSetup,\n  handleMkdir,\n  handleOutput,\n  handleSetVar,\n  handleSymlink,\n  handleTerminalCommand,\n} from \"./handlers\";\nimport { TaskContext, TaskType } from \"./task_data\";\n\nexport const handlerMap: {\n  [k in TaskType]: (context: TaskContext, task: any) => Promise<void>;\n} = {\n  \"git-repo-prepare\": handleGitRepoSetup,\n  symlink: handleSymlink,\n  cmd: handleTerminalCommand,\n  \"set-var\": handleSetVar,\n  output: handleOutput,\n  \"fs-copy\": handleFsCopy,\n  \"fs-del\": handleFsDelete,\n  \"fs-mkdir\": handleMkdir,\n  \"env-var\": handleEnvVar,\n  \"sub-tasks\": handleSubTasks,\n  \"content-replace\": handleContentReplace,\n};\n"],"mappings":";ykBAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,iBAAAE,IAAA,eAAAC,GAAAH,IAEA,IAAAI,GAAiB,mBCFjB,IAAAC,GAAwB,qBACxBC,GAAiB,mBAEJC,GAAiB,oBACjBC,GAAoB,GAEpBC,EAAa,UACbC,EAAU,OAEVC,GAAW,CAACF,EAAYC,CAAO,EAItCE,GAAe,OACfC,GAAgB,QAChBC,GAAe,OACRC,EAAY,CAACD,GAAcF,GAAcC,EAAa,EAkB7DG,GAAU,CACd,QAAS,kBAAkBL,GACxB,IAAKM,GAAM,IAAIA,CAAC,GAAG,EACnB,KACC,MACF,CAAC,yLAAyLR,CAAU,yHAAyHC,CAAO,wCACxU,EAEaQ,EAASC,GAAwB,CAI5C,IAAMC,EAAU,IAAI,WACpBA,EACG,KAAK,cAAc,EACnB,QAAQ,OAAgC,EACxC,OAAO,iBAAkB,0BAA0B,EACnD,OAAO,wBAAyB,8BAA+Bb,EAAc,EAC7E,OACC,wBACA,uJACF,EACC,OACC,4BACA,8IACF,EACC,OACC,wBACA,uJACF,EACC,OACC,4BACA,8IACF,EACC,OACC,yBACA,8KACAC,EACF,EACC,OAAO,sBAAuBQ,GAAQ,QAASP,CAAU,EACzD,OACC,uBACA,gCAAgCM,EAAU,KACxC,GACF,CAAC,uEACH,EACC,mBAAmB,EAAI,EAEtBI,IAAa,OACfC,EAAQ,MAAMD,EAAU,CAAE,KAAM,MAAO,CAAC,EAExCC,EAAQ,MAAM,EAMhB,IAAMC,EAHOD,EAAQ,KAAK,EAW1B,GAPAC,EAAa,QAAUC,EAAuBD,EAAa,OAAO,EAClEA,EAAa,WAAaC,EAAuBD,EAAa,UAAU,EACxEA,EAAa,QAAUC,EAAuBD,EAAa,OAAO,EAClEA,EAAa,WAAaC,EAAuBD,EAAa,UAAU,EAExEA,EAAa,kBAAoBA,EAAa,UAAYX,EAEtDW,EAAa,YAAc,QAAa,OAAOA,EAAa,WAAc,SAAU,CACtF,IAAIJ,EAAYI,EAAa,UAC7BJ,EAAIA,EAAE,KAAK,EAAE,YAAY,EACrBA,IAAM,SAAWA,IAAM,KAAOA,IAAM,KACtCI,EAAa,UAAY,GAChBJ,IAAM,QAAUA,IAAM,KAAOA,IAAM,MAC5CI,EAAa,UAAY,GAEzBA,EAAa,UAAYb,EAE7B,CACA,OAAAa,EAAa,UAAY,CAAC,GAAID,EAAQ,MAAQ,CAAC,CAAE,EAK7CC,EAAa,KACf,QAAQ,MAAM,GAAAE,QAAK,QAAQF,EAAa,GAAG,CAAC,EAKvC,CAAE,IAAKA,EAAc,QAAAD,CAAQ,CACtC,EAEME,EAAyB,CAACE,EAAsCC,EAAyB,KAAS,CACtG,GAAI,CAACD,EACH,MAAO,CAAC,EAGV,GAAI,OAAOA,GAAU,SAAU,CAC7B,IAAME,EAAmB,CAAC,EAE1B,OADYF,EAAM,MAAM,GAAG,EACvB,QAASA,GAAU,CACrB,IAAMG,EAAcH,EAAM,KAAK,EAC3BC,EACEE,EAAY,OAAS,GACvBD,EAAO,KAAKC,CAAW,EAGzBD,EAAO,KAAKC,CAAW,CAE3B,CAAC,EACMD,CACT,CAEA,MAAO,CAAC,CACV,EClJA,IAAAE,EAAiB,mBCAjB,IAAAC,EAAe,iBACfC,EAAiB,mBACjBC,GAAkB,oBCFlB,IAAAC,EAAkB,oBC+IX,IAAMC,EAAU,eACVC,EAAY,GAAGD,CAAO,SACtBE,EAAW,GAAGF,CAAO,QACrBG,EAAW,GAAGH,CAAO,QAGrBI,GAAwB,iCAExBC,GAA2B,SAC3BC,GAA+B,SDrJrC,IAAMC,MAAO,EAAAC,SAAMC,CAAQ,EACrBC,KAAO,EAAAF,SAAMG,CAAQ,EACrBC,KAAO,EAAAJ,SAAMK,CAAS,EDC5B,IAAMC,EAAmBC,GAAqB,CAEnD,GADAC,EAAK,iBAAiBD,CAAQ,EAAE,EAC5B,CAAC,EAAAE,QAAG,WAAWF,CAAQ,EACzB,MAAM,IAAI,MAAM,oBAAoBA,CAAQ,oBAAoB,EAGlE,OAAO,EAAAE,QAAG,aAAaF,EAAU,CAAE,SAAU,OAAQ,CAAC,CACxD,EAEaG,GAAYH,GAChBI,EAAUL,EAAgBC,CAAQ,CAAC,EAG/BI,EAAaC,GAAoB,GAAAC,QAAM,MAAMD,CAAO,EAEpDE,EAAkBP,GAAqB,CAClD,IAAIQ,EAAaL,GAASH,CAAQ,EAClC,GAAIQ,EAAW,QAAS,CACtB,IAAMC,EAAc,EAAAC,QAAK,QAAQV,CAAQ,EACnCW,EAAkB,EAAAD,QAAK,QAAQD,EAAaD,EAAW,OAAO,EACpEA,EAAa,OAAO,OAAO,CAAC,EAAGA,EAAYD,EAAeI,CAAe,CAAC,CAC5E,CAEA,OAAOH,CACT,EAEaI,EAAoC,CAACC,EAAcC,IAAkB,CAChF,GAAI,CAACA,EACH,OAAOD,EAGT,IAAIE,EAAS,GACTC,EAAUH,EAAK,MAAM,GAAG,EAC5B,QAASI,EAAI,EAAGA,EAAID,EAAQ,OAAQC,IAAK,CACvC,IAAIC,EAAOF,EAAQC,CAAC,EAChBA,IAAM,EACRF,EAASG,GAELA,EAAK,OAAS,IAChBA,EAAO,GAAGA,EAAK,CAAC,EAAE,YAAY,CAAC,GAAGA,EAAK,UAAU,CAAC,CAAC,IAErDH,EAAS,GAAGA,CAAM,GAAGG,CAAI,GAE7B,CACA,OAAOH,CACT,EAEaI,EAAc,CAACC,EAAoBC,IAAmB,CACjE,GAAID,EAAS,OAAS,EACpB,MAAO,GAGT,QAAWE,KAAMF,EACf,QAAWG,KAAOF,EAChB,GAAIC,IAAOC,EACT,MAAO,GAKb,MAAO,EACT,EAEaC,GAAiB,CAACJ,EAAoBC,IAAmB,CACpE,GAAID,EAAS,OAAS,EACpB,MAAO,GAET,QAAWE,KAAMF,EAAU,CACzB,IAAIK,EAAY,GAChB,QAAWF,KAAOF,EAChB,GAAIE,IAAQD,EAAI,CACdG,EAAY,GACZ,KACF,CAEF,GAAI,CAACA,EACH,MAAO,EAEX,CACA,MAAO,EACT,EAEaC,GAA0B,CAACC,EAAcC,IAAkB,CACtE,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,QAAQD,CAAI,+BAA+B,CAE/D,EAEaE,EAAmB,CAACC,EAAYC,IAAgB,CACtDD,EAAaC,CAAG,IAAM,QAAWC,GAAK,YAAYD,CAAG,wBAAwB,CACpF,EAGaE,GAAY,CAACL,EAAYM,IAChCA,EAAa,QAAU,EAAU,GAC9BA,EAAa,SAAS,OAAON,CAAK,EAG9BO,EAAmB,CAACR,EAAcC,EAAYM,IAAwC,CACjG,GAAID,GAAUL,EAAOM,CAAY,EAC/B,MAAO,GAGT,IAAME,EAAY,OAAOR,EACzB,MAAM,IAAI,MACR,QAAQD,CAAI,mCAAmCS,CAAS,qBAAqBR,CAAK,6BAA6BM,CAAY,IAC7H,CACF,EAEMG,GACJ,+IAGK,SAASC,EAAWC,EAAa,CACtC,IAAMC,EAAW,CAAC,EAGdC,EAAQF,EAAI,SAAS,EAGzBE,EAAQA,EAAM,QAAQ,UAAW;AAAA,CAAI,EAErC,IAAIC,EACJ,MAAQA,EAAQL,GAAS,KAAKI,CAAK,IAAM,MAAM,CAC7C,IAAMV,EAAMW,EAAM,CAAC,EAEfd,EAAQc,EAAM,CAAC,GAAK,GAExBd,EAAQA,EAAM,KAAK,EAEnB,IAAMe,EAAaf,EAAM,CAAC,EAE1BA,EAAQA,EAAM,QAAQ,yBAA0B,IAAI,EAEhDe,IAAe,MACjBf,EAAQA,EAAM,QAAQ,OAAQ;AAAA,CAAI,EAClCA,EAAQA,EAAM,QAAQ,OAAQ,IAAI,GAIpCY,EAAIT,CAAG,EAAIH,CACb,CAEA,OAAOY,CACT,CDnJA,IAAAI,GAAkB,oBICX,IAAMC,GAAiB,MAAOC,EAAsBC,IAAe,CACxE,IAAMC,EAAmBD,EACzB,QAAWE,KAAO,OAAO,KAAKD,CAAW,EACvC,GAAI,OAAOC,GAAQ,UAIf,EAAAA,IAAQ,MAAQA,IAAQ,SAIxBD,EAAYC,CAAG,IAAM,QAAa,OAAOD,EAAYC,CAAG,GAAM,SAAU,CAC1E,IAAIC,EAAqBF,EAAYC,CAAG,EACxC,OAAa,CACX,IAAME,EAAQL,EAAQ,aAAa,KAAKI,CAAU,EAClD,GAAIC,GAAU,KACZ,MAGF,IAAMC,EAAaD,EAAM,CAAC,EACpBE,EAAUF,EAAM,CAAC,EAEnBG,EAAaR,EAAQ,KACzB,GAAIO,EAAQ,OAAS,EAAG,CACtB,IAAME,EAAWF,EAAQ,MAAM,GAAG,EAClC,QAASG,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAAK,CACxC,IAAMC,EAAQF,EAASC,CAAC,EACxB,GAAIF,EAAW,eAAeG,CAAK,EACjCH,EAAaA,EAAWG,CAAK,MAE7B,OAAM,IAAI,MAAM,gBAAgBJ,CAAO,sBAAsB,CAEjE,CACF,CAEA,IAAMK,EAAcR,EAAW,UAAU,EAAGC,EAAM,KAAK,EACjDQ,EAAe,GAAGL,CAAU,GAC5BM,EAAcV,EAAW,UAAUC,EAAM,MAAQC,EAAW,MAAM,EACxEF,EAAa,GAAGQ,CAAW,GAAGC,CAAY,GAAGC,CAAW,GACxDC,EAAK,wBAAwBZ,CAAG,OAAOC,CAAU,GAAG,CACtD,CAEAF,EAAYC,CAAG,EAAIC,CACrB,CAEJ,EAEaY,GAAsB,CACjCC,EACAC,EACAC,EACAC,IACG,CACH,IAAIC,EACAC,EAA+B,GAEnC,QAASC,KAAYN,EAAW,CAE9B,GADYM,EAAS,KAAK,IACd,KAAM,CAChBR,EAAK,sBAAsB,EAC3B,KACF,CAEA,GAAIO,GAAuBD,EAAgB,CACzC,IAAMG,EAAQD,EAAS,WAAW,GAAG,EAAI,GAAKA,EAC9CH,EAASC,EAAgBG,CAAK,EAC9BH,EAAiB,OACjBC,EAAsB,EACxB,SACsBC,EAAS,QAAQL,CAAG,GACrB,EAAG,CACpB,IAAMO,EAAiBF,EAAS,QAAQ,GAAG,EAC3C,GAAIE,GAAkB,EAAG,CACvB,IAAMC,EAAUC,EACdJ,EAAS,UAAUL,EAAI,OAAQO,CAAc,EAC7CN,CACF,EACMK,EAAQD,EAAS,UAAUE,EAAiB,CAAC,EACnDL,EAASM,EAASF,CAAK,CACzB,MACEH,EAAiBM,EAAkCJ,EAAS,UAAUL,EAAI,MAAM,EAAGC,CAAkB,EACrGG,EAAsB,EAE1B,CAEJ,CACF,EAEaM,EAAa,CAAC5B,EAAsBG,EAAaqB,EAAYK,IAA2B,CACnG,GAAIA,GAAiB7B,EAAQ,KAAKG,CAAG,IAAM,OAAW,CACpDY,EAAK,gCAAgCZ,CAAG,IAAIqB,CAAK,6BAA6B,EAC9E,MACF,CAEAT,EAAK,qBAAqBZ,CAAG,IAAIqB,CAAK,EAAE,EACxCxB,EAAQ,KAAKG,CAAG,EAAIqB,CACtB,EAEaM,EAAY,CAAC9B,EAAsBG,EAAaqB,EAAYK,IAA2B,CAClG,IAAIE,EAAY,OAAOP,EACvB,GAAIO,IAAc,UAAYA,IAAc,UAAYA,IAAc,UACpEhB,EAAK,8BAA8BgB,CAAS,0BAA0B5B,CAAG,IAAIqB,CAAK,EAAE,UAElE,OAAOA,CAAK,EAChB,OAAS,EACrBT,EAAK,6CAA6CZ,CAAG,IAAIqB,CAAK,EAAE,MAC3D,CACL,GAAIK,GAAiB,QAAQ,IAAI1B,CAAG,IAAM,OAAW,CACnDY,EAAK,4CAA4CZ,CAAG,IAAIqB,CAAK,6BAA6B,EAC1F,MACF,CAEAT,EAAK,iCAAiCZ,CAAG,IAAIqB,CAAK,EAAE,EACpD,QAAQ,IAAIrB,CAAG,EAAI,OAAOqB,CAAK,CACjC,CAEJ,ECxHA,IAAAQ,GAAuB,0BAKhB,IAAMC,GAAiB,MAAOC,EAAsBC,IAAuB,CAChF,GAAI,CAACA,EAAK,MAAQ,OAAOA,EAAK,MAAS,SACrC,MAAM,IAAI,MAAM,2DAA2D,EAG7E,IAAMC,KAAU,GAAAC,SAAWF,EAAK,IAAI,EAC9BG,EAAcC,EAAMH,CAAO,EACjCI,EAAYN,EAAQ,UAAWI,EAAY,IAAKA,EAAY,OAAO,CACrE,ECbA,IAAAG,EAAe,iBACfC,GAAyB,yBACzBC,EAAiB,mBACjBC,EAAuD,sBACvDC,EAAiG,oBCJjG,IAAAC,GAAe,iBACfC,EAAyB,gBAYZC,EAAsB,CACjCC,EACAC,EACAC,EACAC,EACAC,EACAC,IACY,CACZ,GAAI,GAAAC,QAAG,SAASL,CAAG,EAAE,YAAY,IAAM,GACrC,MAAO,GAIT,IAAMM,EAAiBH,IAAa,GAE9BI,EAAgBN,EAAS,OAAS,EAClCO,EAAgBN,EAAS,OAAS,EACxC,MAAI,CAACK,GAAQC,GAEXT,KAAQ,YAAS,KAAM,CAAE,OAAQ,CAAC,IAAK,GAAGG,CAAQ,EAAG,IAAAF,EAAK,MAAAM,CAAM,CAAC,CAAC,EAC3D,IACEC,GAAQ,CAACC,GAElBT,KAAQ,YAASE,EAAU,CAAE,IAAAD,EAAK,MAAAM,CAAM,CAAC,CAAC,EACnC,IACEC,GAAQC,GAEjBT,KAAQ,YAASE,EAAU,CAAE,OAAQC,EAAU,IAAAF,EAAK,MAAAM,CAAM,CAAC,CAAC,EACrD,IACEF,GAETL,KAAQ,YAAS,KAAM,CAAE,OAAQ,CAAC,GAAG,EAAG,IAAAC,EAAK,MAAAM,CAAM,CAAC,CAAC,EAC9C,IAGF,EACT,EDfA,IAAMG,GAAyB,CAAuBC,EAAQC,IAAW,CACvE,MAAM,IAAI,MAAM,kBAAkB,OAAOA,CAAG,CAAC,0BAA0BD,EAAIC,CAAG,CAAC,EAAE,CACnF,EAEaC,GAAqB,MAAOC,EAAsBC,IAA0B,CACvF,IAAMC,EAAY,EAAAC,QAAK,QAAQF,EAAK,SAAS,EAExC,EAAAG,QAAG,WAAWF,CAAS,GAC1B,EAAAE,QAAG,UAAUF,EAAW,CAAE,UAAW,EAAK,CAAC,EAGzC,EAAAE,QAAG,YAAYF,CAAS,EAAE,SAAW,GACnCD,EAAK,KACP,QAAM,aAAU,EAAE,MAAMA,EAAK,IAAKC,CAAS,EAI/C,IAAMG,KAAM,aAAUH,EAAW,CAAE,OAAQD,EAAK,MAAO,CAAC,EAGxD,GAAI,CADc,MAAMI,EAAI,YAAY,mBAAiB,YAAY,EAEnE,MAAM,MAAM,GAAGH,CAAS,6BAA6B,EAcvD,GAXID,EAAK,mBACP,MAAMI,EAAI,cAAc,EACxB,MAAMA,EAAI,gBAAgB,GAO5B,MAAMA,EAAI,MAAM,EAEZJ,EAAK,OAAQ,CACf,IAAIK,EAAiB,GACfC,EAAc,MAAMF,EAAI,YAAY,EAC1C,QAASG,KAAKD,EAAY,IACxB,GAAIC,IAAMP,EAAK,OAAQ,CACrBK,EAAiB,GACjB,KACF,CAGF,IAAMG,EAASR,EAAK,QAAU,GACxBS,EAAqBT,EAAK,YAAc,GAEzCK,GAGCC,EAAY,UAAYN,EAAK,QAC/B,MAAMI,EAAI,SAASI,CAAM,EAE3B,MAAMJ,EAAI,MAAM,YAAU,KAAM,CAACK,CAAU,CAAC,GAL5C,MAAML,EAAI,eAAeI,EAAQC,CAAU,CAO/C,CACF,EAEaC,GAAgB,MAAOX,EAAsBC,IAAsB,CAC9E,IAAMW,EAAiB,EAAAT,QAAK,QAAQF,EAAK,MAAM,EACzCY,EAAkB,EAAAV,QAAK,QAAQF,EAAK,IAAI,EAE9C,GAAI,EAAAG,QAAG,WAAWS,CAAO,EAAG,CAC1B,IAAMC,EAAkB,EAAAV,QAAG,UAAUS,CAAO,EAC5CE,EAAK,qBAAqBD,EAAM,eAAe,CAAC,mBAAmBA,EAAM,YAAY,CAAC,EAAE,EACpFb,EAAK,SACHa,EAAM,eAAe,GAAKA,EAAM,OAAO,GACzCC,EAAK,UAAUF,CAAO,EAAE,EACxB,EAAAT,QAAG,WAAWS,CAAO,GACZC,EAAM,YAAY,IAC3BC,EAAK,qBAAqBF,CAAO,GAAG,KACpC,cAAWA,CAAO,GAGxB,CAEA,GAAI,EAAAT,QAAG,WAAWS,CAAO,EACvBE,EAAK,yCAAyCF,CAAO,kBAAkB,MAElE,CACLE,EAAK,wBAAwBH,CAAM,OAAOC,CAAO,EAAE,EACnD,EAAAT,QAAG,YAAYQ,EAAQC,EAASZ,EAAK,QAAQ,EAC7C,IAAMa,EAAkB,EAAAV,QAAG,UAAUS,CAAO,EAC5CE,EAAK,qBAAqBD,EAAM,eAAe,CAAC,mBAAmBA,EAAM,YAAY,CAAC,EAAE,CAC1F,CACF,EAEaE,GAAwB,MAAOhB,EAAsBC,IAA8B,CAC9Fc,EAAK,sBAAsBd,EAAK,GAAG,EAAE,KACrC,aAASA,EAAK,IAAK,CACjB,MAAOA,EAAK,MAEZ,IAAK,QAAQ,IACb,MAAO,CAAC,QAAQ,MAAO,QAAQ,OAAQ,QAAQ,MAAM,EACrD,SAAU,OACZ,CAAC,CACH,EAEagB,GAAe,MAAOjB,EAAsBC,IAAqB,CAC5EiB,EAAiBjB,EAAM,KAAK,EAC5BiB,EAAiBjB,EAAM,SAAS,EAChCiB,EAAiBjB,EAAM,YAAY,EAEnCkB,EAAiB,MAAOlB,EAAK,IAAK,CAAC,QAAQ,CAAC,EAC5CmB,GAAwB,MAAOnB,EAAK,GAAG,EAEnCA,EAAK,aAAe,KACtBA,EAAK,WAAa,IAEpB,IAAMoB,EAAsBpB,EAAK,WAEjC,GAAIA,EAAK,QAAU,OAAW,CAC5B,IAAMqB,EAAQrB,EAAK,MACnBsB,EAAWvB,EAASC,EAAK,IAAKqB,EAAOD,CAAU,CACjD,CAEA,GAAI,CAACpB,EAAK,IAAK,OACfkB,EAAiB,MAAOlB,EAAK,IAAK,CAAC,QAAQ,CAAC,EAE5C,IAAMuB,EAAMvB,EAAK,IACXwB,EAASxB,EAAK,QAAU,OAC9Bc,EAAK,YAAYU,CAAM,EAAE,EAEzB,IAAMC,EAAWC,GAAqB,CACpC,IAAMC,EAAW,EAAAzB,QAAK,QAAQwB,CAAQ,EAClC9B,EACEgC,EAAUC,EAAgBF,CAAQ,EAExC,GAAIH,IAAW,QAAUA,IAAW,OAClC,GAAI,CACFV,EAAK,0BAA0B,EAC/BlB,EAAMkC,EAAUF,CAAO,CACzB,OAASG,EAAP,CACA,GAAIP,IAAW,OAAQ,MAAMO,CAC/B,CAGE,CAACnC,IAAQ4B,IAAW,QAAUA,IAAW,WAC3CV,EAAK,2BAA2B,EAChClB,EAAMoC,EAAWJ,CAAO,GAGtB,CAAChC,IAAQ4B,IAAW,QAAUA,IAAW,YAC3C5B,EAAMgC,GAGRN,EAAWvB,EAASC,EAAK,IAAKJ,EAAKwB,CAAU,CAC/C,EAagBa,EAXKC,GAAoB,CACvC,QAAWC,KAAKD,EAAO,CACrB,IAAME,EAAmB,EAAAlC,QAAK,KAAKqB,EAAKY,CAAC,EACrC,EAAAhC,QAAG,SAASiC,CAAQ,EAAE,YAAY,GAGtCX,EAAQW,CAAQ,CAClB,CACF,EAKEb,EACAc,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnCqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIEyB,EAAQF,CAAG,CAEf,EAEae,GAAe,MAAOvC,EAAsBC,IAAqB,CAC5EiB,EAAiBjB,EAAM,KAAK,EAC5BiB,EAAiBjB,EAAM,SAAS,EAChCiB,EAAiBjB,EAAM,YAAY,EAE/BA,EAAK,aAAe,KACtBA,EAAK,WAAa,IAEpB,IAAMoB,EAAsBpB,EAAK,WAEjC,GAAIA,EAAK,QAAU,OAAW,CAC5B,IAAIqB,EAAarB,EAAK,MAClB,OAAOqB,GAAU,WACnBP,EAAK,2BAA2B,EAChCO,EAAQW,EAAWX,CAAK,GAG1B,OAAO,KAAKA,CAAK,EAAE,QAASxB,GAAQ,CAClC0C,EAAUxC,EAASF,EAAKwB,EAAMxB,CAAG,EAAGuB,CAAU,CAChD,CAAC,CACH,CAEA,GAAI,CAACpB,EAAK,IAAK,OAEfkB,EAAiB,MAAOlB,EAAK,IAAK,CAAC,QAAQ,CAAC,EAC5C,IAAMuB,EAAMvB,EAAK,IACXwB,EAASxB,EAAK,QAAU,OAC9Bc,EAAK,YAAYU,CAAM,EAAE,EAEzB,IAAMC,EAAWC,GAAqB,CACpC,IAAMC,EAAW,EAAAzB,QAAK,QAAQwB,CAAQ,EAClC9B,EACEgC,EAAUC,EAAgBF,CAAQ,EAExC,GAAIH,IAAW,QAAUA,IAAW,OAClC,GAAI,CACFV,EAAK,0BAA0B,EAC/BlB,EAAMkC,EAAUF,CAAO,CACzB,OAASG,EAAP,CACA,GAAIP,IAAW,OAAQ,MAAMO,CAC/B,CAQF,GALI,CAACnC,IAAQ4B,IAAW,QAAUA,IAAW,WAC3CV,EAAK,2BAA2B,EAChClB,EAAMoC,EAAWJ,CAAO,GAGtBhC,EAAK,CACP,IAAM4C,EAAW5C,EACjB,OAAO,KAAK4C,CAAQ,EAAE,QAAS3C,GAAQ,CACrC0C,EAAUxC,EAASF,EAAK2C,EAAS3C,CAAG,EAAGuB,CAAU,CACnD,CAAC,CACH,CACF,EAagBa,EAXKC,GAAoB,CACvC,QAAWC,KAAKD,EAAO,CACrB,IAAME,EAAmB,EAAAlC,QAAK,KAAKqB,EAAKY,CAAC,EACrC,EAAAhC,QAAG,SAASiC,CAAQ,EAAE,YAAY,GAGtCX,EAAQW,CAAQ,CAClB,CACF,EAKEb,EACAc,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnCqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIEyB,EAAQF,CAAG,CAEf,EAEakB,GAAe,MAAO1C,EAAsBC,IAAqB,CAC5E,IAAM0C,EAAO1C,EAAK,MAAQ,GACpBW,GAA6BX,EAAK,QAAU,KAAK,KAAK,EACtD2C,EAAa3C,EAAK,KAExB,GAAIW,IAAW,KAAOA,IAAW,UAC/B,QAAQ,IAAI+B,CAAI,MACX,CACL,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,kDAAkDhC,CAAM,IAAI,EAG9E,IAAMiC,EAAe,EAAA1C,QAAK,QAAQyC,CAAU,EACtCE,EAAM,EAAA3C,QAAK,QAAQ0C,CAAY,EAKrC,GAJK,EAAAzC,QAAG,WAAW0C,CAAG,MACpB,cAAWA,CAAG,EAGZlC,GAAU,MAAQA,GAAU,cAAe,CAC7C,IAAImC,EACAC,EACJ,GAAI,CACFA,EAAK,EAAA5C,QAAG,SAASyC,EAAc,GAAG,EAClC,EAAAzC,QAAG,eAAe4C,EAAIL,EAAM,MAAM,CACpC,OAASX,EAAP,CACAe,EAAMf,CACR,QAAE,CACIgB,IAAO,QACT,EAAA5C,QAAG,UAAU4C,CAAE,CAEnB,CAEA,GAAID,EACF,MAAMA,CAEV,MACE,EAAA3C,QAAG,cAAcyC,EAAcF,CAAI,CAEvC,CACF,EAEML,EAAqB,CAACW,EAA2CC,IAAqC,CAC1G,GAAyBD,GAAQ,KAAM,CACrC,GAAI,OAAOA,GAAQ,SACjB,MAAO,CAACA,CAAG,EACN,GAAI,MAAM,QAAQA,CAAG,EAC1B,OAAOA,EAAI,OAAQE,GAAM,OAAOA,GAAM,QAAQ,CAElD,CAEA,MAAO,CAAC,CACV,EAEMC,GAAU,CAAC5B,EAAa6B,EAAaC,IAA6B,CACtEvC,EAAK,SAASS,CAAG,OAAO6B,CAAG,EAAE,KAC7B,YAAS7B,EAAK6B,EAAKC,CAAO,CAC5B,EAEaC,GAAe,MAAOvD,EAAsBC,IAAqB,CAC5E,GAAI,CAAC,EAAAG,QAAG,WAAWH,EAAK,GAAG,EACzB,MAAM,IAAI,MAAM,eAAeA,EAAK,GAAG,kBAAkB,EAG3D,IAAMuD,EAAWvD,GAAM,SAAS,SAC5BwD,EACwBD,GAAa,MAAS,OAAOA,GAAa,UAAYA,EAAS,KAAK,IAAM,YAGlGvD,EAAK,SAAW,cAAeA,GAAM,SAAW,OAAOA,GAAM,SAAS,WAAc,YACtFwD,EAAYxD,EAAK,QAAQ,WAG3B,IAAMyD,EAAyB,CAAE,UAAAD,CAAU,EAW3BvB,EATKC,GAAoB,CACvC,QAAWC,KAAKD,EAAO,CACrB,IAAMwB,EAAO,EAAAxD,QAAK,KAAKF,EAAK,IAAKmC,CAAC,EAC5BwB,EAAK,EAAAzD,QAAK,KAAKF,EAAK,KAAMmC,CAAC,EACjCgB,GAAQO,EAAMC,EAAIF,CAAK,CACzB,CACF,EAKEzD,EAAK,IACLqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnCqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIEmD,GAAQnD,EAAK,IAAKA,EAAK,KAAMyD,CAAK,CAEtC,EAEMG,GAAa1D,GAAiB,CAClCY,EAAK,WAAWZ,CAAI,EAAE,KACtB,cAAWA,CAAI,CACjB,EAEa2D,GAAiB,MAAO9D,EAAsBC,IAAuB,CAChF,GAAI,CAAC,EAAAG,QAAG,WAAWH,EAAK,IAAI,EAAG,CAC7Bc,EAAK,QAAQd,EAAK,IAAI,wCAAwC,EAC9D,MACF,CASgBiC,EAPKC,GAAoB,CACvC,QAAWC,KAAKD,EACd0B,GAAU,EAAA1D,QAAK,KAAKF,EAAK,KAAMmC,CAAC,CAAC,CAErC,EAKEnC,EAAK,KACLqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnCqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIE4D,GAAU5D,EAAK,IAAI,CAEvB,EAEa8D,GAAc,MAAO/D,EAAsBC,IAAwB,CAC9EkB,EAAiB,OAAQlB,EAAK,KAAM,CAAC,QAAQ,CAAC,EAC9Cc,EAAK,yBAAyBd,EAAK,IAAI,EAAE,KACzC,cAAWA,EAAK,IAAI,CACtB,EAEM+D,GAA6B,CAACnC,EAAiBoC,EAAcC,EAAiBC,IAA2B,CAC7G,IAAIxB,EAAed,EACnB,GAAIsC,EAAS,EACX,KAAOF,EAAK,KAAKtB,CAAI,GACnBA,EAAOA,EAAK,QAAQsB,EAAMC,CAAO,MAGnC,SAASE,EAAI,EAAGA,EAAID,EAAQC,IACtBH,EAAK,KAAKtB,CAAI,IAChBA,EAAOA,EAAK,QAAQsB,EAAMC,CAAO,GAIvC,OAAOvB,CACT,EAEM0B,GAA4B,CAACxC,EAAiBoC,EAAcC,EAAiBC,IAA2B,CAC5G,IAAIxB,EAAed,EACnB,GAAIsC,EAAS,EACX,KAAOxB,EAAK,QAAQsB,CAAI,GAAK,GAC3BtB,EAAOA,EAAK,QAAQsB,EAAMC,CAAO,MAGnC,SAASE,EAAI,EAAGA,EAAID,EAAQC,IACtBzB,EAAK,QAAQsB,CAAI,GAAK,IACxBtB,EAAOA,EAAK,QAAQsB,EAAMC,CAAO,GAIvC,OAAOvB,CACT,EAEM2B,GAAenB,GACIA,GAAM,MAAQ,OAAOA,GAAM,UAAY,YAAaA,GAAK,OAAOA,EAAE,SAAY,SAQjGoB,GAAyB,CAC7BpE,EACAqE,EACAP,EACAC,EACAC,IACG,CACHpD,EAAK,qBAAqBZ,CAAI,EAAE,EAChC,IAAM0B,EAAkB,EAAAzB,QAAG,aAAaD,EAAM,OAAO,EAC/CsE,EAAaD,EAAY3C,EAASoC,EAAMC,EAASC,CAAM,EAC7D,EAAA/D,QAAG,cAAcD,EAAMsE,EAAY,OAAO,CAC5C,EAEaC,GAAuB,MAAO1E,EAAsBC,IAA6B,CAC5F,GAAI,CAAC,EAAAG,QAAG,WAAWH,EAAK,IAAI,EAAG,CAC7Bc,EAAK,QAAQd,EAAK,IAAI,kBAAkB,EACxC,MACF,EAEIA,EAAK,UAAY,QAAa,OAAOA,EAAK,SAAY,WACxDL,GAAuBK,EAAM,SAAS,EAGxC,IAAI0E,EAAe1E,EAAK,OAAS,QAAaA,EAAK,OAAS,KAAO,EAAIA,EAAK,KACxE,OAAO0E,GAAS,SAClBA,EAAO,SAASA,EAAM,EAAE,EACf,OAAOA,GAAS,UACzB/E,GAAuBK,EAAM,MAAM,EAGrC,IAAIgE,EACAO,EACJ,GAAIF,GAAYrE,EAAK,IAAI,EAAG,CAC1B,IAAM2E,EAAY3E,EAAK,KACvBgE,EAAO,IAAI,OAAOW,EAAU,QAASA,EAAU,KAAK,EACpDJ,EAAcR,EAChB,SAAW,OAAO/D,EAAK,MAAS,SAC9BgE,EAAOhE,EAAK,KACZuE,EAAcH,OACT,CACLzE,GAAuBK,EAAM,MAAM,EACnC,MACF,CAagBiC,EAXKC,GAAoB,CACvC,QAAWC,KAAKD,EAAO,CACrB,IAAME,EAAmB,EAAAlC,QAAK,KAAKF,EAAK,KAAMmC,CAAC,EAC3C,EAAAhC,QAAG,SAASiC,CAAQ,EAAE,YAAY,GAGtCkC,GAAuB,EAAApE,QAAK,KAAKF,EAAK,KAAMmC,CAAC,EAAGoC,EAAaP,EAAMhE,EAAK,QAAS0E,CAAI,CACvF,CACF,EAKE1E,EAAK,KACLqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnCqC,EAAmBrC,EAAK,QAAS,CAAC,CAAC,EACnC,GACA,EACF,GAIEsE,GAAuBtE,EAAK,KAAMuE,EAAaP,EAAMhE,EAAK,QAAS0E,CAAI,CAE3E,EE3gBO,IAAME,GAET,CACF,mBAAoBC,GACpB,QAASC,GACT,IAAKC,GACL,UAAWC,GACX,OAAQC,GACR,UAAWC,GACX,SAAUC,GACV,WAAYC,GACZ,UAAWC,GACX,YAAaC,GACb,kBAAmBC,EACrB,ERRO,IAAMC,EAAc,CAACC,EAAmBC,EAAcC,IAAqB,CAChF,IAAIC,EAAsB,CAAC,EAEvBC,EAAiB,EAAAC,QAAK,QAAQJ,EAAI,MAAM,EAC5C,GAAI,CACFE,EAAcG,EAAeF,CAAc,CAC7C,OAASG,EAAP,CACIA,aAAa,MACf,QAAQ,IAAIA,EAAE,OAAO,EAErB,QAAQ,IAAIA,CAAC,EAEf,QAAQ,IAAI,EAAE,EACdL,EAAQ,KAAK,CACf,CAEA,IAAIM,EAEAC,EAAqB,OACrBC,EAAeC,GACnB,GAAIR,EAAY,KAAO,OAAOA,EAAY,KAAQ,SAAU,CAC1D,IAAMS,EAAMT,EAAY,KAEpBS,EAAI,SAAWA,EAAI,cACrBH,EAAW,SAGTG,EAAI,UAAYC,EAAU,SAASD,EAAI,QAAQ,IACjDH,EAAWG,EAAI,UAGbA,EAAI,eACNF,EAAeE,EAAI,aAEvB,CAqBA,GAlBIX,EAAI,UAAYY,EAAU,SAASZ,EAAI,QAAQ,IACjDQ,EAAWR,EAAI,UAGbQ,IAAa,SAEfD,EAAW,GAAGM,CAAQ,IAAIC,CAAQ,IAAIC,CAAS,GAC/CR,EAAW,GAAGA,CAAQ,4BACbC,IAAa,SACtBD,EAAW,GAAGM,CAAQ,IAAIC,CAAQ,IAGhCP,GACF,GAAAS,QAAM,OAAOT,CAAQ,EAGvBU,EAAK,cAAejB,CAAG,EAEnB,OAAOS,GAAiB,SAC1B,MAAM,IAAI,MAAM,iBAAiBA,CAAY,qBAAqB,EAEpE,GAAIA,EAAa,OAAS,EACxB,MAAM,IAAI,MAAM,iBAAiBA,CAAY,mBAAmB,EAElE,GAAIA,EAAa,QAAQ,GAAG,EAAI,GAAKA,EAAa,QAAQ,GAAG,EAAI,EAC/D,MAAM,IAAI,MAAM,iBAAiBA,CAAY,gDAAgD,EAG/F,IAAMS,EAAU,EAAAd,QAAK,QAAQ,QAAQ,IAAI,CAAC,EAEpCe,EAAuB,CAC3B,UAAApB,EACA,QAAAmB,EACA,aAAc,IAAI,OAAOT,CAAY,EACrC,KAAM,CACJ,MAAO,CACL,YAAaV,EACb,SAAUmB,CACZ,CACF,CACF,EAEIlB,EAAI,YACNiB,EAAK,wDAAwD,EAC7DG,GAAoBpB,EAAI,UAAWqB,GAA0BrB,EAAI,UAAW,CAACsB,EAAaC,IAAkB,CAC1GC,EAAWL,EAASG,EAAKC,EAAO,EAAK,CACvC,CAAC,EAEDN,EAAK,oEAAoE,EACzEG,GAAoBpB,EAAI,UAAWyB,GAA8BzB,EAAI,UAAW,CAACsB,EAAaC,IAAkB,CAC9GG,EAAUP,EAASG,EAAKC,EAAO,EAAK,CACtC,CAAC,GAGHI,EAAK,EAAE,EACPA,EAAK,IAAIzB,EAAY,IAAI,yBAAyB,EAElD,IAAM0B,EAAsB,CAACC,EAAYC,IAChBA,GAAM,KACpBD,EAAK,KAAO,OAAY,IAAIC,CAAC,IAAID,EAAK,EAAE,IAAIA,EAAK,IAAI,GAAK,IAAIC,CAAC,IAAID,EAAK,IAAI,GAE5EA,EAAK,KAAO,OAAY,GAAGA,EAAK,EAAE,IAAIA,EAAK,IAAI,GAAK,GAAGA,EAAK,IAAI,IAI1D,SAAY,CAC3B,IAAIE,EAAqB7B,EAAY,OAAS,CAAC,EAE/C,QAAS4B,EAAI,EAAGA,EAAIC,EAAM,OAAQD,IAAK,CACrC,IAAMD,EAAOE,EAAMD,CAAC,EAGpB,GAAID,EAAK,KAAO,QAAaA,EAAK,KAAO,KAAM,CAC7C,GAAI,OAAOA,EAAK,IAAO,SACrB,MAAM,IAAI,MAAM,qCAAqC,EAGvD,GAAIA,EAAK,GAAG,OAAS,EACnB,MAAM,IAAI,MAAM,6BAA6B,EAG/C,QAASG,EAAIF,EAAI,EAAGE,EAAID,EAAM,OAAQC,IAAK,CACzC,IAAMC,EAAYF,EAAMC,CAAC,EACzB,GAAIC,EAAU,KAAO,QAAaA,EAAU,KAAOJ,EAAK,GACtD,MAAM,IAAI,MAAM,gBAAgBA,EAAK,EAAE,kBAAkB,CAE7D,CACF,CAEA,GAAI,CAACA,EAAK,MAAQ,EAAEA,EAAK,QAAQK,IAC/B,MAAM,IAAI,MAAM,gCAAgCL,EAAK,IAAI,GAAG,EAQ9D,GALAA,EAAK,oBAAsB,CAAC,EACxBA,EAAK,KACPA,EAAK,GAAKA,EAAK,GAAG,KAAK,EACvBA,EAAK,oBAAoB,KAAKA,EAAK,GAAG,KAAK,CAAC,GAE1CA,EAAK,KAAM,CACb,IAAMM,EAAoBC,GAAc,CACtCnB,EAAK,0BAA0BmB,CAAI,GAAG,CACxC,EACA,GAAI,OAAOP,EAAK,MAAS,SACnBA,EAAK,KAAK,OAAS,GACrBA,EAAK,KAAOA,EAAK,KAAK,KAAK,EAC3BA,EAAK,oBAAoB,KAAKA,EAAK,IAAI,GAEvCM,EAAiBN,EAAK,IAAI,UAEnB,MAAM,QAAQA,EAAK,IAAI,EAAG,CACnCA,EAAK,KAAOA,EAAK,KAAK,IAAKN,GAAkBA,EAAM,KAAK,CAAC,EACzD,QAAWc,KAAOR,EAAK,KACjB,OAAOQ,GAAQ,UAAYA,EAAI,OAAS,EAC1CR,EAAK,oBAAoB,KAAKQ,CAAG,EAEjCF,EAAiBE,CAAG,CAG1B,MACEF,EAAiBN,EAAK,IAAI,CAE9B,CACF,CAEA,GAAI7B,EAAI,SAAWA,EAAI,QAAQ,OAAS,EAAG,CACzC,IAAMsC,EAAetC,EAAI,QAEzBiB,EAAK,wDAAwDqB,CAAY,EAAE,EAC3EP,EAAQA,EAAM,OAAO,CAACQ,EAAgBC,EAAeC,IAAkB,CACrE,GAAIC,EAAYJ,EAAcC,EAAS,mBAAmB,IAAM,GAC9D,OAAOA,CAEX,CAAC,CACH,CACA,GAAIvC,EAAI,YAAcA,EAAI,WAAW,OAAS,EAAG,CAC/C,IAAM2C,EAAgB3C,EAAI,WAE1BiB,EAAK,4DAA4D0B,CAAa,EAAE,EAChFZ,EAAQA,EAAM,OAAO,CAACQ,EAAgBC,EAAeC,IAAkB,CACrE,GAAIG,GAAeD,EAAeJ,EAAS,mBAAmB,IAAM,GAClE,OAAOA,CAEX,CAAC,CACH,CACA,IAAMM,EAAoB7C,EAAI,SAAWA,EAAI,QAAQ,OAAS,EACxD8C,EAAuB9C,EAAI,YAAcA,EAAI,WAAW,OAAS,EACvE,GAAI6C,GAAqBC,EAAsB,CAC7C,IAAMC,EAAe/C,EAAI,QACnBgD,EAAkBhD,EAAI,WAE5BiB,EAAK,wDAAwD8B,CAAY,oBAAoBC,CAAe,EAAE,EAC9GjB,EAAQA,EAAM,OAAO,CAACQ,EAAgBC,EAAeC,KAAkB,CACrE,GACGI,GAAqBH,EAAYK,EAAeR,EAAS,mBAAmB,IAAM,IAClFO,GAAwBF,GAAeI,EAAkBT,EAAS,mBAAmB,IAAM,GAE5F,OAAOA,CAEX,CAAC,CACH,CAEAZ,EACE,WAAWI,EAAM,IAAI,CAACkB,EAAGnB,IAChBF,EAAoBqB,EAAGnB,CAAC,CAChC,CAAC,EACJ,EAEA,IAAMoB,GAAYnB,EAAM,QAAU,EAClC,QAASD,EAAI,EAAGA,EAAIoB,GAAWpB,IAAK,CAClC,IAAMD,EAAOE,EAAMD,CAAC,EACpB,MAAMqB,GAAehC,EAASU,CAAI,EAElC,IAAMuB,EAAmBxB,EAAoBC,EAAMC,CAAC,EACpD,GAAID,EAAK,UAAY,GAAO,CAC1BF,EAAK;AAAA,yCAA4CyB,CAAgB,EAAE,EACnE,QACF,MACEzB,EAAK;AAAA,aAAgByB,CAAgB,EAAE,EAGrCvB,EAAK,SACPF,EAAKE,EAAK,OAAO,EAGnB,IAAIwB,EAAgB,GACpB,GAAIxB,EAAK,IAAK,CACZ,IAAMyB,GAAU,EAAAlD,QAAK,QAAQyB,EAAK,GAAG,EACrCF,EAAK,6CAA6C2B,EAAO,EAAE,EAC3DD,EAAgB,GAChB,QAAQ,MAAMC,EAAO,CACvB,CAEA,IAAMC,GAAcrB,GAAWL,EAAK,IAAI,EACxC,MAAM0B,GAAYpC,EAASU,CAAI,EAE1B7B,EAAI,oBACHqD,GACF1B,EAAK,8CAA8CT,CAAO,EAAE,EAE9D,QAAQ,MAAMA,CAAO,EAEzB,CACF,GAES,EACN,KAAK,IAAM,CAAC,CAAC,EACb,MAAOsC,GAAgB,CACtB,MAAMA,CACR,CAAC,EACA,QAAQ,IAAM,CACb,QAAQ,MAAMtC,CAAO,EACrBS,EAAK,IAAIzB,EAAY,IAAI;AAAA,CAAgB,CAC3C,CAAC,CACL,EFxQA,IAAMuD,GAAY,GAAAC,QAAK,QAAQ,QAAQ,IAAI,CAAC,EACtCC,GAAcC,EAAM,EAC1BC,EAAYJ,GAAWE,GAAY,IAAKA,GAAY,OAAO","names":["src_exports","__export","usefulTasks","__toCommonJS","import_path","import_commander","import_path","DEFAULT_CONFIG","DEFAULT_USE_CAMEL","CwdRestore","CwdKeep","cwdModes","LogLevelInfo","LogLevelDebug","LogLevelNone","logLevels","argDesc","v","setup","userArgv","program","typedOptions","fixStringArrayArgument","path","value","skipEmptyItem","result","trimedValue","import_path","import_fs","import_path","import_json5","import_debug","LOG_TAG","TAG_DEBUG","TAG_INFO","TAG_WARN","DEFAULT_REPLACE_REGEX","VAR_FROM_ARGUMENT_PREFIX","ENV_VAR_FROM_ARGUMENT_PREFIX","logw","debug","TAG_WARN","logi","TAG_INFO","logv","TAG_DEBUG","loadFileOrThrow","filePath","logv","fs","loadJson","parseJson","content","json5","loadJsonConfig","configJson","filePathDir","path","extendsFilePath","convertOrNotHyphenTextToCamelText","text","flag","result","textArr","i","word","containsTag","elements","tags","el","tag","containsAllTag","contained","checkEmptyStringOrThrow","name","value","checkLegacyUsage","task","key","logw","checkType","allowedTypes","checkTypeOrThrow","valueType","ENV_LINE","parseLines","src","obj","lines","match","maybeQuote","import_debug","applyVariables","context","task","anyTypeTask","key","valueOfKey","match","matchedStr","varPath","currentVar","varPaths","i","varEl","valuePrefix","valueReplace","valueSuffix","logv","searchExtraKeyValue","extraArgs","fmt","convertToCamelKeys","callback","currentVarName","useNextElementAsVar","extraArg","value","equalMarkIndex","varName","convertOrNotHyphenTextToCamelText","setTaskVar","skipForExists","setEnvVar","valueType","import_string_argv","handleSubTasks","context","task","subArgv","stringArgv","setupResult","setup","usefulTasks","import_fs","import_child_process","import_path","import_simple_git","import_fs_extra","import_fs","import_glob","processWithGlobSync","handler","cwd","includes","excludes","skipDirs","includeAllIfNonFilters","fs","nodir","ilen","elen","throwInvalidParamError","obj","key","handleGitRepoSetup","context","task","localPath","path","fs","git","hasLocalBranch","branchLocal","b","branch","startPoint","handleSymlink","target","dstPath","lstat","logv","handleTerminalCommand","handleSetVar","checkLegacyUsage","checkTypeOrThrow","checkEmptyStringOrThrow","isFallback","value","setTaskVar","src","parser","runFunc","filePath","varsPath","content","loadFileOrThrow","parseJson","e","parseLines","processWithGlobSync","items","f","itemPath","resolveStringArray","handleEnvVar","setEnvVar","finalObj","handleOutput","text","targetPath","resolvedPath","dir","err","fd","val","defaultValue","v","runCopy","dst","options","handleFsCopy","conflict","overwrite","cpOpt","from","to","runDelete","handleFsDelete","handleMkdir","runFindAndReplaceWithRegex","find","replace","repeat","i","runFindAndReplaceWithText","isRegexData","findAndReplaceWithFile","replaceFunc","newContent","handleContentReplace","loop","regexData","handlerMap","handleGitRepoSetup","handleSymlink","handleTerminalCommand","handleSetVar","handleOutput","handleFsCopy","handleFsDelete","handleMkdir","handleEnvVar","handleSubTasks","handleContentReplace","usefulTasks","originCwd","opt","program","tasksConfig","configFilePath","path","loadJsonConfig","e","debugPat","logLevel","replaceRegex","DEFAULT_REPLACE_REGEX","env","logLevels","TAG_WARN","TAG_INFO","TAG_DEBUG","debug","logv","baseCwd","context","searchExtraKeyValue","VAR_FROM_ARGUMENT_PREFIX","key","value","setTaskVar","ENV_VAR_FROM_ARGUMENT_PREFIX","setEnvVar","logi","getTaskRepresentStr","task","i","tasks","j","otherTask","handlerMap","printInvalidTags","tags","tag","excludeItems","taskItem","index","array","containsTag","excludesItems","containsAllTag","hasIncludeFilters","hasIncludeCTAFilters","includeItems","includeCtaItems","v","taskCount","applyVariables","taskRepresentStr","cwdHasChanges","taskCwd","taskHandler","reason","originCwd","path","setupResult","setup","usefulTasks"]}