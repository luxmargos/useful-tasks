#!/usr/bin/env node
import we from"path";import{Command as ie}from"commander";import ce from"path";var le="useful_tasks.json",K=!0,A="restore",F="keep",pe=[A,F],de={cwdMode:`Choose between ${pe.map(n=>`'${n}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${A}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${F}' mode, the CWD will remain unchanged.`},S=n=>{let e=new ie;e.name("useful-tasks").version("0.1.20").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",le).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',K).option("--cwd-mode <string>",de.cwdMode,A).allowUnknownOption(!0),n!==void 0?e.parse(n,{from:"user"}):e.parse();let t=e.opts();if(t.include=_(t.include),t.includeCta=_(t.includeCta),t.exclude=_(t.exclude),t.excludeCta=_(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===F,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let o=t.camelKeys;o=o.trim().toLowerCase(),o==="false"||o==="0"||o==="no"?t.camelKeys=!1:o==="true"||o==="1"||o==="yes"?t.camelKeys=!0:t.camelKeys=K}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(ce.resolve(t.cwd)),{opt:t,program:e}},_=(n,e=!0)=>{if(!n)return[];if(typeof n=="string"){let r=[];return n.split(",").forEach(o=>{let i=o.trim();e?i.length>0&&r.push(i):r.push(i)}),r}return[]};import L from"path";import j from"fs";import U from"path";import fe from"json5";var O=n=>{if(!j.existsSync(n))throw new Error(`ERROR: The Path '${n}' does not exists!`);let e=j.readFileSync(n,{encoding:"utf-8"});return fe.parse(e)},I=n=>{let e=O(n);if(e.extends){let r=U.dirname(n),t=U.resolve(r,e.extends);e=Object.assign({},e,I(t))}return e},V=(n,e)=>{if(!e)return n;let r="",t=n.split("-");for(let o=0;o<t.length;o++){let i=t[o];o===0?r=i:(i.length>0&&(i=`${i[0].toUpperCase()}${i.substring(1)}`),r=`${r}${i}`)}return r},M=(n,e)=>{if(n.length<1)return!1;for(let r of n)for(let t of e)if(r===t)return!0;return!1},D=(n,e)=>{if(n.length<1)return!1;for(let r of n){let t=!1;for(let o of e)if(o===r){t=!0;break}if(!t)return!1}return!0};import ne from"debug";var h="useful-tasks",N="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",J="--var-",X="--env-";import ue from"debug";var v=ue(h),H=async(n,e)=>{let r=e;for(let t of Object.keys(r))if(typeof t=="string"&&!(t==="id"||t==="tags")&&r[t]!==void 0&&typeof r[t]=="string"){let o=r[t];for(;;){let i=n.replaceRegex.exec(o);if(i==null)break;let l=i[0],c=i[1],p=n.vars;if(c.length>0){let a=c.split(".");for(let y=0;y<a.length;y++){let b=a[y];if(p.hasOwnProperty(b))p=p[b];else throw new Error(`The value of ${c} could not be found!`)}}let m=o.substring(0,i.index),k=`${p}`,C=o.substring(i.index+l.length);o=`${m}${k}${C}`,v(`Updated value ${o}`)}r[t]=o}},P=(n,e,r,t)=>{let o,i=!1;for(let l of n){if(l.trim()==="--"){v("Stop parsing by '--'");break}if(i&&o){let p=l.startsWith("-")?"":l;t(o,p),o=void 0,i=!1}else if(l.indexOf(e)>=0){let m=l.indexOf("=");if(m>=0){let k=V(l.substring(e.length,m),r),C=l.substring(m+1);t(k,C)}else o=V(l.substring(e.length),r),i=!0}}},$=(n,e,r)=>{v(`Sets the variable ${e}=${r}`),n.vars[e]=r},E=(n,e,r)=>{var t=typeof r;t!=="string"&&t!=="number"&&t!=="boolean"?v(`Ignoring the invalid typed(${t}) environment variable ${e}=${r}`):String(r).length<1?v(`Ignoring the invalid environment variable ${e}=${r}`):(v(`Sets the environment variable ${e}=${r}`),process.env[e]=String(r))};import ge from"string-argv";import me from"debug";var qe=me(h),q=async(n,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let r=ge(e.args),t=S(r);w(n.originCwd,t.opt,t.program)};import g from"fs";import{execSync as ye}from"child_process";import x from"path";import{CheckRepoActions as he,ResetMode as Te,simpleGit as W}from"simple-git";import{copySync as xe,mkdirpSync as ke,removeSync as B}from"fs-extra";import ve from"debug";import be from"json5";var T=ve(h),Y=async(n,e)=>{let r=x.resolve(e.localPath);g.existsSync(r)||g.mkdirSync(r,{recursive:!0}),g.readdirSync(r).length===0&&e.url&&await W().clone(e.url,r);let t=W(r,{binary:e.binary});if(!await t.checkIsRepo(he.IS_REPO_ROOT))throw Error(`${r} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let l=!1,c=await t.branchLocal();for(var i of c.all)if(i===e.branch){l=!0;break}let p=e.branch??"",m=e.startPoint??"";l?(c.current!==e.branch&&await t.checkout(p),await t.reset(Te.HARD,[m])):await t.checkoutBranch(p,m)}},z=async(n,e)=>{let r=x.resolve(e.target),t=x.resolve(e.path);if(g.existsSync(t)){let o=g.lstatSync(t);T(`LSTAT is symlink? ${o.isSymbolicLink()}, is directory? ${o.isDirectory()}`),e.forced&&(o.isSymbolicLink()||o.isFile()?(T(`Unlink ${t}`),g.unlinkSync(t)):o.isDirectory()&&(T(`Remove directory '${t}'`),B(t)))}if(g.existsSync(t))T(`Could not create symbolic link cause '${t}' already exists`);else{T(`Create symbolic link ${r} => ${t}`),g.symlinkSync(r,t,e.linkType);let o=g.lstatSync(t);T(`LSTAT is symlink? ${o.isSymbolicLink()}, is directory? ${o.isDirectory()}`)}},Z=async(n,e)=>{T(`Start execution... ${e.cmd}`),ye(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},Q=async(n,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=x.resolve(r);if(!g.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);r=g.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(r=be.parse(r))}$(n,e.key,r)},ee=async(n,e)=>{let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=x.resolve(r);r=O(t)}if(typeof r!="object")throw new Error('The content of the "var" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(r).forEach(t=>{E(n,t,r[t])})},te=async(n,e)=>{let r=e.text??"",t=(e.target??"c").trim(),o=e.path;if(t==="c"||t==="console")console.log(r);else{if(!o)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let i=x.resolve(o),l=x.dirname(i);if(g.existsSync(l)||ke(l),t=="fa"||t=="file-append"){let c,p;try{p=g.openSync(i,"a"),g.appendFileSync(p,r,"utf8")}catch(m){c=m}finally{p!==void 0&&g.closeSync(p)}if(c)throw c}else g.writeFileSync(i,r)}},re=async(n,e)=>{let r=e?.options?.conflict!=="skip";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(r=e.options.overwrite),xe(e.src,e.dest,{overwrite:r})},se=async(n,e)=>{B(e.path)};var G={"git-repo-prepare":Y,symlink:z,cmd:Z,"set-var":Q,output:te,"fs-copy":re,"fs-del":se,"env-var":ee,"sub-tasks":q};var w=(n,e,r)=>{let t={},o=L.resolve(e.config);try{t=I(o)}catch(a){a instanceof Error?console.log(a.message):console.log(a),console.log(""),r.help()}let i="",l=N;if(t.env&&typeof t.env=="object"){let a=t.env;a.verbose&&(i=`${h}, ${h}:*`),a.verboseGit&&(i=`${i},simple-git,simple-git:*`),a.replaceRegex&&(l=a.replaceRegex)}if(typeof l!="string")throw new Error(`replaceRegex '${l}'  must be a string`);if(l.length<1)throw new Error(`replaceRegex '${l}' cannot be empty`);if(l.indexOf("(")<0||l.indexOf(")")<0)throw new Error(`replaceRegex '${l}' must contain regex group express '(' and ')'`);i&&ne.enable(i);let c=ne(h),p=L.resolve(process.cwd()),m={originCwd:n,baseCwd:p,replaceRegex:new RegExp(l),vars:{__env:{cwd_startup:n,cwd_base:p}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),P(e.extraArgs,J,e.camelKeys,(a,y)=>{$(m,a,y)}),c("Setting up the environment variables from the additional arguments"),P(e.extraArgs,X,e.camelKeys,(a,y)=>{E(m,a,y)})),c(""),c(`[${t.name}] Start task processing`);let k=(a,y)=>y!=null?a.id!==void 0?`[${y}]${a.id}/${a.type}`:`[${y}]${a.type}`:a.id!==void 0?`${a.id}/${a.type}`:`${a.type}`;(async()=>{let a=t.tasks??[];for(let d=0;d<a.length;d++){let s=a[d];if(s.id!==void 0&&s.id!==null){if(typeof s.id!="string")throw new Error("The task id must be a 'string' type");if(s.id.length<1)throw new Error("The task id cannot be empty");for(let f=d+1;f<a.length;f++){let u=a[f];if(u.id!==void 0&&u.id===s.id)throw new Error(`The task id '${s.id}' must be unique`)}}if(!s.type||!(s.type in G))throw new Error(`Found the invalid task type '${s.type}'`);if(s.__compare__elements=[],s.id&&(s.id=s.id.trim(),s.__compare__elements.push(s.id.trim())),s.tags){let f=u=>{c(`Ignoring invalid tags '${u}'`)};if(typeof s.tags=="string")s.tags.length>0?(s.tags=s.tags.trim(),s.__compare__elements.push(s.tags)):f(s.tags);else if(Array.isArray(s.tags)){s.tags=s.tags.map(u=>u.trim());for(let u of s.tags)typeof u=="string"&&u.length>0?s.__compare__elements.push(u):f(u)}else f(s.tags)}}if(e.exclude&&e.exclude.length>0){let d=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${d}`),a=a.filter((s,f,u)=>{if(M(d,s.__compare__elements)===!1)return s})}if(e.excludeCta&&e.excludeCta.length>0){let d=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${d}`),a=a.filter((s,f,u)=>{if(D(d,s.__compare__elements)===!1)return s})}let y=e.include&&e.include.length>0,b=e.includeCta&&e.includeCta.length>0;if(y||b){let d=e.include,s=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${d} / --include-cta=${s}`),a=a.filter((f,u,R)=>{if(y&&M(d,f.__compare__elements)===!0||b&&D(s,f.__compare__elements)===!0)return f})}c(`Tasks : ${a.map((d,s)=>k(d,s))}`);let ae=a.length??0;for(let d=0;d<ae;d++){let s=a[d];H(m,s);let f=k(s,d);if(s.enabled===!1){c(`
### Skip the task without execution => ${f}`);continue}else c(`
### Task : ${f}`);if(s.comment&&c(s.comment),s.cwd){let R=L.resolve(s.cwd);c(`Changing the current working directory => ${R}`),process.chdir(R)}let u=G[s.type];await u(m,s),e.cwdModeIsContinue||process.chdir(p)}})().then(()=>{}).catch(a=>{throw a}).finally(()=>{process.chdir(p),c(`[${t.name}] Tasks completed`),c("")})};var Ce=we.resolve(process.cwd()),oe=S();w(Ce,oe.opt,oe.program);export{w as usefulTasks};
//# sourceMappingURL=index.mjs.map