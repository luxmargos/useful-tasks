#!/usr/bin/env node
import qe from"path";import{Command as $e}from"commander";import _e from"path";var Re="useful_tasks.json",ee=!0,M="restore",N="keep",Ee=[M,N],Fe="info",Ae="debug",Oe="none",O=[Oe,Fe,Ae],Le={cwdMode:`Choose between ${Ee.map(n=>`'${n}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${M}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${N}' mode, the CWD will remain unchanged.`},L=n=>{let e=new $e;e.name("useful-tasks").version("0.2.0").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",Re).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',ee).option("--cwd-mode <string>",Le.cwdMode,M).option("--log-level <string>",`Specify the logging level as ${O.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),n!==void 0?e.parse(n,{from:"user"}):e.parse();let t=e.opts();if(t.include=A(t.include),t.includeCta=A(t.includeCta),t.exclude=A(t.exclude),t.excludeCta=A(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===N,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let r=t.camelKeys;r=r.trim().toLowerCase(),r==="false"||r==="0"||r==="no"?t.camelKeys=!1:r==="true"||r==="1"||r==="yes"?t.camelKeys=!0:t.camelKeys=ee}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(_e.resolve(t.cwd)),{opt:t,program:e}},A=(n,e=!0)=>{if(!n)return[];if(typeof n=="string"){let s=[];return n.split(",").forEach(r=>{let o=r.trim();e?o.length>0&&s.push(o):s.push(o)}),s}return[]};import Q from"path";import oe from"fs";import ie from"path";import Ge from"json5";import K from"debug";var U="useful-tasks",G=`${U}:debug`,$=`${U}:info`,_=`${U}:warn`,te="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",ne="--var-",re="--env-";var se=K(_),v=K($),c=K(G);var D=n=>{if(c(`Loading file: ${n}`),!oe.existsSync(n))throw new Error(`ERROR: The Path '${n}' does not exists!`);return oe.readFileSync(n,{encoding:"utf-8"})},De=n=>I(D(n)),I=n=>Ge.parse(n),W=n=>{let e=De(n);if(e.extends){let s=ie.dirname(n),t=ie.resolve(s,e.extends);e=Object.assign({},e,W(t))}return e},J=(n,e)=>{if(!e)return n;let s="",t=n.split("-");for(let r=0;r<t.length;r++){let o=t[r];r===0?s=o:(o.length>0&&(o=`${o[0].toUpperCase()}${o.substring(1)}`),s=`${s}${o}`)}return s},X=(n,e)=>{if(n.length<1)return!1;for(let s of n)for(let t of e)if(s===t)return!0;return!1},B=(n,e)=>{if(n.length<1)return!1;for(let s of n){let t=!1;for(let r of e)if(r===s){t=!0;break}if(!t)return!1}return!0},ae=(n,e)=>{if(!e)throw new Error(`The '${n}' property must not be empty.`)},k=(n,e)=>{n[e]!==void 0&&se(`The key '${e}' has been deprecated.`)},Ie=(n,e)=>e.length<=0?!0:e.includes(typeof n),V=(n,e,s)=>{if(Ie(e,s))return!0;let t=typeof e;throw new Error(`The '${n}' property has an invalid type '${t}' with the value '${e}'. The allowed types are ${s}.`)},Ve=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;function j(n){let e={},s=n.toString();s=s.replace(/\r\n?/gm,`
`);let t;for(;(t=Ve.exec(s))!=null;){let r=t[1],o=t[2]||"";o=o.trim();let p=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/gm,"$2"),p==='"'&&(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),e[r]=o}return e}import He from"debug";var le=async(n,e)=>{let s=e;for(let t of Object.keys(s))if(typeof t=="string"&&!(t==="id"||t==="tags")&&s[t]!==void 0&&typeof s[t]=="string"){let r=s[t];for(;;){let o=n.replaceRegex.exec(r);if(o==null)break;let p=o[0],f=o[1],l=n.vars;if(f.length>0){let i=f.split(".");for(let y=0;y<i.length;y++){let C=i[y];if(l.hasOwnProperty(C))l=l[C];else throw new Error(`The value of ${f} could not be found!`)}}let g=r.substring(0,o.index),d=`${l}`,b=r.substring(o.index+p.length);r=`${g}${d}${b}`,c(`Variable injection: '${t}'=>'${r}'`)}s[t]=r}},H=(n,e,s,t)=>{let r,o=!1;for(let p of n){if(p.trim()==="--"){c("Stop parsing by '--'");break}if(o&&r){let l=p.startsWith("-")?"":p;t(r,l),r=void 0,o=!1}else if(p.indexOf(e)>=0){let g=p.indexOf("=");if(g>=0){let d=J(p.substring(e.length,g),s),b=p.substring(g+1);t(d,b)}else r=J(p.substring(e.length),s),o=!0}}},R=(n,e,s,t)=>{if(t&&n.vars[e]!==void 0){c(`Skips assigning the variable ${e}=${s} because it already exists.`);return}c(`Sets the variable ${e}=${s}`),n.vars[e]=s},E=(n,e,s,t)=>{var r=typeof s;if(r!=="string"&&r!=="number"&&r!=="boolean")c(`Ignoring the invalid typed(${r}) environment variable ${e}=${s}`);else if(String(s).length<1)c(`Ignoring the invalid environment variable ${e}=${s}`);else{if(t&&process.env[e]!==void 0){c(`Skips assigning the environment variable ${e}=${s} because it already exists.`);return}c(`Sets the environment variable ${e}=${s}`),process.env[e]=String(s)}};import je from"string-argv";var ce=async(n,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let s=je(e.args),t=L(s);F(n.originCwd,t.opt,t.program)};import u from"fs";import{execSync as Me}from"child_process";import T from"path";import{CheckRepoActions as Ne,ResetMode as Ue,simpleGit as pe}from"simple-git";import{copySync as Ke,mkdirpSync as We,removeSync as ue}from"fs-extra";import Pe from"fs";import{globSync as P}from"glob";var S=(n,e,s,t,r,o)=>{if(Pe.statSync(e).isDirectory()===!1)return!1;let p=r===!0,f=s.length>0,l=t.length>0;return!f&&l?(n(P("**",{ignore:[".",...t],cwd:e,nodir:p})),!0):f&&!l?(n(P(s,{cwd:e,nodir:p})),!0):f&&l?(n(P(s,{ignore:t,cwd:e,nodir:p})),!0):o?(n(P("**",{ignore:["."],cwd:e,nodir:p})),!0):!1};var q=(n,e)=>{throw new Error(`The parameter '${String(e)}' has an invalid value ${n[e]}`)},me=async(n,e)=>{let s=T.resolve(e.localPath);u.existsSync(s)||u.mkdirSync(s,{recursive:!0}),u.readdirSync(s).length===0&&e.url&&await pe().clone(e.url,s);let t=pe(s,{binary:e.binary});if(!await t.checkIsRepo(Ne.IS_REPO_ROOT))throw Error(`${s} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let p=!1,f=await t.branchLocal();for(var o of f.all)if(o===e.branch){p=!0;break}let l=e.branch??"",g=e.startPoint??"";p?(f.current!==e.branch&&await t.checkout(l),await t.reset(Ue.HARD,[g])):await t.checkoutBranch(l,g)}},ye=async(n,e)=>{let s=T.resolve(e.target),t=T.resolve(e.path);if(u.existsSync(t)){let r=u.lstatSync(t);c(`LSTAT is symlink? ${r.isSymbolicLink()}, is directory? ${r.isDirectory()}`),e.forced&&(r.isSymbolicLink()||r.isFile()?(c(`Unlink ${t}`),u.unlinkSync(t)):r.isDirectory()&&(c(`Remove directory '${t}'`),ue(t)))}if(u.existsSync(t))c(`Could not create symbolic link cause '${t}' already exists`);else{c(`Create symbolic link ${s} => ${t}`),u.symlinkSync(s,t,e.linkType);let r=u.lstatSync(t);c(`LSTAT is symlink? ${r.isSymbolicLink()}, is directory? ${r.isDirectory()}`)}},he=async(n,e)=>{c(`Start execution... ${e.cmd}`),Me(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},xe=async(n,e)=>{k(e,"var"),k(e,"varType"),k(e,"fileFormat"),V("key",e.key,["string"]),ae("key",e.key),e.isFallback!==!0&&(e.isFallback=!1);let s=e.isFallback;if(e.value!==void 0){let l=e.value;R(n,e.key,l,s)}if(!e.src)return;V("src",e.src,["string"]);let t=e.src,r=e.parser||"auto";c(`Parser = ${r}`);let o=l=>{let g=T.resolve(l),d,b=D(g);if(r==="auto"||r==="json")try{c("Trying to parse as JSON."),d=I(b)}catch(i){if(r==="json")throw i}!d&&(r==="auto"||r==="lines")&&(c("Trying to parse as lines."),d=j(b)),!d&&(r==="auto"||r==="string")&&(d=b),R(n,e.key,d,s)};S(l=>{for(let g of l){let d=T.join(t,g);u.statSync(d).isDirectory()||o(d)}},t,w(e.include,[]),w(e.exclude,[]),!0,!0)||o(t)},Te=async(n,e)=>{k(e,"var"),k(e,"varType"),k(e,"fileFormat"),e.isFallback!==!0&&(e.isFallback=!1);let s=e.isFallback;if(e.value!==void 0){let l=e.value;typeof l=="string"&&(c("Trying to parse as lines."),l=j(l)),Object.keys(l).forEach(g=>{E(n,g,l[g],s)})}if(!e.src)return;V("src",e.src,["string"]);let t=e.src,r=e.parser||"auto";c(`Parser = ${r}`);let o=l=>{let g=T.resolve(l),d,b=D(g);if(r==="auto"||r==="json")try{c("Trying to parse as JSON."),d=I(b)}catch(i){if(r==="json")throw i}if(!d&&(r==="auto"||r==="lines")&&(c("Trying to parse as lines."),d=j(b)),d){let i=d;Object.keys(i).forEach(y=>{E(n,y,i[y],s)})}};S(l=>{for(let g of l){let d=T.join(t,g);u.statSync(d).isDirectory()||o(d)}},t,w(e.include,[]),w(e.exclude,[]),!0,!0)||o(t)},be=async(n,e)=>{let s=e.text??"",t=(e.target??"c").trim(),r=e.path;if(t==="c"||t==="console")console.log(s);else{if(!r)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let o=T.resolve(r),p=T.dirname(o);if(u.existsSync(p)||We(p),t=="fa"||t=="file-append"){let f,l;try{l=u.openSync(o,"a"),u.appendFileSync(l,s,"utf8")}catch(g){f=g}finally{l!==void 0&&u.closeSync(l)}if(f)throw f}else u.writeFileSync(o,s)}},w=(n,e)=>{if(n!=null){if(typeof n=="string")return[n];if(Array.isArray(n))return n.filter(s=>typeof s=="string")}return[]},fe=(n,e,s)=>{c(`Copy: ${n} => ${e}`),Ke(n,e,s)},ve=async(n,e)=>{if(!u.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let s=e?.options?.conflict,t=s==null||typeof s=="string"&&s.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let r={overwrite:t};S(f=>{for(let l of f){let g=T.join(e.src,l),d=T.join(e.dest,l);fe(g,d,r)}},e.src,w(e.include,[]),w(e.exclude,[]),!1,!1)||fe(e.src,e.dest,r)},ge=n=>{c(`Delete: ${n}`),ue(n)},we=async(n,e)=>{if(!u.existsSync(e.path)){c(`The '${e.path}' does not exist and cannot be deleted`);return}S(r=>{for(let o of r)ge(T.join(e.path,o))},e.path,w(e.include,[]),w(e.exclude,[]),!1,!1)||ge(e.path)},Je=(n,e,s,t)=>{var r=n;if(t<1)for(;e.test(r);)r=r.replace(e,s);else for(var o=0;o<t;o++)e.test(r)&&(r=r.replace(e,s));return r},Xe=(n,e,s,t)=>{var r=n;if(t<1)for(;r.indexOf(e)>=0;)r=r.replace(e,s);else for(var o=0;o<t;o++)r.indexOf(e)>=0&&(r=r.replace(e,s));return r},Be=n=>n!=null&&typeof n=="object"&&"pattern"in n&&typeof n.pattern=="string",de=(n,e,s,t,r)=>{c(`Find and Replace: ${n}`);let o=u.readFileSync(n,"utf-8"),p=e(o,s,t,r);u.writeFileSync(n,p,"utf-8")},ke=async(n,e)=>{if(!u.existsSync(e.path)){c(`The '${e.path}' does not exist`);return}(e.replace===void 0||typeof e.replace!="string")&&q(e,"replace");let s=e.loop===void 0||e.loop===null?1:e.loop;typeof s=="string"?s=parseInt(s,10):typeof s!="number"&&q(e,"loop");let t,r;if(Be(e.find)){let f=e.find;t=new RegExp(f.pattern,f.flags),r=Je}else if(typeof e.find=="string")t=e.find,r=Xe;else{q(e,"find");return}S(f=>{for(let l of f){let g=T.join(e.path,l);u.statSync(g).isDirectory()||de(T.join(e.path,l),r,t,e.replace,s)}},e.path,w(e.include,[]),w(e.exclude,[]),!0,!0)||de(e.path,r,t,e.replace,s)};var z={"git-repo-prepare":me,symlink:ye,cmd:he,"set-var":xe,output:be,"fs-copy":ve,"fs-del":we,"env-var":Te,"sub-tasks":ce,"content-replace":ke};var F=(n,e,s)=>{let t={},r=Q.resolve(e.config);try{t=W(r)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),s.help()}let o,p="info",f=te;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(p="debug"),i.logLevel&&O.includes(i.logLevel)&&(p=i.logLevel),i.replaceRegex&&(f=i.replaceRegex)}if(e.logLevel&&O.includes(e.logLevel)&&(p=e.logLevel),p==="debug"?(o=`${_},${$},${G}`,o=`${o},simple-git,simple-git:*`):p==="info"&&(o=`${_},${$}`),o&&He.enable(o),c("CLI Options",e),typeof f!="string")throw new Error(`replaceRegex '${f}'  must be a string`);if(f.length<1)throw new Error(`replaceRegex '${f}' cannot be empty`);if(f.indexOf("(")<0||f.indexOf(")")<0)throw new Error(`replaceRegex '${f}' must contain regex group express '(' and ')'`);let l=Q.resolve(process.cwd()),g={originCwd:n,baseCwd:l,replaceRegex:new RegExp(f),vars:{__env:{cwd_startup:n,cwd_base:l}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),H(e.extraArgs,ne,e.camelKeys,(i,y)=>{R(g,i,y,!1)}),c("Setting up the environment variables from the additional arguments"),H(e.extraArgs,re,e.camelKeys,(i,y)=>{E(g,i,y,!1)})),v(""),v(`[${t.name}] Start task processing`);let d=(i,y)=>y!=null?i.id!==void 0?`[${y}]${i.id}/${i.type}`:`[${y}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let m=0;m<i.length;m++){let a=i[m];if(a.id!==void 0&&a.id!==null){if(typeof a.id!="string")throw new Error("The task id must be a 'string' type");if(a.id.length<1)throw new Error("The task id cannot be empty");for(let x=m+1;x<i.length;x++){let h=i[x];if(h.id!==void 0&&h.id===a.id)throw new Error(`The task id '${a.id}' must be unique`)}}if(!a.type||!(a.type in z))throw new Error(`Found the invalid task type '${a.type}'`);if(a.__compare__elements=[],a.id&&(a.id=a.id.trim(),a.__compare__elements.push(a.id.trim())),a.tags){let x=h=>{c(`Ignoring invalid tags '${h}'`)};if(typeof a.tags=="string")a.tags.length>0?(a.tags=a.tags.trim(),a.__compare__elements.push(a.tags)):x(a.tags);else if(Array.isArray(a.tags)){a.tags=a.tags.map(h=>h.trim());for(let h of a.tags)typeof h=="string"&&h.length>0?a.__compare__elements.push(h):x(h)}else x(a.tags)}}if(e.exclude&&e.exclude.length>0){let m=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${m}`),i=i.filter((a,x,h)=>{if(X(m,a.__compare__elements)===!1)return a})}if(e.excludeCta&&e.excludeCta.length>0){let m=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${m}`),i=i.filter((a,x,h)=>{if(B(m,a.__compare__elements)===!1)return a})}let y=e.include&&e.include.length>0,C=e.includeCta&&e.includeCta.length>0;if(y||C){let m=e.include,a=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${m} / --include-cta=${a}`),i=i.filter((x,h,Z)=>{if(y&&X(m,x.__compare__elements)===!0||C&&B(a,x.__compare__elements)===!0)return x})}v(`Tasks : ${i.map((m,a)=>d(m,a))}`);let Ce=i.length??0;for(let m=0;m<Ce;m++){let a=i[m];await le(g,a);let x=d(a,m);if(a.enabled===!1){v(`
### Skip the task without execution => ${x}`);continue}else v(`
### Task : ${x}`);a.comment&&v(a.comment);let h=!1;if(a.cwd){let Y=Q.resolve(a.cwd);v(`Changing the current working directory => ${Y}`),h=!0,process.chdir(Y)}let Z=z[a.type];await Z(g,a),e.cwdModeIsContinue||(h&&v(`Restoring the current working directory => ${l}`),process.chdir(l))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(l),v(`[${t.name}] Tasks done
`)})};var ze=qe.resolve(process.cwd()),Se=L();F(ze,Se.opt,Se.program);export{F as usefulTasks};
//# sourceMappingURL=index.mjs.map