#!/usr/bin/env node
import Fe from"path";import{Command as me}from"commander";import ye from"path";var he="useful_tasks.json",q=!0,O="restore",D="keep",xe=[O,D],Te="info",ve="debug",ke="none",$=[ke,Te,ve],we={cwdMode:`Choose between ${xe.map(r=>`'${r}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${O}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${D}' mode, the CWD will remain unchanged.`},E=r=>{let e=new me;e.name("useful-tasks").version("0.1.25").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",he).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',q).option("--cwd-mode <string>",we.cwdMode,O).option("--log-level <string>",`Specify the logging level as ${$.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),r!==void 0?e.parse(r,{from:"user"}):e.parse();let t=e.opts();if(t.include=S(t.include),t.includeCta=S(t.includeCta),t.exclude=S(t.exclude),t.excludeCta=S(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===D,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let s=t.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?t.camelKeys=!1:s==="true"||s==="1"||s==="yes"?t.camelKeys=!0:t.camelKeys=q}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(ye.resolve(t.cwd)),{opt:t,program:e}},S=(r,e=!0)=>{if(!r)return[];if(typeof r=="string"){let n=[];return r.split(",").forEach(s=>{let a=s.trim();e?a.length>0&&n.push(a):n.push(a)}),n}return[]};import B from"path";import H from"fs";import W from"path";import be from"json5";var I=r=>{if(!H.existsSync(r))throw new Error(`ERROR: The Path '${r}' does not exists!`);let e=H.readFileSync(r,{encoding:"utf-8"});return be.parse(e)},V=r=>{let e=I(r);if(e.extends){let n=W.dirname(r),t=W.resolve(n,e.extends);e=Object.assign({},e,V(t))}return e},G=(r,e)=>{if(!e)return r;let n="",t=r.split("-");for(let s=0;s<t.length;s++){let a=t[s];s===0?n=a:(a.length>0&&(a=`${a[0].toUpperCase()}${a.substring(1)}`),n=`${n}${a}`)}return n},M=(r,e)=>{if(r.length<1)return!1;for(let n of r)for(let t of e)if(n===t)return!0;return!1},P=(r,e)=>{if(r.length<1)return!1;for(let n of r){let t=!1;for(let s of e)if(s===n){t=!0;break}if(!t)return!1}return!0};import Le from"debug";var Y="useful-tasks",R=`${Y}:debug`,C=`${Y}:info`,z="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",Z="--var-",Q="--env-";import ee from"debug";var f=ee(R),x=ee(C);var te=async(r,e)=>{let n=e;for(let t of Object.keys(n))if(typeof t=="string"&&!(t==="id"||t==="tags")&&n[t]!==void 0&&typeof n[t]=="string"){let s=n[t];for(;;){let a=r.replaceRegex.exec(s);if(a==null)break;let l=a[0],c=a[1],p=r.vars;if(c.length>0){let i=c.split(".");for(let m=0;m<i.length;m++){let b=i[m];if(p.hasOwnProperty(b))p=p[b];else throw new Error(`The value of ${c} could not be found!`)}}let u=s.substring(0,a.index),v=`${p}`,k=s.substring(a.index+l.length);s=`${u}${v}${k}`,f(`Variable applied '${t}'=>'${s}'`)}n[t]=s}},j=(r,e,n,t)=>{let s,a=!1;for(let l of r){if(l.trim()==="--"){f("Stop parsing by '--'");break}if(a&&s){let p=l.startsWith("-")?"":l;t(s,p),s=void 0,a=!1}else if(l.indexOf(e)>=0){let u=l.indexOf("=");if(u>=0){let v=G(l.substring(e.length,u),n),k=l.substring(u+1);t(v,k)}else s=G(l.substring(e.length),n),a=!0}}},A=(r,e,n)=>{f(`Sets the variable ${e}=${n}`),r.vars[e]=n},L=(r,e,n)=>{var t=typeof n;t!=="string"&&t!=="number"&&t!=="boolean"?f(`Ignoring the invalid typed(${t}) environment variable ${e}=${n}`):String(n).length<1?f(`Ignoring the invalid environment variable ${e}=${n}`):(f(`Sets the environment variable ${e}=${n}`),process.env[e]=String(n))};import Ce from"string-argv";var ne=async(r,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let n=Ce(e.args),t=E(n);_(r.originCwd,t.opt,t.program)};import d from"fs";import{execSync as _e}from"child_process";import T from"path";import{CheckRepoActions as Se,ResetMode as $e,simpleGit as re}from"simple-git";import{copySync as Ee,mkdirpSync as Re,removeSync as se}from"fs-extra";import Ae from"json5";import{globSync as w}from"glob";var oe=async(r,e)=>{let n=T.resolve(e.localPath);d.existsSync(n)||d.mkdirSync(n,{recursive:!0}),d.readdirSync(n).length===0&&e.url&&await re().clone(e.url,n);let t=re(n,{binary:e.binary});if(!await t.checkIsRepo(Se.IS_REPO_ROOT))throw Error(`${n} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let l=!1,c=await t.branchLocal();for(var a of c.all)if(a===e.branch){l=!0;break}let p=e.branch??"",u=e.startPoint??"";l?(c.current!==e.branch&&await t.checkout(p),await t.reset($e.HARD,[u])):await t.checkoutBranch(p,u)}},ie=async(r,e)=>{let n=T.resolve(e.target),t=T.resolve(e.path);if(d.existsSync(t)){let s=d.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(f(`Unlink ${t}`),d.unlinkSync(t)):s.isDirectory()&&(f(`Remove directory '${t}'`),se(t)))}if(d.existsSync(t))f(`Could not create symbolic link cause '${t}' already exists`);else{f(`Create symbolic link ${n} => ${t}`),d.symlinkSync(n,t,e.linkType);let s=d.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}},ae=async(r,e)=>{f(`Start execution... ${e.cmd}`),_e(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},le=async(r,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let n=e.value;if(n==null&&e.var&&(n=e.var),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.resolve(n);if(!d.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);n=d.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(n=Ae.parse(n))}A(r,e.key,n)},ce=async(r,e)=>{let n=e.value;if(n==null&&e.var&&(n=e.var),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.resolve(n);n=I(t)}if(typeof n!="object")throw new Error('The content of the "value" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(n).forEach(t=>{L(r,t,n[t])})},pe=async(r,e)=>{let n=e.text??"",t=(e.target??"c").trim(),s=e.path;if(t==="c"||t==="console")console.log(n);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let a=T.resolve(s),l=T.dirname(a);if(d.existsSync(l)||Re(l),t=="fa"||t=="file-append"){let c,p;try{p=d.openSync(a,"a"),d.appendFileSync(p,n,"utf8")}catch(u){c=u}finally{p!==void 0&&d.closeSync(p)}if(c)throw c}else d.writeFileSync(a,n)}};var F=(r,e)=>{if(r!=null){if(typeof r=="string")return[r];if(Array.isArray(r))return r.filter(n=>typeof n=="string")}return[]},N=(r,e,n)=>{f(`Copy: ${r} => ${e}`),Ee(r,e,n)},fe=async(r,e)=>{if(!d.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let n=e?.options?.conflict,t=n==null||typeof n=="string"&&n.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let s={overwrite:t};if(d.statSync(e.src).isDirectory()===!1){N(e.src,e.dest,s);return}let a=F(e.include,[]),l=F(e.exclude,[]),c=v=>{for(let k of v){let i=T.join(e.src,k),m=T.join(e.dest,k);N(i,m,s)}},p=a.length>0,u=l.length>0;!p&&u?c(w("**",{ignore:l,cwd:e.src})):p&&!u?c(w(a,{cwd:e.src})):p&&u?c(w(a,{ignore:l,cwd:e.src})):N(e.src,e.dest,s)},U=r=>{f(`Delete: ${r}`),se(r)},ge=async(r,e)=>{if(!d.existsSync(e.path)){f(`The '${e.path}' does not exist and cannot be deleted`);return}if(d.statSync(e.path).isDirectory()===!1){U(e.path);return}let n=F(e.include,[]),t=F(e.exclude,[]),s=c=>{for(let p of c)U(T.join(e.path,p))},a=n.length>0,l=t.length>0;!a&&l?s(w("**",{ignore:t,cwd:e.path})):a&&!l?s(w(n,{cwd:e.path})):a&&l?s(w(n,{ignore:t,cwd:e.path})):U(e.path)};var K={"git-repo-prepare":oe,symlink:ie,cmd:ae,"set-var":le,output:pe,"fs-copy":fe,"fs-del":ge,"env-var":ce,"sub-tasks":ne};var _=(r,e,n)=>{let t={},s=B.resolve(e.config);try{t=V(s)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),n.help()}let a,l="info",c=z;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(l="debug"),i.logLevel&&$.includes(i.logLevel)&&(l=i.logLevel),i.replaceRegex&&(c=i.replaceRegex)}if(e.logLevel&&$.includes(e.logLevel)&&(l=e.logLevel),l==="debug"?(a=`${C},${R}`,a=`${a},simple-git,simple-git:*`):l==="info"&&(a=`${C}`),a&&Le.enable(a),f("CLI Options",e),typeof c!="string")throw new Error(`replaceRegex '${c}'  must be a string`);if(c.length<1)throw new Error(`replaceRegex '${c}' cannot be empty`);if(c.indexOf("(")<0||c.indexOf(")")<0)throw new Error(`replaceRegex '${c}' must contain regex group express '(' and ')'`);let p=B.resolve(process.cwd()),u={originCwd:r,baseCwd:p,replaceRegex:new RegExp(c),vars:{__env:{cwd_startup:r,cwd_base:p}}};e.extraArgs&&(f("Setting up the variables from the additional arguments"),j(e.extraArgs,Z,e.camelKeys,(i,m)=>{A(u,i,m)}),f("Setting up the environment variables from the additional arguments"),j(e.extraArgs,Q,e.camelKeys,(i,m)=>{L(u,i,m)})),x(""),x(`[${t.name}] Start task processing`);let v=(i,m)=>m!=null?i.id!==void 0?`[${m}]${i.id}/${i.type}`:`[${m}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let g=0;g<i.length;g++){let o=i[g];if(o.id!==void 0&&o.id!==null){if(typeof o.id!="string")throw new Error("The task id must be a 'string' type");if(o.id.length<1)throw new Error("The task id cannot be empty");for(let h=g+1;h<i.length;h++){let y=i[h];if(y.id!==void 0&&y.id===o.id)throw new Error(`The task id '${o.id}' must be unique`)}}if(!o.type||!(o.type in K))throw new Error(`Found the invalid task type '${o.type}'`);if(o.__compare__elements=[],o.id&&(o.id=o.id.trim(),o.__compare__elements.push(o.id.trim())),o.tags){let h=y=>{f(`Ignoring invalid tags '${y}'`)};if(typeof o.tags=="string")o.tags.length>0?(o.tags=o.tags.trim(),o.__compare__elements.push(o.tags)):h(o.tags);else if(Array.isArray(o.tags)){o.tags=o.tags.map(y=>y.trim());for(let y of o.tags)typeof y=="string"&&y.length>0?o.__compare__elements.push(y):h(y)}else h(o.tags)}}if(e.exclude&&e.exclude.length>0){let g=e.exclude;f(`Excluding tasks by specified IDs or Tags : --exclude=${g}`),i=i.filter((o,h,y)=>{if(M(g,o.__compare__elements)===!1)return o})}if(e.excludeCta&&e.excludeCta.length>0){let g=e.excludeCta;f(`Excluding tasks by specified IDs or Tags : --exclude-cta=${g}`),i=i.filter((o,h,y)=>{if(P(g,o.__compare__elements)===!1)return o})}let m=e.include&&e.include.length>0,b=e.includeCta&&e.includeCta.length>0;if(m||b){let g=e.include,o=e.includeCta;f(`Including tasks by specified IDs or Tags : --include=${g} / --include-cta=${o}`),i=i.filter((h,y,J)=>{if(m&&M(g,h.__compare__elements)===!0||b&&P(o,h.__compare__elements)===!0)return h})}x(`Tasks : ${i.map((g,o)=>v(g,o))}`);let ue=i.length??0;for(let g=0;g<ue;g++){let o=i[g];te(u,o);let h=v(o,g);if(o.enabled===!1){x(`
### Skip the task without execution => ${h}`);continue}else x(`
### Task : ${h}`);o.comment&&x(o.comment);let y=!1;if(o.cwd){let X=B.resolve(o.cwd);x(`Changing the current working directory => ${X}`),y=!0,process.chdir(X)}let J=K[o.type];await J(u,o),e.cwdModeIsContinue||(y&&x(`Restoring the current working directory => ${p}`),process.chdir(p))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(p),x(`[${t.name}] Tasks done
`)})};var Oe=Fe.resolve(process.cwd()),de=E();_(Oe,de.opt,de.program);export{_ as usefulTasks};
//# sourceMappingURL=index.mjs.map