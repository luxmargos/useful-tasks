#!/usr/bin/env node
import Ee from"path";import{Command as de}from"commander";import ge from"path";var ue="useful_tasks.json",K=!0,A="restore",F="keep",me=[A,F],B="info",ye="debug",he="none",$=[he,B,ye],xe={cwdMode:`Choose between ${me.map(s=>`'${s}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${A}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${F}' mode, the CWD will remain unchanged.`},S=s=>{let e=new de;e.name("useful-tasks").version("0.1.24").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",ue).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',K).option("--cwd-mode <string>",xe.cwdMode,A).option("--log-level <string>",`Specify the logging level as ${$.join(",")}. This parameter takes higher priority than the 'json' configuration.`,B).allowUnknownOption(!0),s!==void 0?e.parse(s,{from:"user"}):e.parse();let t=e.opts();if(t.include=C(t.include),t.includeCta=C(t.includeCta),t.exclude=C(t.exclude),t.excludeCta=C(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===F,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let o=t.camelKeys;o=o.trim().toLowerCase(),o==="false"||o==="0"||o==="no"?t.camelKeys=!1:o==="true"||o==="1"||o==="yes"?t.camelKeys=!0:t.camelKeys=K}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(ge.resolve(t.cwd)),{opt:t,program:e}},C=(s,e=!0)=>{if(!s)return[];if(typeof s=="string"){let r=[];return s.split(",").forEach(o=>{let a=o.trim();e?a.length>0&&r.push(a):r.push(a)}),r}return[]};import U from"path";import J from"fs";import X from"path";import Te from"json5";var O=s=>{if(!J.existsSync(s))throw new Error(`ERROR: The Path '${s}' does not exists!`);let e=J.readFileSync(s,{encoding:"utf-8"});return Te.parse(e)},I=s=>{let e=O(s);if(e.extends){let r=X.dirname(s),t=X.resolve(r,e.extends);e=Object.assign({},e,I(t))}return e},V=(s,e)=>{if(!e)return s;let r="",t=s.split("-");for(let o=0;o<t.length;o++){let a=t[o];o===0?r=a:(a.length>0&&(a=`${a[0].toUpperCase()}${a.substring(1)}`),r=`${r}${a}`)}return r},G=(s,e)=>{if(s.length<1)return!1;for(let r of s)for(let t of e)if(r===t)return!0;return!1},D=(s,e)=>{if(s.length<1)return!1;for(let r of s){let t=!1;for(let o of e)if(o===r){t=!0;break}if(!t)return!1}return!0};import Se from"debug";var H="useful-tasks",E=`${H}:debug`,b=`${H}:info`,q="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",W="--var-",Y="--env-";import z from"debug";var l=z(E),x=z(b);var Z=async(s,e)=>{let r=e;for(let t of Object.keys(r))if(typeof t=="string"&&!(t==="id"||t==="tags")&&r[t]!==void 0&&typeof r[t]=="string"){let o=r[t];for(;;){let a=s.replaceRegex.exec(o);if(a==null)break;let c=a[0],p=a[1],f=s.vars;if(p.length>0){let i=p.split(".");for(let h=0;h<i.length;h++){let v=i[h];if(f.hasOwnProperty(v))f=f[v];else throw new Error(`The value of ${p} could not be found!`)}}let y=o.substring(0,a.index),k=`${f}`,_=o.substring(a.index+c.length);o=`${y}${k}${_}`,l(`Updated value ${o}`)}r[t]=o}},M=(s,e,r,t)=>{let o,a=!1;for(let c of s){if(c.trim()==="--"){l("Stop parsing by '--'");break}if(a&&o){let f=c.startsWith("-")?"":c;t(o,f),o=void 0,a=!1}else if(c.indexOf(e)>=0){let y=c.indexOf("=");if(y>=0){let k=V(c.substring(e.length,y),r),_=c.substring(y+1);t(k,_)}else o=V(c.substring(e.length),r),a=!0}}},L=(s,e,r)=>{l(`Sets the variable ${e}=${r}`),s.vars[e]=r},R=(s,e,r)=>{var t=typeof r;t!=="string"&&t!=="number"&&t!=="boolean"?l(`Ignoring the invalid typed(${t}) environment variable ${e}=${r}`):String(r).length<1?l(`Ignoring the invalid environment variable ${e}=${r}`):(l(`Sets the environment variable ${e}=${r}`),process.env[e]=String(r))};import ke from"string-argv";var Q=async(s,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let r=ke(e.args),t=S(r);w(s.originCwd,t.opt,t.program)};import m from"fs";import{execSync as ve}from"child_process";import T from"path";import{CheckRepoActions as be,ResetMode as we,simpleGit as ee}from"simple-git";import{copySync as _e,mkdirpSync as Ce,removeSync as te}from"fs-extra";import $e from"json5";var re=async(s,e)=>{let r=T.resolve(e.localPath);m.existsSync(r)||m.mkdirSync(r,{recursive:!0}),m.readdirSync(r).length===0&&e.url&&await ee().clone(e.url,r);let t=ee(r,{binary:e.binary});if(!await t.checkIsRepo(be.IS_REPO_ROOT))throw Error(`${r} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let c=!1,p=await t.branchLocal();for(var a of p.all)if(a===e.branch){c=!0;break}let f=e.branch??"",y=e.startPoint??"";c?(p.current!==e.branch&&await t.checkout(f),await t.reset(we.HARD,[y])):await t.checkoutBranch(f,y)}},ne=async(s,e)=>{let r=T.resolve(e.target),t=T.resolve(e.path);if(m.existsSync(t)){let o=m.lstatSync(t);l(`LSTAT is symlink? ${o.isSymbolicLink()}, is directory? ${o.isDirectory()}`),e.forced&&(o.isSymbolicLink()||o.isFile()?(l(`Unlink ${t}`),m.unlinkSync(t)):o.isDirectory()&&(l(`Remove directory '${t}'`),te(t)))}if(m.existsSync(t))l(`Could not create symbolic link cause '${t}' already exists`);else{l(`Create symbolic link ${r} => ${t}`),m.symlinkSync(r,t,e.linkType);let o=m.lstatSync(t);l(`LSTAT is symlink? ${o.isSymbolicLink()}, is directory? ${o.isDirectory()}`)}},se=async(s,e)=>{l(`Start execution... ${e.cmd}`),ve(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},oe=async(s,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=T.resolve(r);if(!m.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);r=m.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(r=$e.parse(r))}L(s,e.key,r)},ie=async(s,e)=>{let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=T.resolve(r);r=O(t)}if(typeof r!="object")throw new Error('The content of the "var" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(r).forEach(t=>{R(s,t,r[t])})},ae=async(s,e)=>{let r=e.text??"",t=(e.target??"c").trim(),o=e.path;if(t==="c"||t==="console")console.log(r);else{if(!o)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let a=T.resolve(o),c=T.dirname(a);if(m.existsSync(c)||Ce(c),t=="fa"||t=="file-append"){let p,f;try{f=m.openSync(a,"a"),m.appendFileSync(f,r,"utf8")}catch(y){p=y}finally{f!==void 0&&m.closeSync(f)}if(p)throw p}else m.writeFileSync(a,r)}},le=async(s,e)=>{let r=e?.options?.conflict!=="skip";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(r=e.options.overwrite),_e(e.src,e.dest,{overwrite:r})},ce=async(s,e)=>{te(e.path)};var P={"git-repo-prepare":re,symlink:ne,cmd:se,"set-var":oe,output:ae,"fs-copy":le,"fs-del":ce,"env-var":ie,"sub-tasks":Q};var w=(s,e,r)=>{let t={},o=U.resolve(e.config);try{t=I(o)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),r.help()}let a,c="info",p=q;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(c="debug"),i.logLevel&&$.includes(i.logLevel)&&(c=i.logLevel),i.replaceRegex&&(p=i.replaceRegex)}if(e.logLevel&&$.includes(e.logLevel)&&(c=e.logLevel),c==="debug"?(a=`${b},${E}`,a=`${a},simple-git,simple-git:*`):c==="info"&&(a=`${b}`),a&&Se.enable(a),l("CLI Options",e),typeof p!="string")throw new Error(`replaceRegex '${p}'  must be a string`);if(p.length<1)throw new Error(`replaceRegex '${p}' cannot be empty`);if(p.indexOf("(")<0||p.indexOf(")")<0)throw new Error(`replaceRegex '${p}' must contain regex group express '(' and ')'`);let f=U.resolve(process.cwd()),y={originCwd:s,baseCwd:f,replaceRegex:new RegExp(p),vars:{__env:{cwd_startup:s,cwd_base:f}}};e.extraArgs&&(l("Setting up the variables from the additional arguments"),M(e.extraArgs,W,e.camelKeys,(i,h)=>{L(y,i,h)}),l("Setting up the environment variables from the additional arguments"),M(e.extraArgs,Y,e.camelKeys,(i,h)=>{R(y,i,h)})),x(""),x(`[${t.name}] Start task processing`);let k=(i,h)=>h!=null?i.id!==void 0?`[${h}]${i.id}/${i.type}`:`[${h}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let d=0;d<i.length;d++){let n=i[d];if(n.id!==void 0&&n.id!==null){if(typeof n.id!="string")throw new Error("The task id must be a 'string' type");if(n.id.length<1)throw new Error("The task id cannot be empty");for(let u=d+1;u<i.length;u++){let g=i[u];if(g.id!==void 0&&g.id===n.id)throw new Error(`The task id '${n.id}' must be unique`)}}if(!n.type||!(n.type in P))throw new Error(`Found the invalid task type '${n.type}'`);if(n.__compare__elements=[],n.id&&(n.id=n.id.trim(),n.__compare__elements.push(n.id.trim())),n.tags){let u=g=>{l(`Ignoring invalid tags '${g}'`)};if(typeof n.tags=="string")n.tags.length>0?(n.tags=n.tags.trim(),n.__compare__elements.push(n.tags)):u(n.tags);else if(Array.isArray(n.tags)){n.tags=n.tags.map(g=>g.trim());for(let g of n.tags)typeof g=="string"&&g.length>0?n.__compare__elements.push(g):u(g)}else u(n.tags)}}if(e.exclude&&e.exclude.length>0){let d=e.exclude;l(`Excluding tasks by specified IDs or Tags : --exclude=${d}`),i=i.filter((n,u,g)=>{if(G(d,n.__compare__elements)===!1)return n})}if(e.excludeCta&&e.excludeCta.length>0){let d=e.excludeCta;l(`Excluding tasks by specified IDs or Tags : --exclude-cta=${d}`),i=i.filter((n,u,g)=>{if(D(d,n.__compare__elements)===!1)return n})}let h=e.include&&e.include.length>0,v=e.includeCta&&e.includeCta.length>0;if(h||v){let d=e.include,n=e.includeCta;l(`Including tasks by specified IDs or Tags : --include=${d} / --include-cta=${n}`),i=i.filter((u,g,j)=>{if(h&&G(d,u.__compare__elements)===!0||v&&D(n,u.__compare__elements)===!0)return u})}x(`Tasks : ${i.map((d,n)=>k(d,n))}`);let fe=i.length??0;for(let d=0;d<fe;d++){let n=i[d];Z(y,n);let u=k(n,d);if(n.enabled===!1){x(`
### Skip the task without execution => ${u}`);continue}else x(`
### Task : ${u}`);n.comment&&x(n.comment);let g=!1;if(n.cwd){let N=U.resolve(n.cwd);x(`Changing the current working directory => ${N}`),g=!0,process.chdir(N)}let j=P[n.type];await j(y,n),e.cwdModeIsContinue||(g&&x(`Restoring the current working directory => ${f}`),process.chdir(f))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(f),l(`[${t.name}] Tasks completed`),l("")})};var Le=Ee.resolve(process.cwd()),pe=S();w(Le,pe.opt,pe.program);export{w as usefulTasks};
//# sourceMappingURL=index.mjs.map