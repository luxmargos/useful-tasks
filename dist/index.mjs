#!/usr/bin/env node
import tn from"path";import{Command as nt}from"commander";import rt from"path";var ue="0.3.0";var st="useful_tasks.json",de=!0,j="restore",R="keep",ot=[j,R],it="info",at="debug",ct="none",D=[ct,it,at],lt={cwdMode:`Choose between ${ot.map(t=>`'${t}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${j}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${R}' mode, the CWD will remain unchanged.`},H=t=>{let e=new nt;e.name("useful-tasks").version(ue).option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",st).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',de).option("--cwd-mode <string>",lt.cwdMode).option("--log-level <string>",`Specify the logging level as ${D.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),t!==void 0?e.parse(t,{from:"user"}):e.parse();let r=e.opts();if(r.include=J(r.include),r.includeCta=J(r.includeCta),r.exclude=J(r.exclude),r.excludeCta=J(r.excludeCta),r.camelKeys!==void 0&&typeof r.camelKeys=="string"){let s=r.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?r.camelKeys=!1:s==="true"||s==="1"||s==="yes"?r.camelKeys=!0:r.camelKeys=de}return r.extraArgs=[...e.args??[]],r.cwd&&process.chdir(rt.resolve(r.cwd)),{opt:r,program:e}},J=(t,e=!0)=>{if(!t)return[];if(typeof t=="string"){let o=[];return t.split(",").forEach(s=>{let i=s.trim();e?i.length>0&&o.push(i):o.push(i)}),o}return[]};import me from"path";import Se from"fs";import we from"path";import Et from"json5";import re from"debug";import{z as n}from"zod";import pt from"os";var B="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",O=(t,e)=>Te.extend({type:n.literal(t),...e}),q=n.union([n.string().nonempty(),n.array(n.string().nonempty())]).optional(),dn=n.object({include:q,exclude:q}),L=(t,e)=>Te.extend({type:n.literal(t),...e,include:q,exclude:q}),xe=t=>({...t,__compare__elements:[]});var ft=n.union([n.literal("git-setup"),n.literal("cmd"),n.literal("set-var"),n.literal("output"),n.literal("symlink"),n.literal("fs-copy"),n.literal("fs-del"),n.literal("fs-mkdir"),n.literal("env-var"),n.literal("sub-tasks"),n.literal("content-replace")]),ge=["aix","android","darwin","freebsd","haiku","linux","openbsd","sunos","win32","cygwin","netbsd"],gn=[...ge,...ge.map(t=>`!${t}`)],ye=["arm","arm64","ia32","mips","mipsel","ppc","ppc64","s390","s390x","x64"],yn=[...ye,...ye.map(t=>`!${t}`)],he=["arm","arm64","aarch64","mips","mips64","ppc64","ppc64le","s390","s390x","i386","i686","x86_64"],hn=[...he,...he.map(t=>`!${t}`)];pt.machine();var mt=n.object({platform:n.custom().optional(),architecture:n.custom().optional(),machine:n.custom().optional()}),Te=n.object({type:ft,id:n.string().trim().nonempty().optional(),tags:n.union([n.string().trim().nonempty(),n.array(n.string().trim().nonempty())]).optional().transform(t=>t?typeof t=="string"?[t]:t:[]),cwd:n.string().nonempty().optional(),enabled:n.boolean().default(!0),when:mt.optional(),comment:n.string().optional(),onError:n.union([n.literal("skip"),n.literal("throw"),n.literal("warn")]).default("throw")}),ut=O("git-setup",{localPath:n.string().nonempty(),binary:n.string().nonempty().optional(),url:n.string().nonempty().optional(),branch:n.string().nonempty().optional(),startPoint:n.string().nonempty().optional(),updateSubmodules:n.union([n.string().nonempty(),n.string().nonempty(),n.boolean()]).optional()}),dt=O("symlink",{type:n.literal("symlink"),target:n.string().nonempty(),path:n.string().nonempty(),linkType:n.union([n.literal("dir"),n.literal("file"),n.literal("junction")]).optional(),forced:n.boolean().optional()}),gt=O("cmd",{cmd:n.string(),shell:n.string().optional()}),yt=L("set-var",{key:n.string().nonempty(),value:n.union([n.string(),n.number(),n.boolean(),n.any()]),src:n.string().nonempty().optional(),parser:n.union([n.literal("json"),n.literal("lines"),n.literal("string"),n.literal("auto")]).optional(),isFallback:n.boolean().optional().describe("If the variable already exists, assigning will be skipped")}),ht=L("env-var",{map:n.map(n.string(),n.union([n.string(),n.number(),n.boolean()])).optional(),src:n.string().nonempty().optional(),parser:n.union([n.literal("json"),n.literal("lines"),n.literal("auto")]).default("auto"),isFallback:n.boolean().optional().describe("If the environment variable already exists, assigning will be skipped")}),xt=n.union([n.literal("console").describe("Output to console"),n.literal("file-write").describe("Output to file (overwriting)"),n.literal("file-append").describe("Output to file (appending)"),n.literal("c").describe("Output to console"),n.literal("fw").describe("Output to file (overwriting)"),n.literal("fa").describe("Output to file (appending)")]),Tt=O("output",{target:xt,text:n.string(),path:n.string().nonempty().optional()}),kt=n.object({conflict:n.union([n.literal("overwrite"),n.literal("skip")]).default("overwrite")}),bt=L("fs-copy",{src:n.string().nonempty(),dest:n.string().nonempty(),options:kt.default({conflict:"overwrite"})}),vt=L("fs-del",{path:n.string().nonempty()}),St=O("fs-mkdir",{path:n.string().nonempty()}),wt=O("sub-tasks",{args:n.string().optional(),inherits:n.object({args:n.boolean().default(!0),vars:n.boolean().default(!0)}).optional().describe("Whether to inherit args and vars from the parent task.")}),_t=n.object({pattern:n.string(),flags:n.string().optional()}),Ct=n.union([n.string().nonempty(),_t]),Rt=L("content-replace",{path:n.string().nonempty().describe(`If the task includes 'include' or 'exclude',       it will be handled as a directory. 
      Otherwise, it will be processed as a file.`),find:Ct,replace:n.string(),loop:n.number().optional()}),$t=n.union([ut,gt,yt,ht,Tt,bt,vt,St,dt,wt,Rt]),ke=n.object({name:n.string().optional(),env:n.object({logLevel:n.enum(D).default("info"),varReplaceRegex:n.string().nonempty().default(B).describe("The regex to replace text with variable values").refine(t=>t.indexOf("(")>=0&&t.indexOf(")")>=0,{message:"The Regex must contains regex group express '(' and ')'"}),envReplaceRegex:n.string().nonempty().default(B).describe("The regex to replace text with environment variable values").refine(t=>t.indexOf("(")>=0&&t.indexOf(")")>=0,{message:"The Regex must contains regex group express '(' and ')'"}),cwdMode:n.union([n.literal(j),n.literal(R)]).default(j)}).default({logLevel:"info",varReplaceRegex:B,envReplaceRegex:B}),tasks:n.array($t).default([])}),ne="useful-tasks",X=`${ne}:debug`,I=`${ne}:info`,G=`${ne}:warn`,be="--var-",ve="--env-";var Z=re(G),S=re(I),a=re(X);import{assignIn as Ft}from"es-toolkit/compat";var V=t=>{if(a(`Loading file: ${t}`),!Se.existsSync(t))throw new Error(`ERROR: The Path '${t}' does not exists!`);return Se.readFileSync(t,{encoding:"utf-8"})},Ot=t=>M(V(t)),M=t=>Et.parse(t),se=t=>{let e=Ot(t);if(e.extends){let o=we.dirname(t),r=we.resolve(o,e.extends);e=Ft({},e,se(r))}return e},oe=(t,e)=>{if(!e)return t;let o="",r=t.split("-");for(let s=0;s<r.length;s++){let i=r[s];s===0?o=i:(i.length>0&&(i=`${i[0].toUpperCase()}${i.substring(1)}`),o=`${o}${i}`)}return o},ie=(t,e)=>{if(t.length<1)return!1;for(let o of t)if(e){for(let r of e)if(o===r)return!0}return!1},ae=(t,e)=>{if(t.length<1)return!1;for(let o of t){let r=!1;if(e){for(let s of e)if(s===o){r=!0;break}}if(!r)return!1}return!0},_e=(t,e)=>{if(!e)throw new Error(`The '${t}' property must not be empty.`)},C=(t,e)=>{t[e]!==void 0&&Z(`The key '${e}' has been deprecated.`)},At=(t,e)=>e.length<=0?!0:e.includes(typeof t),$=(t,e,o)=>{if(At(e,o))return!0;let r=typeof e;throw new Error(`The '${t}' property has an invalid type '${r}' with the value '${e}'. The allowed types are [${o}].`)},jt=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;function P(t){let e={},o=t.toString();o=o.replace(/\r\n?/gm,`
`);let r;for(;(r=jt.exec(o))!=null;){let s=r[1],i=r[2]||"";i=i.trim();let m=i[0];i=i.replace(/^(['"`])([\s\S]*)\1$/gm,"$2"),m==='"'&&(i=i.replace(/\\n/g,`
`),i=i.replace(/\\r/g,"\r")),e[s]=i}return e}var Q=(t,e)=>{throw new Error(`The parameter '${String(e)}' has an invalid value ${t[e]}`)},k=(t,e)=>{if(t!=null){if(typeof t=="string")return[t];if(Array.isArray(t))return t.filter(o=>typeof o=="string")}return e};import Qt from"debug";import Yt from"os";import{get as ce,isNotNil as Ce}from"es-toolkit/compat";var Re=async(t,e)=>{let o=e;for(let r of Object.keys(o))if(typeof r=="string"&&!(r==="id"||r==="tags")&&o[r]!==void 0&&typeof o[r]=="string"){let s=o[r];for(;;){let i=f=>{t.envVarReplaceRegex.lastIndex=0;let l=t.envVarReplaceRegex.exec(f),g=Ce(l),x=l?.[0],b=l?.[1],_=b?ce(process.env,b):void 0;return{isMatched:g,matchedStr:x,varPath:b,matchedVar:_,replaceText:()=>{let u=f.substring(0,l.index),T=`${_}`,E=f.substring(l.index+x.length);return`${u}${T}${E}`}}},d=(f=>{t.varReplaceRegex.lastIndex=0;let l=t.varReplaceRegex.exec(f),g=Ce(l),x=l?.[0],b=l?.[1],_=b?ce(t.systemVars,b)||ce(t.vars,b):void 0;return{isMatched:g,matchedStr:x,varPath:b,matchedVar:_,replaceText:()=>{let u=f.substring(0,l.index),T=`${_}`,E=f.substring(l.index+x.length);return`${u}${T}${E}`}}})(s),c=i(s);if(d.isMatched)a(`Variable injection: '${r}'=>'${s}'`),s=d.replaceText();else if(c.isMatched)a(`Variable injection: '${r}'=>'${s}'`),s=c.replaceText();else break}o[r]=s}},le=(t,e,o,r)=>{let s,i=!1;for(let m of t){if(m.trim()==="--"){a("Stop parsing by '--'");break}if(i&&s){let c=m.startsWith("-")?"":m;r(s,c),s=void 0,i=!1}else if(m.indexOf(e)>=0){let f=m.indexOf("=");if(f>=0){let l=oe(m.substring(e.length,f),o),g=m.substring(f+1);r(l,g)}else s=oe(m.substring(e.length),o),i=!0}}},N=(t,e,o,r)=>{if(r&&t.vars[e]!==void 0){a(`Skips assigning the variable ${e}=${o} because it already exists.`);return}a(`Sets the variable ${e}=${o}`),t.vars[e]=o},W=(t,e,o,r)=>{var s=typeof o;if(s!=="string"&&s!=="number"&&s!=="boolean")a(`Ignoring the invalid typed(${s}) environment variable ${e}=${o}`);else if(String(o).length<1)a(`Ignoring the invalid environment variable ${e}=${o}`);else{if(r&&process.env[e]!==void 0){a(`Skips assigning the environment variable ${e}=${o} because it already exists.`);return}a(`Sets the environment variable ${e}=${o}`),process.env[e]=String(o)}};import Dt from"string-argv";var $e=async(t,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let o=Dt(e.args),r=H(o);Y(t.originCwd,r.opt,r.program)};import z from"fs";import Ee from"path";import Lt from"fs";import{globSync as ee}from"glob";var w=(t,e,o,r,s,i)=>{if(Lt.statSync(e).isDirectory()===!1)return!1;let m=s===!0,d=o.length>0,c=r.length>0;return!d&&c?(t(ee(["**"],{ignore:[...r],cwd:e,nodir:m}).filter(f=>f!==".")),!0):d&&!c?(t(ee(o,{cwd:e,nodir:m})),!0):d&&c?(t(ee(o,{ignore:r,cwd:e,nodir:m})),!0):i?(t(ee(["**"],{cwd:e,nodir:m}).filter(f=>f!==".")),!0):!1};var It=(t,e,o,r)=>{var s=t;if(r<1)for(;e.test(s);)s=s.replace(e,o);else for(var i=0;i<r;i++)e.test(s)&&(s=s.replace(e,o));return s},Gt=(t,e,o,r)=>{var s=t;if(r<1)for(;s.indexOf(e)>=0;)s=s.replace(e,o);else for(var i=0;i<r;i++)s.indexOf(e)>=0&&(s=s.replace(e,o));return s},Vt=t=>t!=null&&typeof t=="object"&&"pattern"in t&&typeof t.pattern=="string",Fe=(t,e,o,r,s)=>{a(`Find and Replace: ${t}`);let i=z.readFileSync(t,"utf-8"),m=e(i,o,r,s);z.writeFileSync(t,m,"utf-8")},Oe=async(t,e)=>{if(!z.existsSync(e.path)){a(`The '${e.path}' does not exist`);return}(e.replace===void 0||typeof e.replace!="string")&&Q(e,"replace");let o=e.loop===void 0||e.loop===null?1:e.loop;typeof o=="string"?o=parseInt(o,10):typeof o!="number"&&Q(e,"loop");let r,s;if(Vt(e.find)){let d=e.find;r=new RegExp(d.pattern,d.flags),s=It}else if(typeof e.find=="string")r=e.find,s=Gt;else{Q(e,"find");return}w(d=>{for(let c of d){let f=Ee.join(e.path,c);z.existsSync(f)&&z.statSync(f).isDirectory()||Fe(Ee.join(e.path,c),s,r,e.replace,o)}},e.path,k(e.include,[]),k(e.exclude,[]),!0,!0)||Fe(e.path,s,r,e.replace,o)};import{mkdirpSync as Mt}from"fs-extra";var Ae=async(t,e)=>{$("path",e.path,["string"]),a(`Make a directory at : ${e.path}`),Mt(e.path)};import Pt from"fs";import Nt from"path";import Wt from"fs-extra";var je=t=>{a(`Delete: ${t}`),Wt.removeSync(t)},De=async(t,e)=>{if(!Pt.existsSync(e.path)){a(`The '${e.path}' does not exist and cannot be deleted`);return}w(s=>{for(let i of s)je(Nt.join(e.path,i))},e.path,k(e.include,[]),k(e.exclude,[]),!1,!1)||je(e.path)};import Le from"path";import Ge from"fs-extra";var Ie=(t,e,o)=>{a(`Copy: ${t} => ${e}`),Ge.copySync(t,e,o)},Ve=async(t,e)=>{if(!Ge.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let o=e?.options?.conflict,r=o==null||typeof o=="string"&&o.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(r=e.options.overwrite);let s={overwrite:r};w(d=>{for(let c of d){let f=Le.join(e.src,c),l=Le.join(e.dest,c);Ie(f,l,s)}},e.src,k(e.include,[]),k(e.exclude,[]),!1,!1)||Ie(e.src,e.dest,s)};import U from"fs";import{mkdirpSync as zt}from"fs-extra";import Me from"path";var Pe=async(t,e)=>{let o=e.text??"",r=(e.target??"c").trim(),s=e.path;if(r==="c"||r==="console")console.log(o);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${r}'!`);let i=Me.resolve(s),m=Me.dirname(i);if(U.existsSync(m)||zt(m),r=="fa"||r=="file-append"){let d,c;try{c=U.openSync(i,"a"),U.appendFileSync(c,o,"utf8")}catch(f){d=f}finally{c!==void 0&&U.closeSync(c)}if(d)throw d}else U.writeFileSync(i,o)}};import Ut from"fs-extra";import Ne from"path";import{isNotNil as Kt}from"es-toolkit";var We=async(t,e)=>{C(e,"var"),C(e,"varType"),C(e,"fileFormat"),e.isFallback!==!0&&(e.isFallback=!1);let o=e.isFallback;if(Kt(e.map)){let c=e.map;typeof c=="string"?(a("Trying to parse as lines."),c=P(c)):(typeof c=="object"||Array.isArray(c))&&Object.keys(c).forEach(f=>{W(t,f,c[f],o)})}if(!e.src)return;$("src",e.src,["string"]);let r=e.src,s=e.parser||"auto";a(`Parser = ${s}`);let i=c=>{let f=Ne.resolve(c),l,g=V(f);if(s==="auto"||s==="json")try{a("Trying to parse as JSON."),l=M(g)}catch(x){if(s==="json")throw x}if(!l&&(s==="auto"||s==="lines")&&(a("Trying to parse as lines."),l=P(g)),l){let x=l;Object.keys(x).forEach(b=>{W(t,b,x[b],o)})}};w(c=>{for(let f of c){let l=Ne.join(r,f);Ut.statSync(l).isDirectory()||i(l)}},r,k(e.include,[]),k(e.exclude,[]),!0,!0)||i(r)};import Jt from"fs";import ze from"path";var Ue=async(t,e)=>{C(e,"var"),C(e,"varType"),C(e,"fileFormat"),$("key",e.key,["string"]),_e("key",e.key),e.isFallback!==!0&&(e.isFallback=!1);let o=e.isFallback;if(e.value!==void 0){let c=e.value;N(t,e.key,c,o)}if(!e.src)return;$("src",e.src,["string"]);let r=e.src,s=e.parser||"auto";a(`Parser = ${s}`);let i=c=>{let f=ze.resolve(c),l,g=V(f);if(s==="auto"||s==="json")try{a("Trying to parse as JSON."),l=M(g)}catch(x){if(s==="json")throw x}!l&&(s==="auto"||s==="lines")&&(a("Trying to parse as lines."),l=P(g)),!l&&(s==="auto"||s==="string")&&(l=g),N(t,e.key,l,o)};w(c=>{for(let f of c){let l=ze.join(r,f);Jt.statSync(l).isDirectory()||i(l)}},r,k(e.include,[]),k(e.exclude,[]),!0,!0)||i(r)};import{execSync as Ht}from"child_process";var Ke=async(t,e)=>{a(`Start execution... ${e.cmd}`),Ht(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})};import Je from"path";import A from"fs";import Bt from"fs-extra";var He=async(t,e)=>{let o=Je.resolve(e.target),r=Je.resolve(e.path);if(A.existsSync(r)){let s=A.lstatSync(r);a(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(a(`Unlink ${r}`),A.unlinkSync(r)):s.isDirectory()&&(a(`Remove directory '${r}'`),Bt.removeSync(r)))}if(A.existsSync(r))a(`Could not create symbolic link cause '${r}' already exists`);else{a(`Create symbolic link ${o} => ${r}`),A.symlinkSync(o,r,e.linkType);let s=A.lstatSync(r);a(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}};import pe from"fs";import qt from"path";import Be,{CheckRepoActions as Xt,ResetMode as Zt}from"simple-git";var qe=async(t,e)=>{let o=qt.resolve(e.localPath);pe.existsSync(o)||pe.mkdirSync(o,{recursive:!0}),pe.readdirSync(o).length===0&&e.url&&await Be().clone(e.url,o);let r=Be(o,{binary:e.binary});if(!await r.checkIsRepo(Xt.IS_REPO_ROOT))throw Error(`${o} is not a git repository!!!`);if(e.updateSubmodules&&(await r.submoduleInit(),await r.submoduleUpdate()),await r.fetch(),e.branch){let m=!1,d=await r.branchLocal();for(var i of d.all)if(i===e.branch){m=!0;break}let c=e.branch??"",f=e.startPoint??"";m?(d.current!==e.branch&&await r.checkout(c),await r.reset(Zt.HARD,[f])):await r.checkoutBranch(c,f)}};var fe={"git-setup":qe,cmd:Ke,"set-var":Ue,output:Pe,symlink:He,"fs-copy":Ve,"fs-del":De,"fs-mkdir":Ae,"env-var":We,"sub-tasks":$e,"content-replace":Oe};import{isNil as en,isNotNil as te}from"es-toolkit";var Xe=async(t,e,o,r)=>{let s=ke.parse(o),i=e.cwdMode?e.cwdMode===R:s.env.cwdMode===R,m,d=s.env.logLevel,c=s.env.varReplaceRegex,f=s.env.envReplaceRegex;e.logLevel&&D.includes(e.logLevel)&&(d=e.logLevel),d==="debug"?(m=`${G},${I},${X}`,m=`${m},simple-git,simple-git:*`):d==="info"&&(m=`${G},${I}`),m&&Qt.enable(m),a("CLI Options",e);let l=me.resolve(process.cwd()),g={os:{platform:process.platform,architecture:process.arch,machine:Yt.machine()},originCwd:t,baseCwd:l,varReplaceRegex:new RegExp(c),envVarReplaceRegex:new RegExp(f),systemVars:{__env:{cwd_startup:t,cwd_base:l}},vars:{},opts:e,program:r};e.extraArgs&&(a("Setting up the variables from the additional arguments"),le(e.extraArgs,be,e.camelKeys,(u,T)=>{N(g,u,T,!1)}),a("Setting up the environment variables from the additional arguments"),le(e.extraArgs,ve,e.camelKeys,(u,T)=>{W(g,u,T,!1)})),S(""),S(`[${s.name}] Start task processing`);let x=(u,T)=>T!=null?u.id!==void 0?`[${T}]${u.id}/${u.type}`:`[${T}]${u.type}`:u.id!==void 0?`${u.id}/${u.type}`:`${u.type}`,b=async()=>{let u=(s.tasks??[]).map(xe);for(let y=0;y<u.length;y++){let p=u[y];if(te(p.id))for(let h=y+1;h<u.length;h++){let v=u[h];if(v.id!==void 0&&v.id===p.id)throw new Error(`The task id '${p.id}' must be unique`)}if(!p.type||!(p.type in fe))throw new Error(`Found the invalid task type '${p.type}'`);p.id&&p.__compare__elements.push(p.id),p.tags&&p.__compare__elements.push(...p.tags)}if(e.exclude&&e.exclude.length>0){let y=e.exclude;a(`Excluding tasks by specified IDs or Tags : --exclude=${y}`),u=u.filter(p=>{if(ie(y,p.__compare__elements)===!1)return p})}if(u=u.filter(y=>{if(en(y.when))return!0;let{platform:p,architecture:h,machine:v}=y.when;if(te(p)){if(p.startsWith("!")){if(p.substring(1)===g.os.platform)return!1}else if(p!==g.os.platform)return!1}if(te(h)){if(h.startsWith("!")){if(h.substring(1)===g.os.architecture)return!1}else if(h!==g.os.architecture)return!1}if(te(v)){if(v.startsWith("!")){if(v.substring(1)===g.os.machine)return!1}else if(v!==g.os.machine)return!1}return!0}),e.excludeCta&&e.excludeCta.length>0){let y=e.excludeCta;a(`Excluding tasks by specified IDs or Tags : --exclude-cta=${y}`),u=u.filter(p=>{if(ae(y,p.__compare__elements)===!1)return p})}let T=e.include&&e.include.length>0,E=e.includeCta&&e.includeCta.length>0;if(T||E){let y=e.include,p=e.includeCta;a(`Including tasks by specified IDs or Tags : --include=${y} / --include-cta=${p}`),u=u.filter(h=>{if(T&&ie(y,h.__compare__elements)===!0||E&&ae(p,h.__compare__elements)===!0)return h})}S(`Tasks : ${u.map((y,p)=>x(y,p))}`);let Qe=u.length??0;for(let y=0;y<Qe;y++){let p=u[y];await Re(g,p);let h=x(p,y);if(p.enabled===!1){S(`
### Skip the task without execution => ${h}`);continue}else S(`
### Task : ${h}`);p.comment&&S(p.comment);let v=!1;if(p.cwd){let F=me.resolve(p.cwd);S(`Changing the current working directory => ${F}`),v=!0,process.chdir(F)}let Ye=fe[p.type];try{await Ye(g,p)}catch(F){if(p.onError==="skip")a(`Skip the failed task => ${h}`,F);else if(p.onError==="warn")Z(`Warn about the failed task => ${h}`,F);else throw F}i||(v&&S(`Restoring the current working directory => ${l}`),process.chdir(l))}},_=!1,K;try{await b()}catch(u){_=!0,K=u}if(_)throw K;process.chdir(l),S(`[${s.name}] Tasks done
`)},Y=(t,e,o)=>{let r={},s=me.resolve(e.config);try{r=se(s)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),o.help()}return Xe(t,e,r,o)};var nn=tn.resolve(process.cwd()),Ze=H();Y(nn,Ze.opt,Ze.program);export{Y as initUsefulTasks,Xe as usefulTasks};
//# sourceMappingURL=index.mjs.map