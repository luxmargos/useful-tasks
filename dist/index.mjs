#!/usr/bin/env node
import gt from"path";import{Command as Ge}from"commander";import De from"path";var Ie="useful_tasks.json",re=!0,U="restore",W="keep",Ve=[U,W],je="info",Me="debug",Pe="none",I=[Pe,je,Me],Ne={cwdMode:`Choose between ${Ve.map(r=>`'${r}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${U}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${W}' mode, the CWD will remain unchanged.`},V=r=>{let e=new Ge;e.name("useful-tasks").version("0.2.1").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",Ie).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',re).option("--cwd-mode <string>",Ne.cwdMode,U).option("--log-level <string>",`Specify the logging level as ${I.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),r!==void 0?e.parse(r,{from:"user"}):e.parse();let t=e.opts();if(t.include=D(t.include),t.includeCta=D(t.includeCta),t.exclude=D(t.exclude),t.excludeCta=D(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===W,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let n=t.camelKeys;n=n.trim().toLowerCase(),n==="false"||n==="0"||n==="no"?t.camelKeys=!1:n==="true"||n==="1"||n==="yes"?t.camelKeys=!0:t.camelKeys=re}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(De.resolve(t.cwd)),{opt:t,program:e}},D=(r,e=!0)=>{if(!r)return[];if(typeof r=="string"){let o=[];return r.split(",").forEach(n=>{let s=n.trim();e?s.length>0&&o.push(s):o.push(s)}),o}return[]};import Y from"path";import ae from"fs";import le from"path";import Ue from"json5";import J from"debug";var K="useful-tasks",j=`${K}:debug`,$=`${K}:info`,_=`${K}:warn`,ne="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",oe="--var-",se="--env-";var ie=J(_),b=J($),c=J(j);var F=r=>{if(c(`Loading file: ${r}`),!ae.existsSync(r))throw new Error(`ERROR: The Path '${r}' does not exists!`);return ae.readFileSync(r,{encoding:"utf-8"})},We=r=>E(F(r)),E=r=>Ue.parse(r),X=r=>{let e=We(r);if(e.extends){let o=le.dirname(r),t=le.resolve(o,e.extends);e=Object.assign({},e,X(t))}return e},B=(r,e)=>{if(!e)return r;let o="",t=r.split("-");for(let n=0;n<t.length;n++){let s=t[n];n===0?o=s:(s.length>0&&(s=`${s[0].toUpperCase()}${s.substring(1)}`),o=`${o}${s}`)}return o},H=(r,e)=>{if(r.length<1)return!1;for(let o of r)for(let t of e)if(o===t)return!0;return!1},q=(r,e)=>{if(r.length<1)return!1;for(let o of r){let t=!1;for(let n of e)if(n===o){t=!0;break}if(!t)return!1}return!0},ce=(r,e)=>{if(!e)throw new Error(`The '${r}' property must not be empty.`)},k=(r,e)=>{r[e]!==void 0&&ie(`The key '${e}' has been deprecated.`)},Ke=(r,e)=>e.length<=0?!0:e.includes(typeof r),w=(r,e,o)=>{if(Ke(e,o))return!0;let t=typeof e;throw new Error(`The '${r}' property has an invalid type '${t}' with the value '${e}'. The allowed types are [${o}].`)},Je=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;function R(r){let e={},o=r.toString();o=o.replace(/\r\n?/gm,`
`);let t;for(;(t=Je.exec(o))!=null;){let n=t[1],s=t[2]||"";s=s.trim();let p=s[0];s=s.replace(/^(['"`])([\s\S]*)\1$/gm,"$2"),p==='"'&&(s=s.replace(/\\n/g,`
`),s=s.replace(/\\r/g,"\r")),e[n]=s}return e}var M=(r,e)=>{throw new Error(`The parameter '${String(e)}' has an invalid value ${r[e]}`)},x=(r,e)=>{if(r!=null){if(typeof r=="string")return[r];if(Array.isArray(r))return r.filter(o=>typeof o=="string")}return e};import ft from"debug";var pe=async(r,e)=>{let o=e;for(let t of Object.keys(o))if(typeof t=="string"&&!(t==="id"||t==="tags")&&o[t]!==void 0&&typeof o[t]=="string"){let n=o[t];for(;;){let s=r.replaceRegex.exec(n);if(s==null)break;let p=s[0],f=s[1],l=r.vars;if(f.length>0){let i=f.split(".");for(let u=0;u<i.length;u++){let C=i[u];if(l.hasOwnProperty(C))l=l[C];else throw new Error(`The value of ${f} could not be found!`)}}let g=n.substring(0,s.index),d=`${l}`,T=n.substring(s.index+p.length);n=`${g}${d}${T}`,c(`Variable injection: '${t}'=>'${n}'`)}o[t]=n}},z=(r,e,o,t)=>{let n,s=!1;for(let p of r){if(p.trim()==="--"){c("Stop parsing by '--'");break}if(s&&n){let l=p.startsWith("-")?"":p;t(n,l),n=void 0,s=!1}else if(p.indexOf(e)>=0){let g=p.indexOf("=");if(g>=0){let d=B(p.substring(e.length,g),o),T=p.substring(g+1);t(d,T)}else n=B(p.substring(e.length),o),s=!0}}},A=(r,e,o,t)=>{if(t&&r.vars[e]!==void 0){c(`Skips assigning the variable ${e}=${o} because it already exists.`);return}c(`Sets the variable ${e}=${o}`),r.vars[e]=o},O=(r,e,o,t)=>{var n=typeof o;if(n!=="string"&&n!=="number"&&n!=="boolean")c(`Ignoring the invalid typed(${n}) environment variable ${e}=${o}`);else if(String(o).length<1)c(`Ignoring the invalid environment variable ${e}=${o}`);else{if(t&&process.env[e]!==void 0){c(`Skips assigning the environment variable ${e}=${o} because it already exists.`);return}c(`Sets the environment variable ${e}=${o}`),process.env[e]=String(o)}};import Xe from"string-argv";var fe=async(r,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let o=Xe(e.args),t=V(o);L(r.originCwd,t.opt,t.program)};import N from"fs";import ge from"path";import Be from"fs";import{globSync as P}from"glob";var v=(r,e,o,t,n,s)=>{if(Be.statSync(e).isDirectory()===!1)return!1;let p=n===!0,f=o.length>0,l=t.length>0;return!f&&l?(r(P("**",{ignore:[".",...t],cwd:e,nodir:p})),!0):f&&!l?(r(P(o,{cwd:e,nodir:p})),!0):f&&l?(r(P(o,{ignore:t,cwd:e,nodir:p})),!0):s?(r(P("**",{ignore:["."],cwd:e,nodir:p})),!0):!1};var He=(r,e,o,t)=>{var n=r;if(t<1)for(;e.test(n);)n=n.replace(e,o);else for(var s=0;s<t;s++)e.test(n)&&(n=n.replace(e,o));return n},qe=(r,e,o,t)=>{var n=r;if(t<1)for(;n.indexOf(e)>=0;)n=n.replace(e,o);else for(var s=0;s<t;s++)n.indexOf(e)>=0&&(n=n.replace(e,o));return n},ze=r=>r!=null&&typeof r=="object"&&"pattern"in r&&typeof r.pattern=="string",de=(r,e,o,t,n)=>{c(`Find and Replace: ${r}`);let s=N.readFileSync(r,"utf-8"),p=e(s,o,t,n);N.writeFileSync(r,p,"utf-8")},me=async(r,e)=>{if(!N.existsSync(e.path)){c(`The '${e.path}' does not exist`);return}(e.replace===void 0||typeof e.replace!="string")&&M(e,"replace");let o=e.loop===void 0||e.loop===null?1:e.loop;typeof o=="string"?o=parseInt(o,10):typeof o!="number"&&M(e,"loop");let t,n;if(ze(e.find)){let f=e.find;t=new RegExp(f.pattern,f.flags),n=He}else if(typeof e.find=="string")t=e.find,n=qe;else{M(e,"find");return}v(f=>{for(let l of f){let g=ge.join(e.path,l);N.statSync(g).isDirectory()||de(ge.join(e.path,l),n,t,e.replace,o)}},e.path,x(e.include,[]),x(e.exclude,[]),!0,!0)||de(e.path,n,t,e.replace,o)};import{mkdirpSync as Qe}from"fs-extra";var ue=async(r,e)=>{w("path",e.path,["string"]),c(`Make a directory at : ${e.path}`),Qe(e.path)};import Ze from"fs";import Ye from"path";import{removeSync as et}from"fs-extra";var ye=r=>{c(`Delete: ${r}`),et(r)},he=async(r,e)=>{if(!Ze.existsSync(e.path)){c(`The '${e.path}' does not exist and cannot be deleted`);return}v(n=>{for(let s of n)ye(Ye.join(e.path,s))},e.path,x(e.include,[]),x(e.exclude,[]),!1,!1)||ye(e.path)};import xe from"path";import tt from"fs-extra";import{copySync as rt}from"fs-extra";var Te=(r,e,o)=>{c(`Copy: ${r} => ${e}`),rt(r,e,o)},be=async(r,e)=>{if(!tt.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let o=e?.options?.conflict,t=o==null||typeof o=="string"&&o.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let n={overwrite:t};v(f=>{for(let l of f){let g=xe.join(e.src,l),d=xe.join(e.dest,l);Te(g,d,n)}},e.src,x(e.include,[]),x(e.exclude,[]),!1,!1)||Te(e.src,e.dest,n)};import G from"fs";import{mkdirpSync as nt}from"fs-extra";import ve from"path";var ke=async(r,e)=>{let o=e.text??"",t=(e.target??"c").trim(),n=e.path;if(t==="c"||t==="console")console.log(o);else{if(!n)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let s=ve.resolve(n),p=ve.dirname(s);if(G.existsSync(p)||nt(p),t=="fa"||t=="file-append"){let f,l;try{l=G.openSync(s,"a"),G.appendFileSync(l,o,"utf8")}catch(g){f=g}finally{l!==void 0&&G.closeSync(l)}if(f)throw f}else G.writeFileSync(s,o)}};import ot from"fs-extra";import we from"path";var Se=async(r,e)=>{k(e,"var"),k(e,"varType"),k(e,"fileFormat"),e.isFallback!==!0&&(e.isFallback=!1);let o=e.isFallback;if(e.value!==void 0){let l=e.value;typeof l=="string"&&(c("Trying to parse as lines."),l=R(l)),Object.keys(l).forEach(g=>{O(r,g,l[g],o)})}if(!e.src)return;w("src",e.src,["string"]);let t=e.src,n=e.parser||"auto";c(`Parser = ${n}`);let s=l=>{let g=we.resolve(l),d,T=F(g);if(n==="auto"||n==="json")try{c("Trying to parse as JSON."),d=E(T)}catch(i){if(n==="json")throw i}if(!d&&(n==="auto"||n==="lines")&&(c("Trying to parse as lines."),d=R(T)),d){let i=d;Object.keys(i).forEach(u=>{O(r,u,i[u],o)})}};v(l=>{for(let g of l){let d=we.join(t,g);ot.statSync(d).isDirectory()||s(d)}},t,x(e.include,[]),x(e.exclude,[]),!0,!0)||s(t)};import st from"fs";import Ce from"path";var $e=async(r,e)=>{k(e,"var"),k(e,"varType"),k(e,"fileFormat"),w("key",e.key,["string"]),ce("key",e.key),e.isFallback!==!0&&(e.isFallback=!1);let o=e.isFallback;if(e.value!==void 0){let l=e.value;A(r,e.key,l,o)}if(!e.src)return;w("src",e.src,["string"]);let t=e.src,n=e.parser||"auto";c(`Parser = ${n}`);let s=l=>{let g=Ce.resolve(l),d,T=F(g);if(n==="auto"||n==="json")try{c("Trying to parse as JSON."),d=E(T)}catch(i){if(n==="json")throw i}!d&&(n==="auto"||n==="lines")&&(c("Trying to parse as lines."),d=R(T)),!d&&(n==="auto"||n==="string")&&(d=T),A(r,e.key,d,o)};v(l=>{for(let g of l){let d=Ce.join(t,g);st.statSync(d).isDirectory()||s(d)}},t,x(e.include,[]),x(e.exclude,[]),!0,!0)||s(t)};import{execSync as it}from"child_process";var _e=async(r,e)=>{c(`Start execution... ${e.cmd}`),it(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})};import S from"fs";import{removeSync as at}from"fs-extra";import Fe from"path";var Ee=async(r,e)=>{let o=Fe.resolve(e.target),t=Fe.resolve(e.path);if(S.existsSync(t)){let n=S.lstatSync(t);c(`LSTAT is symlink? ${n.isSymbolicLink()}, is directory? ${n.isDirectory()}`),e.forced&&(n.isSymbolicLink()||n.isFile()?(c(`Unlink ${t}`),S.unlinkSync(t)):n.isDirectory()&&(c(`Remove directory '${t}'`),at(t)))}if(S.existsSync(t))c(`Could not create symbolic link cause '${t}' already exists`);else{c(`Create symbolic link ${o} => ${t}`),S.symlinkSync(o,t,e.linkType);let n=S.lstatSync(t);c(`LSTAT is symlink? ${n.isSymbolicLink()}, is directory? ${n.isDirectory()}`)}};import Q from"fs";import lt from"path";import Re,{CheckRepoActions as ct,ResetMode as pt}from"simple-git";var Ae=async(r,e)=>{let o=lt.resolve(e.localPath);Q.existsSync(o)||Q.mkdirSync(o,{recursive:!0}),Q.readdirSync(o).length===0&&e.url&&await Re().clone(e.url,o);let t=Re(o,{binary:e.binary});if(!await t.checkIsRepo(ct.IS_REPO_ROOT))throw Error(`${o} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let p=!1,f=await t.branchLocal();for(var s of f.all)if(s===e.branch){p=!0;break}let l=e.branch??"",g=e.startPoint??"";p?(f.current!==e.branch&&await t.checkout(l),await t.reset(pt.HARD,[g])):await t.checkoutBranch(l,g)}};var Z={"git-repo-prepare":Ae,cmd:_e,"set-var":$e,output:ke,symlink:Ee,"fs-copy":be,"fs-del":he,"fs-mkdir":ue,"env-var":Se,"sub-tasks":fe,"content-replace":me};var L=(r,e,o)=>{let t={},n=Y.resolve(e.config);try{t=X(n)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),o.help()}let s,p="info",f=ne;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(p="debug"),i.logLevel&&I.includes(i.logLevel)&&(p=i.logLevel),i.replaceRegex&&(f=i.replaceRegex)}if(e.logLevel&&I.includes(e.logLevel)&&(p=e.logLevel),p==="debug"?(s=`${_},${$},${j}`,s=`${s},simple-git,simple-git:*`):p==="info"&&(s=`${_},${$}`),s&&ft.enable(s),c("CLI Options",e),typeof f!="string")throw new Error(`replaceRegex '${f}'  must be a string`);if(f.length<1)throw new Error(`replaceRegex '${f}' cannot be empty`);if(f.indexOf("(")<0||f.indexOf(")")<0)throw new Error(`replaceRegex '${f}' must contain regex group express '(' and ')'`);let l=Y.resolve(process.cwd()),g={originCwd:r,baseCwd:l,replaceRegex:new RegExp(f),vars:{__env:{cwd_startup:r,cwd_base:l}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),z(e.extraArgs,oe,e.camelKeys,(i,u)=>{A(g,i,u,!1)}),c("Setting up the environment variables from the additional arguments"),z(e.extraArgs,se,e.camelKeys,(i,u)=>{O(g,i,u,!1)})),b(""),b(`[${t.name}] Start task processing`);let d=(i,u)=>u!=null?i.id!==void 0?`[${u}]${i.id}/${i.type}`:`[${u}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let m=0;m<i.length;m++){let a=i[m];if(a.id!==void 0&&a.id!==null){if(typeof a.id!="string")throw new Error("The task id must be a 'string' type");if(a.id.length<1)throw new Error("The task id cannot be empty");for(let h=m+1;h<i.length;h++){let y=i[h];if(y.id!==void 0&&y.id===a.id)throw new Error(`The task id '${a.id}' must be unique`)}}if(!a.type||!(a.type in Z))throw new Error(`Found the invalid task type '${a.type}'`);if(a.__compare__elements=[],a.id&&(a.id=a.id.trim(),a.__compare__elements.push(a.id.trim())),a.tags){let h=y=>{c(`Ignoring invalid tags '${y}'`)};if(typeof a.tags=="string")a.tags.length>0?(a.tags=a.tags.trim(),a.__compare__elements.push(a.tags)):h(a.tags);else if(Array.isArray(a.tags)){a.tags=a.tags.map(y=>y.trim());for(let y of a.tags)typeof y=="string"&&y.length>0?a.__compare__elements.push(y):h(y)}else h(a.tags)}}if(e.exclude&&e.exclude.length>0){let m=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${m}`),i=i.filter((a,h,y)=>{if(H(m,a.__compare__elements)===!1)return a})}if(e.excludeCta&&e.excludeCta.length>0){let m=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${m}`),i=i.filter((a,h,y)=>{if(q(m,a.__compare__elements)===!1)return a})}let u=e.include&&e.include.length>0,C=e.includeCta&&e.includeCta.length>0;if(u||C){let m=e.include,a=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${m} / --include-cta=${a}`),i=i.filter((h,y,ee)=>{if(u&&H(m,h.__compare__elements)===!0||C&&q(a,h.__compare__elements)===!0)return h})}b(`Tasks : ${i.map((m,a)=>d(m,a))}`);let Le=i.length??0;for(let m=0;m<Le;m++){let a=i[m];await pe(g,a);let h=d(a,m);if(a.enabled===!1){b(`
### Skip the task without execution => ${h}`);continue}else b(`
### Task : ${h}`);a.comment&&b(a.comment);let y=!1;if(a.cwd){let te=Y.resolve(a.cwd);b(`Changing the current working directory => ${te}`),y=!0,process.chdir(te)}let ee=Z[a.type];await ee(g,a),e.cwdModeIsContinue||(y&&b(`Restoring the current working directory => ${l}`),process.chdir(l))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(l),b(`[${t.name}] Tasks done
`)})};var dt=gt.resolve(process.cwd()),Oe=V();L(dt,Oe.opt,Oe.program);export{L as usefulTasks};
//# sourceMappingURL=index.mjs.map