#!/usr/bin/env node
import Le from"path";import{Command as me}from"commander";import ye from"path";var he="useful_tasks.json",q=!0,O="restore",D="keep",xe=[O,D],Te="info",be="debug",ve="none",$=[ve,Te,be],ke={cwdMode:`Choose between ${xe.map(s=>`'${s}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${O}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${D}' mode, the CWD will remain unchanged.`},E=s=>{let e=new me;e.name("useful-tasks").version("0.1.26").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",he).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',q).option("--cwd-mode <string>",ke.cwdMode,O).option("--log-level <string>",`Specify the logging level as ${$.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),s!==void 0?e.parse(s,{from:"user"}):e.parse();let t=e.opts();if(t.include=S(t.include),t.includeCta=S(t.includeCta),t.exclude=S(t.exclude),t.excludeCta=S(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===D,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let r=t.camelKeys;r=r.trim().toLowerCase(),r==="false"||r==="0"||r==="no"?t.camelKeys=!1:r==="true"||r==="1"||r==="yes"?t.camelKeys=!0:t.camelKeys=q}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(ye.resolve(t.cwd)),{opt:t,program:e}},S=(s,e=!0)=>{if(!s)return[];if(typeof s=="string"){let n=[];return s.split(",").forEach(r=>{let a=r.trim();e?a.length>0&&n.push(a):n.push(a)}),n}return[]};import B from"path";import H from"fs";import W from"path";import we from"json5";var I=s=>{if(!H.existsSync(s))throw new Error(`ERROR: The Path '${s}' does not exists!`);let e=H.readFileSync(s,{encoding:"utf-8"});return we.parse(e)},V=s=>{let e=I(s);if(e.extends){let n=W.dirname(s),t=W.resolve(n,e.extends);e=Object.assign({},e,V(t))}return e},G=(s,e)=>{if(!e)return s;let n="",t=s.split("-");for(let r=0;r<t.length;r++){let a=t[r];r===0?n=a:(a.length>0&&(a=`${a[0].toUpperCase()}${a.substring(1)}`),n=`${n}${a}`)}return n},M=(s,e)=>{if(s.length<1)return!1;for(let n of s)for(let t of e)if(n===t)return!0;return!1},P=(s,e)=>{if(s.length<1)return!1;for(let n of s){let t=!1;for(let r of e)if(r===n){t=!0;break}if(!t)return!1}return!0};import Ae from"debug";var Y="useful-tasks",R=`${Y}:debug`,C=`${Y}:info`,z="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",Z="--var-",Q="--env-";import ee from"debug";var c=ee(R),x=ee(C);var te=async(s,e)=>{let n=e;for(let t of Object.keys(n))if(typeof t=="string"&&!(t==="id"||t==="tags")&&n[t]!==void 0&&typeof n[t]=="string"){let r=n[t];for(;;){let a=s.replaceRegex.exec(r);if(a==null)break;let l=a[0],p=a[1],f=s.vars;if(p.length>0){let i=p.split(".");for(let m=0;m<i.length;m++){let w=i[m];if(f.hasOwnProperty(w))f=f[w];else throw new Error(`The value of ${p} could not be found!`)}}let u=r.substring(0,a.index),b=`${f}`,v=r.substring(a.index+l.length);r=`${u}${b}${v}`,c(`Variable applied '${t}'=>'${r}'`)}n[t]=r}},j=(s,e,n,t)=>{let r,a=!1;for(let l of s){if(l.trim()==="--"){c("Stop parsing by '--'");break}if(a&&r){let f=l.startsWith("-")?"":l;t(r,f),r=void 0,a=!1}else if(l.indexOf(e)>=0){let u=l.indexOf("=");if(u>=0){let b=G(l.substring(e.length,u),n),v=l.substring(u+1);t(b,v)}else r=G(l.substring(e.length),n),a=!0}}},F=(s,e,n,t)=>{if(t&&s.vars[e]!==void 0){c(`Skips assigning the variable ${e}=${n} because it already exists.`);return}c(`Sets the variable ${e}=${n}`),s.vars[e]=n},A=(s,e,n,t)=>{var r=typeof n;if(r!=="string"&&r!=="number"&&r!=="boolean")c(`Ignoring the invalid typed(${r}) environment variable ${e}=${n}`);else if(String(n).length<1)c(`Ignoring the invalid environment variable ${e}=${n}`);else{if(t&&process.env[e]!==void 0){c(`Skips assigning the environment variable ${e}=${n} because it already exists.`);return}c(`Sets the environment variable ${e}=${n}`),process.env[e]=String(n)}};import Ce from"string-argv";var ne=async(s,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let n=Ce(e.args),t=E(n);_(s.originCwd,t.opt,t.program)};import d from"fs";import{execSync as _e}from"child_process";import T from"path";import{CheckRepoActions as Se,ResetMode as $e,simpleGit as re}from"simple-git";import{copySync as Ee,mkdirpSync as Re,removeSync as se}from"fs-extra";import Fe from"json5";import{globSync as k}from"glob";var oe=async(s,e)=>{let n=T.resolve(e.localPath);d.existsSync(n)||d.mkdirSync(n,{recursive:!0}),d.readdirSync(n).length===0&&e.url&&await re().clone(e.url,n);let t=re(n,{binary:e.binary});if(!await t.checkIsRepo(Se.IS_REPO_ROOT))throw Error(`${n} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let l=!1,p=await t.branchLocal();for(var a of p.all)if(a===e.branch){l=!0;break}let f=e.branch??"",u=e.startPoint??"";l?(p.current!==e.branch&&await t.checkout(f),await t.reset($e.HARD,[u])):await t.checkoutBranch(f,u)}},ie=async(s,e)=>{let n=T.resolve(e.target),t=T.resolve(e.path);if(d.existsSync(t)){let r=d.lstatSync(t);c(`LSTAT is symlink? ${r.isSymbolicLink()}, is directory? ${r.isDirectory()}`),e.forced&&(r.isSymbolicLink()||r.isFile()?(c(`Unlink ${t}`),d.unlinkSync(t)):r.isDirectory()&&(c(`Remove directory '${t}'`),se(t)))}if(d.existsSync(t))c(`Could not create symbolic link cause '${t}' already exists`);else{c(`Create symbolic link ${n} => ${t}`),d.symlinkSync(n,t,e.linkType);let r=d.lstatSync(t);c(`LSTAT is symlink? ${r.isSymbolicLink()}, is directory? ${r.isDirectory()}`)}},ae=async(s,e)=>{c(`Start execution... ${e.cmd}`),_e(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},le=async(s,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let n=e.value;if(n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.resolve(n);if(!d.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);n=d.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(n=Fe.parse(n))}F(s,e.key,n,e.isFallback)},ce=async(s,e)=>{let n=e.value;n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1);let t=e.isFallback;if(e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let r=T.resolve(n);n=I(r)}if(typeof n!="object")throw new Error('The content of the "value" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(n).forEach(r=>{A(s,r,n[r],t)})},pe=async(s,e)=>{let n=e.text??"",t=(e.target??"c").trim(),r=e.path;if(t==="c"||t==="console")console.log(n);else{if(!r)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let a=T.resolve(r),l=T.dirname(a);if(d.existsSync(l)||Re(l),t=="fa"||t=="file-append"){let p,f;try{f=d.openSync(a,"a"),d.appendFileSync(f,n,"utf8")}catch(u){p=u}finally{f!==void 0&&d.closeSync(f)}if(p)throw p}else d.writeFileSync(a,n)}};var L=(s,e)=>{if(s!=null){if(typeof s=="string")return[s];if(Array.isArray(s))return s.filter(n=>typeof n=="string")}return[]},N=(s,e,n)=>{c(`Copy: ${s} => ${e}`),Ee(s,e,n)},fe=async(s,e)=>{if(!d.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let n=e?.options?.conflict,t=n==null||typeof n=="string"&&n.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let r={overwrite:t};if(d.statSync(e.src).isDirectory()===!1){N(e.src,e.dest,r);return}let a=L(e.include,[]),l=L(e.exclude,[]),p=b=>{for(let v of b){let i=T.join(e.src,v),m=T.join(e.dest,v);N(i,m,r)}},f=a.length>0,u=l.length>0;!f&&u?p(k("**",{ignore:l,cwd:e.src})):f&&!u?p(k(a,{cwd:e.src})):f&&u?p(k(a,{ignore:l,cwd:e.src})):N(e.src,e.dest,r)},U=s=>{c(`Delete: ${s}`),se(s)},ge=async(s,e)=>{if(!d.existsSync(e.path)){c(`The '${e.path}' does not exist and cannot be deleted`);return}if(d.statSync(e.path).isDirectory()===!1){U(e.path);return}let n=L(e.include,[]),t=L(e.exclude,[]),r=p=>{for(let f of p)U(T.join(e.path,f))},a=n.length>0,l=t.length>0;!a&&l?r(k("**",{ignore:t,cwd:e.path})):a&&!l?r(k(n,{cwd:e.path})):a&&l?r(k(n,{ignore:t,cwd:e.path})):U(e.path)};var K={"git-repo-prepare":oe,symlink:ie,cmd:ae,"set-var":le,output:pe,"fs-copy":fe,"fs-del":ge,"env-var":ce,"sub-tasks":ne};var _=(s,e,n)=>{let t={},r=B.resolve(e.config);try{t=V(r)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),n.help()}let a,l="info",p=z;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(l="debug"),i.logLevel&&$.includes(i.logLevel)&&(l=i.logLevel),i.replaceRegex&&(p=i.replaceRegex)}if(e.logLevel&&$.includes(e.logLevel)&&(l=e.logLevel),l==="debug"?(a=`${C},${R}`,a=`${a},simple-git,simple-git:*`):l==="info"&&(a=`${C}`),a&&Ae.enable(a),c("CLI Options",e),typeof p!="string")throw new Error(`replaceRegex '${p}'  must be a string`);if(p.length<1)throw new Error(`replaceRegex '${p}' cannot be empty`);if(p.indexOf("(")<0||p.indexOf(")")<0)throw new Error(`replaceRegex '${p}' must contain regex group express '(' and ')'`);let f=B.resolve(process.cwd()),u={originCwd:s,baseCwd:f,replaceRegex:new RegExp(p),vars:{__env:{cwd_startup:s,cwd_base:f}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),j(e.extraArgs,Z,e.camelKeys,(i,m)=>{F(u,i,m,!1)}),c("Setting up the environment variables from the additional arguments"),j(e.extraArgs,Q,e.camelKeys,(i,m)=>{A(u,i,m,!1)})),x(""),x(`[${t.name}] Start task processing`);let b=(i,m)=>m!=null?i.id!==void 0?`[${m}]${i.id}/${i.type}`:`[${m}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let g=0;g<i.length;g++){let o=i[g];if(o.id!==void 0&&o.id!==null){if(typeof o.id!="string")throw new Error("The task id must be a 'string' type");if(o.id.length<1)throw new Error("The task id cannot be empty");for(let h=g+1;h<i.length;h++){let y=i[h];if(y.id!==void 0&&y.id===o.id)throw new Error(`The task id '${o.id}' must be unique`)}}if(!o.type||!(o.type in K))throw new Error(`Found the invalid task type '${o.type}'`);if(o.__compare__elements=[],o.id&&(o.id=o.id.trim(),o.__compare__elements.push(o.id.trim())),o.tags){let h=y=>{c(`Ignoring invalid tags '${y}'`)};if(typeof o.tags=="string")o.tags.length>0?(o.tags=o.tags.trim(),o.__compare__elements.push(o.tags)):h(o.tags);else if(Array.isArray(o.tags)){o.tags=o.tags.map(y=>y.trim());for(let y of o.tags)typeof y=="string"&&y.length>0?o.__compare__elements.push(y):h(y)}else h(o.tags)}}if(e.exclude&&e.exclude.length>0){let g=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${g}`),i=i.filter((o,h,y)=>{if(M(g,o.__compare__elements)===!1)return o})}if(e.excludeCta&&e.excludeCta.length>0){let g=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${g}`),i=i.filter((o,h,y)=>{if(P(g,o.__compare__elements)===!1)return o})}let m=e.include&&e.include.length>0,w=e.includeCta&&e.includeCta.length>0;if(m||w){let g=e.include,o=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${g} / --include-cta=${o}`),i=i.filter((h,y,J)=>{if(m&&M(g,h.__compare__elements)===!0||w&&P(o,h.__compare__elements)===!0)return h})}x(`Tasks : ${i.map((g,o)=>b(g,o))}`);let ue=i.length??0;for(let g=0;g<ue;g++){let o=i[g];te(u,o);let h=b(o,g);if(o.enabled===!1){x(`
### Skip the task without execution => ${h}`);continue}else x(`
### Task : ${h}`);o.comment&&x(o.comment);let y=!1;if(o.cwd){let X=B.resolve(o.cwd);x(`Changing the current working directory => ${X}`),y=!0,process.chdir(X)}let J=K[o.type];await J(u,o),e.cwdModeIsContinue||(y&&x(`Restoring the current working directory => ${f}`),process.chdir(f))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(f),x(`[${t.name}] Tasks done
`)})};var Oe=Le.resolve(process.cwd()),de=E();_(Oe,de.opt,de.program);export{_ as usefulTasks};
//# sourceMappingURL=index.mjs.map