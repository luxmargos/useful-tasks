#!/usr/bin/env node
"use strict";var Se=Object.create;var R=Object.defineProperty;var $e=Object.getOwnPropertyDescriptor;var Ee=Object.getOwnPropertyNames;var Re=Object.getPrototypeOf,Fe=Object.prototype.hasOwnProperty;var Ae=(r,e)=>{for(var n in e)R(r,n,{get:e[n],enumerable:!0})},ee=(r,e,n,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Ee(e))!Fe.call(r,s)&&s!==n&&R(r,s,{get:()=>e[s],enumerable:!(t=$e(e,s))||t.enumerable});return r};var x=(r,e,n)=>(n=r!=null?Se(Re(r)):{},ee(e||!r||!r.__esModule?R(n,"default",{value:r,enumerable:!0}):n,r)),Le=r=>ee(R({},"__esModule",{value:!0}),r);var je={};Ae(je,{usefulTasks:()=>S});module.exports=Le(je);var Ce=x(require("path"));var ne=require("commander"),re=x(require("path")),Oe="useful_tasks.json",te=!0,M="restore",P="keep",De=[M,P],Ie="info",Ve="debug",Ge="none",A=[Ge,Ie,Ve],Me={cwdMode:`Choose between ${De.map(r=>`'${r}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${M}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${P}' mode, the CWD will remain unchanged.`},L=r=>{let e=new ne.Command;e.name("useful-tasks").version("0.1.26").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",Oe).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',te).option("--cwd-mode <string>",Me.cwdMode,M).option("--log-level <string>",`Specify the logging level as ${A.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),r!==void 0?e.parse(r,{from:"user"}):e.parse();let t=e.opts();if(t.include=F(t.include),t.includeCta=F(t.includeCta),t.exclude=F(t.exclude),t.excludeCta=F(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===P,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let s=t.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?t.camelKeys=!1:s==="true"||s==="1"||s==="yes"?t.camelKeys=!0:t.camelKeys=te}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(re.default.resolve(t.cwd)),{opt:t,program:e}},F=(r,e=!0)=>{if(!r)return[];if(typeof r=="string"){let n=[];return r.split(",").forEach(s=>{let a=s.trim();e?a.length>0&&n.push(a):n.push(a)}),n}return[]};var G=x(require("path"));var j=x(require("fs")),N=x(require("path")),se=x(require("json5")),U=r=>{if(!j.default.existsSync(r))throw new Error(`ERROR: The Path '${r}' does not exists!`);let e=j.default.readFileSync(r,{encoding:"utf-8"});return se.default.parse(e)},K=r=>{let e=U(r);if(e.extends){let n=N.default.dirname(r),t=N.default.resolve(n,e.extends);e=Object.assign({},e,K(t))}return e},B=(r,e)=>{if(!e)return r;let n="",t=r.split("-");for(let s=0;s<t.length;s++){let a=t[s];s===0?n=a:(a.length>0&&(a=`${a[0].toUpperCase()}${a.substring(1)}`),n=`${n}${a}`)}return n},J=(r,e)=>{if(r.length<1)return!1;for(let n of r)for(let t of e)if(n===t)return!0;return!1},X=(r,e)=>{if(r.length<1)return!1;for(let n of r){let t=!1;for(let s of e)if(s===n){t=!0;break}if(!t)return!1}return!0};var ke=x(require("debug"));var oe="useful-tasks",O=`${oe}:debug`,E=`${oe}:info`,ie="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",ae="--var-",le="--env-";var q=x(require("debug"));var c=(0,q.default)(O),b=(0,q.default)(E);var ce=async(r,e)=>{let n=e;for(let t of Object.keys(n))if(typeof t=="string"&&!(t==="id"||t==="tags")&&n[t]!==void 0&&typeof n[t]=="string"){let s=n[t];for(;;){let a=r.replaceRegex.exec(s);if(a==null)break;let l=a[0],p=a[1],f=r.vars;if(p.length>0){let i=p.split(".");for(let m=0;m<i.length;m++){let $=i[m];if(f.hasOwnProperty($))f=f[$];else throw new Error(`The value of ${p} could not be found!`)}}let u=s.substring(0,a.index),v=`${f}`,k=s.substring(a.index+l.length);s=`${u}${v}${k}`,c(`Variable applied '${t}'=>'${s}'`)}n[t]=s}},H=(r,e,n,t)=>{let s,a=!1;for(let l of r){if(l.trim()==="--"){c("Stop parsing by '--'");break}if(a&&s){let f=l.startsWith("-")?"":l;t(s,f),s=void 0,a=!1}else if(l.indexOf(e)>=0){let u=l.indexOf("=");if(u>=0){let v=B(l.substring(e.length,u),n),k=l.substring(u+1);t(v,k)}else s=B(l.substring(e.length),n),a=!0}}},D=(r,e,n,t)=>{if(t&&r.vars[e]!==void 0){c(`Skips assigning the variable ${e}=${n} because it already exists.`);return}c(`Sets the variable ${e}=${n}`),r.vars[e]=n},I=(r,e,n,t)=>{var s=typeof n;if(s!=="string"&&s!=="number"&&s!=="boolean")c(`Ignoring the invalid typed(${s}) environment variable ${e}=${n}`);else if(String(n).length<1)c(`Ignoring the invalid environment variable ${e}=${n}`);else{if(t&&process.env[e]!==void 0){c(`Skips assigning the environment variable ${e}=${n} because it already exists.`);return}c(`Sets the environment variable ${e}=${n}`),process.env[e]=String(n)}};var pe=x(require("string-argv"));var fe=async(r,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let n=(0,pe.default)(e.args),t=L(n);S(r.originCwd,t.opt,t.program)};var g=x(require("fs")),ge=require("child_process"),T=x(require("path")),C=require("simple-git"),_=require("fs-extra");var de=x(require("json5"));var w=require("glob"),ue=async(r,e)=>{let n=T.default.resolve(e.localPath);g.default.existsSync(n)||g.default.mkdirSync(n,{recursive:!0}),g.default.readdirSync(n).length===0&&e.url&&await(0,C.simpleGit)().clone(e.url,n);let t=(0,C.simpleGit)(n,{binary:e.binary});if(!await t.checkIsRepo(C.CheckRepoActions.IS_REPO_ROOT))throw Error(`${n} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let l=!1,p=await t.branchLocal();for(var a of p.all)if(a===e.branch){l=!0;break}let f=e.branch??"",u=e.startPoint??"";l?(p.current!==e.branch&&await t.checkout(f),await t.reset(C.ResetMode.HARD,[u])):await t.checkoutBranch(f,u)}},me=async(r,e)=>{let n=T.default.resolve(e.target),t=T.default.resolve(e.path);if(g.default.existsSync(t)){let s=g.default.lstatSync(t);c(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(c(`Unlink ${t}`),g.default.unlinkSync(t)):s.isDirectory()&&(c(`Remove directory '${t}'`),(0,_.removeSync)(t)))}if(g.default.existsSync(t))c(`Could not create symbolic link cause '${t}' already exists`);else{c(`Create symbolic link ${n} => ${t}`),g.default.symlinkSync(n,t,e.linkType);let s=g.default.lstatSync(t);c(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}},ye=async(r,e)=>{c(`Start execution... ${e.cmd}`),(0,ge.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},he=async(r,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let n=e.value;if(n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.default.resolve(n);if(!g.default.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);n=g.default.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(n=de.default.parse(n))}D(r,e.key,n,e.isFallback)},xe=async(r,e)=>{let n=e.value;n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1);let t=e.isFallback;if(e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let s=T.default.resolve(n);n=U(s)}if(typeof n!="object")throw new Error('The content of the "value" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(n).forEach(s=>{I(r,s,n[s],t)})},Te=async(r,e)=>{let n=e.text??"",t=(e.target??"c").trim(),s=e.path;if(t==="c"||t==="console")console.log(n);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let a=T.default.resolve(s),l=T.default.dirname(a);if(g.default.existsSync(l)||(0,_.mkdirpSync)(l),t=="fa"||t=="file-append"){let p,f;try{f=g.default.openSync(a,"a"),g.default.appendFileSync(f,n,"utf8")}catch(u){p=u}finally{f!==void 0&&g.default.closeSync(f)}if(p)throw p}else g.default.writeFileSync(a,n)}};var V=(r,e)=>{if(r!=null){if(typeof r=="string")return[r];if(Array.isArray(r))return r.filter(n=>typeof n=="string")}return[]},W=(r,e,n)=>{c(`Copy: ${r} => ${e}`),(0,_.copySync)(r,e,n)},be=async(r,e)=>{if(!g.default.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let n=e?.options?.conflict,t=n==null||typeof n=="string"&&n.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let s={overwrite:t};if(g.default.statSync(e.src).isDirectory()===!1){W(e.src,e.dest,s);return}let a=V(e.include,[]),l=V(e.exclude,[]),p=v=>{for(let k of v){let i=T.default.join(e.src,k),m=T.default.join(e.dest,k);W(i,m,s)}},f=a.length>0,u=l.length>0;!f&&u?p((0,w.globSync)("**",{ignore:l,cwd:e.src})):f&&!u?p((0,w.globSync)(a,{cwd:e.src})):f&&u?p((0,w.globSync)(a,{ignore:l,cwd:e.src})):W(e.src,e.dest,s)},Y=r=>{c(`Delete: ${r}`),(0,_.removeSync)(r)},ve=async(r,e)=>{if(!g.default.existsSync(e.path)){c(`The '${e.path}' does not exist and cannot be deleted`);return}if(g.default.statSync(e.path).isDirectory()===!1){Y(e.path);return}let n=V(e.include,[]),t=V(e.exclude,[]),s=p=>{for(let f of p)Y(T.default.join(e.path,f))},a=n.length>0,l=t.length>0;!a&&l?s((0,w.globSync)("**",{ignore:t,cwd:e.path})):a&&!l?s((0,w.globSync)(n,{cwd:e.path})):a&&l?s((0,w.globSync)(n,{ignore:t,cwd:e.path})):Y(e.path)};var z={"git-repo-prepare":ue,symlink:me,cmd:ye,"set-var":he,output:Te,"fs-copy":be,"fs-del":ve,"env-var":xe,"sub-tasks":fe};var S=(r,e,n)=>{let t={},s=G.default.resolve(e.config);try{t=K(s)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),n.help()}let a,l="info",p=ie;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(l="debug"),i.logLevel&&A.includes(i.logLevel)&&(l=i.logLevel),i.replaceRegex&&(p=i.replaceRegex)}if(e.logLevel&&A.includes(e.logLevel)&&(l=e.logLevel),l==="debug"?(a=`${E},${O}`,a=`${a},simple-git,simple-git:*`):l==="info"&&(a=`${E}`),a&&ke.default.enable(a),c("CLI Options",e),typeof p!="string")throw new Error(`replaceRegex '${p}'  must be a string`);if(p.length<1)throw new Error(`replaceRegex '${p}' cannot be empty`);if(p.indexOf("(")<0||p.indexOf(")")<0)throw new Error(`replaceRegex '${p}' must contain regex group express '(' and ')'`);let f=G.default.resolve(process.cwd()),u={originCwd:r,baseCwd:f,replaceRegex:new RegExp(p),vars:{__env:{cwd_startup:r,cwd_base:f}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),H(e.extraArgs,ae,e.camelKeys,(i,m)=>{D(u,i,m,!1)}),c("Setting up the environment variables from the additional arguments"),H(e.extraArgs,le,e.camelKeys,(i,m)=>{I(u,i,m,!1)})),b(""),b(`[${t.name}] Start task processing`);let v=(i,m)=>m!=null?i.id!==void 0?`[${m}]${i.id}/${i.type}`:`[${m}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let d=0;d<i.length;d++){let o=i[d];if(o.id!==void 0&&o.id!==null){if(typeof o.id!="string")throw new Error("The task id must be a 'string' type");if(o.id.length<1)throw new Error("The task id cannot be empty");for(let h=d+1;h<i.length;h++){let y=i[h];if(y.id!==void 0&&y.id===o.id)throw new Error(`The task id '${o.id}' must be unique`)}}if(!o.type||!(o.type in z))throw new Error(`Found the invalid task type '${o.type}'`);if(o.__compare__elements=[],o.id&&(o.id=o.id.trim(),o.__compare__elements.push(o.id.trim())),o.tags){let h=y=>{c(`Ignoring invalid tags '${y}'`)};if(typeof o.tags=="string")o.tags.length>0?(o.tags=o.tags.trim(),o.__compare__elements.push(o.tags)):h(o.tags);else if(Array.isArray(o.tags)){o.tags=o.tags.map(y=>y.trim());for(let y of o.tags)typeof y=="string"&&y.length>0?o.__compare__elements.push(y):h(y)}else h(o.tags)}}if(e.exclude&&e.exclude.length>0){let d=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${d}`),i=i.filter((o,h,y)=>{if(J(d,o.__compare__elements)===!1)return o})}if(e.excludeCta&&e.excludeCta.length>0){let d=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${d}`),i=i.filter((o,h,y)=>{if(X(d,o.__compare__elements)===!1)return o})}let m=e.include&&e.include.length>0,$=e.includeCta&&e.includeCta.length>0;if(m||$){let d=e.include,o=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${d} / --include-cta=${o}`),i=i.filter((h,y,Z)=>{if(m&&J(d,h.__compare__elements)===!0||$&&X(o,h.__compare__elements)===!0)return h})}b(`Tasks : ${i.map((d,o)=>v(d,o))}`);let _e=i.length??0;for(let d=0;d<_e;d++){let o=i[d];ce(u,o);let h=v(o,d);if(o.enabled===!1){b(`
### Skip the task without execution => ${h}`);continue}else b(`
### Task : ${h}`);o.comment&&b(o.comment);let y=!1;if(o.cwd){let Q=G.default.resolve(o.cwd);b(`Changing the current working directory => ${Q}`),y=!0,process.chdir(Q)}let Z=z[o.type];await Z(u,o),e.cwdModeIsContinue||(y&&b(`Restoring the current working directory => ${f}`),process.chdir(f))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(f),b(`[${t.name}] Tasks done
`)})};var Pe=Ce.default.resolve(process.cwd()),we=L();S(Pe,we.opt,we.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map