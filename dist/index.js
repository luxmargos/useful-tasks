#!/usr/bin/env node
"use strict";var Ve=Object.create;var D=Object.defineProperty;var je=Object.getOwnPropertyDescriptor;var Pe=Object.getOwnPropertyNames;var Me=Object.getPrototypeOf,Ne=Object.prototype.hasOwnProperty;var Ue=(n,e)=>{for(var r in e)D(n,r,{get:e[r],enumerable:!0})},ie=(n,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Pe(e))!Ne.call(n,s)&&s!==r&&D(n,s,{get:()=>e[s],enumerable:!(t=je(e,s))||t.enumerable});return n};var b=(n,e,r)=>(r=n!=null?Ve(Me(n)):{},ie(e||!n||!n.__esModule?D(r,"default",{value:n,enumerable:!0}):r,n)),Ke=n=>ie(D({},"__esModule",{value:!0}),n);var rt={};Ue(rt,{usefulTasks:()=>_});module.exports=Ke(rt);var De=b(require("path"));var le=require("commander"),ce=b(require("path")),We="useful_tasks.json",ae=!0,X="restore",B="keep",Je=[X,B],Xe="info",Be="debug",He="none",V=[He,Xe,Be],qe={cwdMode:`Choose between ${Je.map(n=>`'${n}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${X}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${B}' mode, the CWD will remain unchanged.`},j=n=>{let e=new le.Command;e.name("useful-tasks").version("0.2.0").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",We).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',ae).option("--cwd-mode <string>",qe.cwdMode,X).option("--log-level <string>",`Specify the logging level as ${V.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),n!==void 0?e.parse(n,{from:"user"}):e.parse();let t=e.opts();if(t.include=I(t.include),t.includeCta=I(t.includeCta),t.exclude=I(t.exclude),t.excludeCta=I(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===B,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let s=t.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?t.camelKeys=!1:s==="true"||s==="1"||s==="yes"?t.camelKeys=!0:t.camelKeys=ae}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(ce.default.resolve(t.cwd)),{opt:t,program:e}},I=(n,e=!0)=>{if(!n)return[];if(typeof n=="string"){let r=[];return n.split(",").forEach(s=>{let o=s.trim();e?o.length>0&&r.push(o):r.push(o)}),r}return[]};var J=b(require("path"));var q=b(require("fs")),z=b(require("path")),ue=b(require("json5"));var M=b(require("debug"));var H="useful-tasks",P=`${H}:debug`,F=`${H}:info`,A=`${H}:warn`,pe="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",fe="--var-",ge="--env-";var de=(0,M.default)(A),w=(0,M.default)(F),c=(0,M.default)(P);var N=n=>{if(c(`Loading file: ${n}`),!q.default.existsSync(n))throw new Error(`ERROR: The Path '${n}' does not exists!`);return q.default.readFileSync(n,{encoding:"utf-8"})},ze=n=>U(N(n)),U=n=>ue.default.parse(n),Q=n=>{let e=ze(n);if(e.extends){let r=z.default.dirname(n),t=z.default.resolve(r,e.extends);e=Object.assign({},e,Q(t))}return e},Z=(n,e)=>{if(!e)return n;let r="",t=n.split("-");for(let s=0;s<t.length;s++){let o=t[s];s===0?r=o:(o.length>0&&(o=`${o[0].toUpperCase()}${o.substring(1)}`),r=`${r}${o}`)}return r},Y=(n,e)=>{if(n.length<1)return!1;for(let r of n)for(let t of e)if(r===t)return!0;return!1},ee=(n,e)=>{if(n.length<1)return!1;for(let r of n){let t=!1;for(let s of e)if(s===r){t=!0;break}if(!t)return!1}return!0},me=(n,e)=>{if(!e)throw new Error(`The '${n}' property must not be empty.`)},S=(n,e)=>{n[e]!==void 0&&de(`The key '${e}' has been deprecated.`)},Qe=(n,e)=>e.length<=0?!0:e.includes(typeof n),K=(n,e,r)=>{if(Qe(e,r))return!0;let t=typeof e;throw new Error(`The '${n}' property has an invalid type '${t}' with the value '${e}'. The allowed types are ${r}.`)},Ze=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;function W(n){let e={},r=n.toString();r=r.replace(/\r\n?/gm,`
`);let t;for(;(t=Ze.exec(r))!=null;){let s=t[1],o=t[2]||"";o=o.trim();let p=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/gm,"$2"),p==='"'&&(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),e[s]=o}return e}var Le=b(require("debug"));var ye=async(n,e)=>{let r=e;for(let t of Object.keys(r))if(typeof t=="string"&&!(t==="id"||t==="tags")&&r[t]!==void 0&&typeof r[t]=="string"){let s=r[t];for(;;){let o=n.replaceRegex.exec(s);if(o==null)break;let p=o[0],f=o[1],l=n.vars;if(f.length>0){let i=f.split(".");for(let y=0;y<i.length;y++){let E=i[y];if(l.hasOwnProperty(E))l=l[E];else throw new Error(`The value of ${f} could not be found!`)}}let g=s.substring(0,o.index),d=`${l}`,v=s.substring(o.index+p.length);s=`${g}${d}${v}`,c(`Variable injection: '${t}'=>'${s}'`)}r[t]=s}},te=(n,e,r,t)=>{let s,o=!1;for(let p of n){if(p.trim()==="--"){c("Stop parsing by '--'");break}if(o&&s){let l=p.startsWith("-")?"":p;t(s,l),s=void 0,o=!1}else if(p.indexOf(e)>=0){let g=p.indexOf("=");if(g>=0){let d=Z(p.substring(e.length,g),r),v=p.substring(g+1);t(d,v)}else s=Z(p.substring(e.length),r),o=!0}}},O=(n,e,r,t)=>{if(t&&n.vars[e]!==void 0){c(`Skips assigning the variable ${e}=${r} because it already exists.`);return}c(`Sets the variable ${e}=${r}`),n.vars[e]=r},L=(n,e,r,t)=>{var s=typeof r;if(s!=="string"&&s!=="number"&&s!=="boolean")c(`Ignoring the invalid typed(${s}) environment variable ${e}=${r}`);else if(String(r).length<1)c(`Ignoring the invalid environment variable ${e}=${r}`);else{if(t&&process.env[e]!==void 0){c(`Skips assigning the environment variable ${e}=${r} because it already exists.`);return}c(`Sets the environment variable ${e}=${r}`),process.env[e]=String(r)}};var he=b(require("string-argv"));var xe=async(n,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let r=(0,he.default)(e.args),t=j(r);_(n.originCwd,t.opt,t.program)};var u=b(require("fs")),ke=require("child_process"),T=b(require("path")),C=require("simple-git"),$=require("fs-extra");var Te=b(require("fs")),G=require("glob"),R=(n,e,r,t,s,o)=>{if(Te.default.statSync(e).isDirectory()===!1)return!1;let p=s===!0,f=r.length>0,l=t.length>0;return!f&&l?(n((0,G.globSync)("**",{ignore:[".",...t],cwd:e,nodir:p})),!0):f&&!l?(n((0,G.globSync)(r,{cwd:e,nodir:p})),!0):f&&l?(n((0,G.globSync)(r,{ignore:t,cwd:e,nodir:p})),!0):o?(n((0,G.globSync)("**",{ignore:["."],cwd:e,nodir:p})),!0):!1};var ne=(n,e)=>{throw new Error(`The parameter '${String(e)}' has an invalid value ${n[e]}`)},Se=async(n,e)=>{let r=T.default.resolve(e.localPath);u.default.existsSync(r)||u.default.mkdirSync(r,{recursive:!0}),u.default.readdirSync(r).length===0&&e.url&&await(0,C.simpleGit)().clone(e.url,r);let t=(0,C.simpleGit)(r,{binary:e.binary});if(!await t.checkIsRepo(C.CheckRepoActions.IS_REPO_ROOT))throw Error(`${r} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let p=!1,f=await t.branchLocal();for(var o of f.all)if(o===e.branch){p=!0;break}let l=e.branch??"",g=e.startPoint??"";p?(f.current!==e.branch&&await t.checkout(l),await t.reset(C.ResetMode.HARD,[g])):await t.checkoutBranch(l,g)}},Ce=async(n,e)=>{let r=T.default.resolve(e.target),t=T.default.resolve(e.path);if(u.default.existsSync(t)){let s=u.default.lstatSync(t);c(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(c(`Unlink ${t}`),u.default.unlinkSync(t)):s.isDirectory()&&(c(`Remove directory '${t}'`),(0,$.removeSync)(t)))}if(u.default.existsSync(t))c(`Could not create symbolic link cause '${t}' already exists`);else{c(`Create symbolic link ${r} => ${t}`),u.default.symlinkSync(r,t,e.linkType);let s=u.default.lstatSync(t);c(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}},$e=async(n,e)=>{c(`Start execution... ${e.cmd}`),(0,ke.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},_e=async(n,e)=>{S(e,"var"),S(e,"varType"),S(e,"fileFormat"),K("key",e.key,["string"]),me("key",e.key),e.isFallback!==!0&&(e.isFallback=!1);let r=e.isFallback;if(e.value!==void 0){let l=e.value;O(n,e.key,l,r)}if(!e.src)return;K("src",e.src,["string"]);let t=e.src,s=e.parser||"auto";c(`Parser = ${s}`);let o=l=>{let g=T.default.resolve(l),d,v=N(g);if(s==="auto"||s==="json")try{c("Trying to parse as JSON."),d=U(v)}catch(i){if(s==="json")throw i}!d&&(s==="auto"||s==="lines")&&(c("Trying to parse as lines."),d=W(v)),!d&&(s==="auto"||s==="string")&&(d=v),O(n,e.key,d,r)};R(l=>{for(let g of l){let d=T.default.join(t,g);u.default.statSync(d).isDirectory()||o(d)}},t,k(e.include,[]),k(e.exclude,[]),!0,!0)||o(t)},Re=async(n,e)=>{S(e,"var"),S(e,"varType"),S(e,"fileFormat"),e.isFallback!==!0&&(e.isFallback=!1);let r=e.isFallback;if(e.value!==void 0){let l=e.value;typeof l=="string"&&(c("Trying to parse as lines."),l=W(l)),Object.keys(l).forEach(g=>{L(n,g,l[g],r)})}if(!e.src)return;K("src",e.src,["string"]);let t=e.src,s=e.parser||"auto";c(`Parser = ${s}`);let o=l=>{let g=T.default.resolve(l),d,v=N(g);if(s==="auto"||s==="json")try{c("Trying to parse as JSON."),d=U(v)}catch(i){if(s==="json")throw i}if(!d&&(s==="auto"||s==="lines")&&(c("Trying to parse as lines."),d=W(v)),d){let i=d;Object.keys(i).forEach(y=>{L(n,y,i[y],r)})}};R(l=>{for(let g of l){let d=T.default.join(t,g);u.default.statSync(d).isDirectory()||o(d)}},t,k(e.include,[]),k(e.exclude,[]),!0,!0)||o(t)},Ee=async(n,e)=>{let r=e.text??"",t=(e.target??"c").trim(),s=e.path;if(t==="c"||t==="console")console.log(r);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let o=T.default.resolve(s),p=T.default.dirname(o);if(u.default.existsSync(p)||(0,$.mkdirpSync)(p),t=="fa"||t=="file-append"){let f,l;try{l=u.default.openSync(o,"a"),u.default.appendFileSync(l,r,"utf8")}catch(g){f=g}finally{l!==void 0&&u.default.closeSync(l)}if(f)throw f}else u.default.writeFileSync(o,r)}},k=(n,e)=>{if(n!=null){if(typeof n=="string")return[n];if(Array.isArray(n))return n.filter(r=>typeof r=="string")}return[]},be=(n,e,r)=>{c(`Copy: ${n} => ${e}`),(0,$.copySync)(n,e,r)},Fe=async(n,e)=>{if(!u.default.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let r=e?.options?.conflict,t=r==null||typeof r=="string"&&r.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let s={overwrite:t};R(f=>{for(let l of f){let g=T.default.join(e.src,l),d=T.default.join(e.dest,l);be(g,d,s)}},e.src,k(e.include,[]),k(e.exclude,[]),!1,!1)||be(e.src,e.dest,s)},ve=n=>{c(`Delete: ${n}`),(0,$.removeSync)(n)},Ae=async(n,e)=>{if(!u.default.existsSync(e.path)){c(`The '${e.path}' does not exist and cannot be deleted`);return}R(s=>{for(let o of s)ve(T.default.join(e.path,o))},e.path,k(e.include,[]),k(e.exclude,[]),!1,!1)||ve(e.path)},Ye=(n,e,r,t)=>{var s=n;if(t<1)for(;e.test(s);)s=s.replace(e,r);else for(var o=0;o<t;o++)e.test(s)&&(s=s.replace(e,r));return s},et=(n,e,r,t)=>{var s=n;if(t<1)for(;s.indexOf(e)>=0;)s=s.replace(e,r);else for(var o=0;o<t;o++)s.indexOf(e)>=0&&(s=s.replace(e,r));return s},tt=n=>n!=null&&typeof n=="object"&&"pattern"in n&&typeof n.pattern=="string",we=(n,e,r,t,s)=>{c(`Find and Replace: ${n}`);let o=u.default.readFileSync(n,"utf-8"),p=e(o,r,t,s);u.default.writeFileSync(n,p,"utf-8")},Oe=async(n,e)=>{if(!u.default.existsSync(e.path)){c(`The '${e.path}' does not exist`);return}(e.replace===void 0||typeof e.replace!="string")&&ne(e,"replace");let r=e.loop===void 0||e.loop===null?1:e.loop;typeof r=="string"?r=parseInt(r,10):typeof r!="number"&&ne(e,"loop");let t,s;if(tt(e.find)){let f=e.find;t=new RegExp(f.pattern,f.flags),s=Ye}else if(typeof e.find=="string")t=e.find,s=et;else{ne(e,"find");return}R(f=>{for(let l of f){let g=T.default.join(e.path,l);u.default.statSync(g).isDirectory()||we(T.default.join(e.path,l),s,t,e.replace,r)}},e.path,k(e.include,[]),k(e.exclude,[]),!0,!0)||we(e.path,s,t,e.replace,r)};var re={"git-repo-prepare":Se,symlink:Ce,cmd:$e,"set-var":_e,output:Ee,"fs-copy":Fe,"fs-del":Ae,"env-var":Re,"sub-tasks":xe,"content-replace":Oe};var _=(n,e,r)=>{let t={},s=J.default.resolve(e.config);try{t=Q(s)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),r.help()}let o,p="info",f=pe;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(p="debug"),i.logLevel&&V.includes(i.logLevel)&&(p=i.logLevel),i.replaceRegex&&(f=i.replaceRegex)}if(e.logLevel&&V.includes(e.logLevel)&&(p=e.logLevel),p==="debug"?(o=`${A},${F},${P}`,o=`${o},simple-git,simple-git:*`):p==="info"&&(o=`${A},${F}`),o&&Le.default.enable(o),c("CLI Options",e),typeof f!="string")throw new Error(`replaceRegex '${f}'  must be a string`);if(f.length<1)throw new Error(`replaceRegex '${f}' cannot be empty`);if(f.indexOf("(")<0||f.indexOf(")")<0)throw new Error(`replaceRegex '${f}' must contain regex group express '(' and ')'`);let l=J.default.resolve(process.cwd()),g={originCwd:n,baseCwd:l,replaceRegex:new RegExp(f),vars:{__env:{cwd_startup:n,cwd_base:l}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),te(e.extraArgs,fe,e.camelKeys,(i,y)=>{O(g,i,y,!1)}),c("Setting up the environment variables from the additional arguments"),te(e.extraArgs,ge,e.camelKeys,(i,y)=>{L(g,i,y,!1)})),w(""),w(`[${t.name}] Start task processing`);let d=(i,y)=>y!=null?i.id!==void 0?`[${y}]${i.id}/${i.type}`:`[${y}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let m=0;m<i.length;m++){let a=i[m];if(a.id!==void 0&&a.id!==null){if(typeof a.id!="string")throw new Error("The task id must be a 'string' type");if(a.id.length<1)throw new Error("The task id cannot be empty");for(let x=m+1;x<i.length;x++){let h=i[x];if(h.id!==void 0&&h.id===a.id)throw new Error(`The task id '${a.id}' must be unique`)}}if(!a.type||!(a.type in re))throw new Error(`Found the invalid task type '${a.type}'`);if(a.__compare__elements=[],a.id&&(a.id=a.id.trim(),a.__compare__elements.push(a.id.trim())),a.tags){let x=h=>{c(`Ignoring invalid tags '${h}'`)};if(typeof a.tags=="string")a.tags.length>0?(a.tags=a.tags.trim(),a.__compare__elements.push(a.tags)):x(a.tags);else if(Array.isArray(a.tags)){a.tags=a.tags.map(h=>h.trim());for(let h of a.tags)typeof h=="string"&&h.length>0?a.__compare__elements.push(h):x(h)}else x(a.tags)}}if(e.exclude&&e.exclude.length>0){let m=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${m}`),i=i.filter((a,x,h)=>{if(Y(m,a.__compare__elements)===!1)return a})}if(e.excludeCta&&e.excludeCta.length>0){let m=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${m}`),i=i.filter((a,x,h)=>{if(ee(m,a.__compare__elements)===!1)return a})}let y=e.include&&e.include.length>0,E=e.includeCta&&e.includeCta.length>0;if(y||E){let m=e.include,a=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${m} / --include-cta=${a}`),i=i.filter((x,h,se)=>{if(y&&Y(m,x.__compare__elements)===!0||E&&ee(a,x.__compare__elements)===!0)return x})}w(`Tasks : ${i.map((m,a)=>d(m,a))}`);let Ie=i.length??0;for(let m=0;m<Ie;m++){let a=i[m];await ye(g,a);let x=d(a,m);if(a.enabled===!1){w(`
### Skip the task without execution => ${x}`);continue}else w(`
### Task : ${x}`);a.comment&&w(a.comment);let h=!1;if(a.cwd){let oe=J.default.resolve(a.cwd);w(`Changing the current working directory => ${oe}`),h=!0,process.chdir(oe)}let se=re[a.type];await se(g,a),e.cwdModeIsContinue||(h&&w(`Restoring the current working directory => ${l}`),process.chdir(l))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(l),w(`[${t.name}] Tasks done
`)})};var nt=De.default.resolve(process.cwd()),Ge=j();_(nt,Ge.opt,Ge.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map