#!/usr/bin/env node
"use strict";var Le=Object.create;var R=Object.defineProperty;var Oe=Object.getOwnPropertyDescriptor;var Ie=Object.getOwnPropertyNames;var Ge=Object.getPrototypeOf,De=Object.prototype.hasOwnProperty;var Ve=(r,e)=>{for(var n in e)R(r,n,{get:e[n],enumerable:!0})},te=(r,e,n,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Ie(e))!De.call(r,s)&&s!==n&&R(r,s,{get:()=>e[s],enumerable:!(t=Oe(e,s))||t.enumerable});return r};var x=(r,e,n)=>(n=r!=null?Le(Ge(r)):{},te(e||!r||!r.__esModule?R(n,"default",{value:r,enumerable:!0}):n,r)),Pe=r=>te(R({},"__esModule",{value:!0}),r);var Qe={};Ve(Qe,{usefulTasks:()=>C});module.exports=Pe(Qe);var Re=x(require("path"));var re=require("commander"),se=x(require("path")),je="useful_tasks.json",ne=!0,j="restore",M="keep",Me=[j,M],Ne="info",Ke="debug",Ue="none",L=[Ue,Ne,Ke],Je={cwdMode:`Choose between ${Me.map(r=>`'${r}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${j}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${M}' mode, the CWD will remain unchanged.`},O=r=>{let e=new re.Command;e.name("useful-tasks").version("0.1.29").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",je).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',ne).option("--cwd-mode <string>",Je.cwdMode,j).option("--log-level <string>",`Specify the logging level as ${L.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),r!==void 0?e.parse(r,{from:"user"}):e.parse();let t=e.opts();if(t.include=A(t.include),t.includeCta=A(t.includeCta),t.exclude=A(t.exclude),t.excludeCta=A(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===M,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let s=t.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?t.camelKeys=!1:s==="true"||s==="1"||s==="yes"?t.camelKeys=!0:t.camelKeys=ne}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(se.default.resolve(t.cwd)),{opt:t,program:e}},A=(r,e=!0)=>{if(!r)return[];if(typeof r=="string"){let n=[];return r.split(",").forEach(s=>{let o=s.trim();e?o.length>0&&n.push(o):n.push(o)}),n}return[]};var P=x(require("path"));var N=x(require("fs")),K=x(require("path")),oe=x(require("json5")),U=r=>{if(!N.default.existsSync(r))throw new Error(`ERROR: The Path '${r}' does not exists!`);return N.default.readFileSync(r,{encoding:"utf-8"})},We=r=>J(U(r)),J=r=>oe.default.parse(r),W=r=>{let e=We(r);if(e.extends){let n=K.default.dirname(r),t=K.default.resolve(n,e.extends);e=Object.assign({},e,W(t))}return e},B=(r,e)=>{if(!e)return r;let n="",t=r.split("-");for(let s=0;s<t.length;s++){let o=t[s];s===0?n=o:(o.length>0&&(o=`${o[0].toUpperCase()}${o.substring(1)}`),n=`${n}${o}`)}return n},X=(r,e)=>{if(r.length<1)return!1;for(let n of r)for(let t of e)if(n===t)return!0;return!1},H=(r,e)=>{if(r.length<1)return!1;for(let n of r){let t=!1;for(let s of e)if(s===n){t=!0;break}if(!t)return!1}return!0};var Ee=x(require("debug"));var ie="useful-tasks",I=`${ie}:debug`,$=`${ie}:info`,ae="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",le="--var-",ce="--env-";var q=x(require("debug"));var f=(0,q.default)(I),b=(0,q.default)($);var pe=async(r,e)=>{let n=e;for(let t of Object.keys(n))if(typeof t=="string"&&!(t==="id"||t==="tags")&&n[t]!==void 0&&typeof n[t]=="string"){let s=n[t];for(;;){let o=r.replaceRegex.exec(s);if(o==null)break;let l=o[0],c=o[1],p=r.vars;if(c.length>0){let a=c.split(".");for(let h=0;h<a.length;h++){let _=a[h];if(p.hasOwnProperty(_))p=p[_];else throw new Error(`The value of ${c} could not be found!`)}}let u=s.substring(0,o.index),v=`${p}`,F=s.substring(o.index+l.length);s=`${u}${v}${F}`,f(`Variable injection: '${t}'=>'${s}'`)}n[t]=s}},Y=(r,e,n,t)=>{let s,o=!1;for(let l of r){if(l.trim()==="--"){f("Stop parsing by '--'");break}if(o&&s){let p=l.startsWith("-")?"":l;t(s,p),s=void 0,o=!1}else if(l.indexOf(e)>=0){let u=l.indexOf("=");if(u>=0){let v=B(l.substring(e.length,u),n),F=l.substring(u+1);t(v,F)}else s=B(l.substring(e.length),n),o=!0}}},G=(r,e,n,t)=>{if(t&&r.vars[e]!==void 0){f(`Skips assigning the variable ${e}=${n} because it already exists.`);return}f(`Sets the variable ${e}=${n}`),r.vars[e]=n},D=(r,e,n,t)=>{var s=typeof n;if(s!=="string"&&s!=="number"&&s!=="boolean")f(`Ignoring the invalid typed(${s}) environment variable ${e}=${n}`);else if(String(n).length<1)f(`Ignoring the invalid environment variable ${e}=${n}`);else{if(t&&process.env[e]!==void 0){f(`Skips assigning the environment variable ${e}=${n} because it already exists.`);return}f(`Sets the environment variable ${e}=${n}`),process.env[e]=String(n)}};var fe=x(require("string-argv"));var de=async(r,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let n=(0,fe.default)(e.args),t=O(n);C(r.originCwd,t.opt,t.program)};var d=x(require("fs")),he=require("child_process"),T=x(require("path")),w=require("simple-git"),k=require("fs-extra");var xe=x(require("json5"));var ge=x(require("fs")),E=require("glob"),V=(r,e,n,t,s,o)=>{if(ge.default.statSync(e).isDirectory()===!1)return!1;let l=s===!0,c=n.length>0,p=t.length>0;return!c&&p?(r((0,E.globSync)("**",{ignore:[".",...t],cwd:e,nodir:l})),!0):c&&!p?(r((0,E.globSync)(n,{cwd:e,nodir:l})),!0):c&&p?(r((0,E.globSync)(n,{ignore:t,cwd:e,nodir:l})),!0):o?(r((0,E.globSync)("**",{ignore:["."],cwd:e,nodir:l})),!0):!1};var z=(r,e)=>{throw new Error(`The parameter '${String(e)}' has an invalid value ${r[e]}`)},Te=async(r,e)=>{let n=T.default.resolve(e.localPath);d.default.existsSync(n)||d.default.mkdirSync(n,{recursive:!0}),d.default.readdirSync(n).length===0&&e.url&&await(0,w.simpleGit)().clone(e.url,n);let t=(0,w.simpleGit)(n,{binary:e.binary});if(!await t.checkIsRepo(w.CheckRepoActions.IS_REPO_ROOT))throw Error(`${n} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let l=!1,c=await t.branchLocal();for(var o of c.all)if(o===e.branch){l=!0;break}let p=e.branch??"",u=e.startPoint??"";l?(c.current!==e.branch&&await t.checkout(p),await t.reset(w.ResetMode.HARD,[u])):await t.checkoutBranch(p,u)}},be=async(r,e)=>{let n=T.default.resolve(e.target),t=T.default.resolve(e.path);if(d.default.existsSync(t)){let s=d.default.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(f(`Unlink ${t}`),d.default.unlinkSync(t)):s.isDirectory()&&(f(`Remove directory '${t}'`),(0,k.removeSync)(t)))}if(d.default.existsSync(t))f(`Could not create symbolic link cause '${t}' already exists`);else{f(`Create symbolic link ${n} => ${t}`),d.default.symlinkSync(n,t,e.linkType);let s=d.default.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}},ve=async(r,e)=>{f(`Start execution... ${e.cmd}`),(0,he.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},we=async(r,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let n=e.value;if(n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.default.resolve(n);if(!d.default.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);n=d.default.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(n=xe.default.parse(n))}G(r,e.key,n,e.isFallback)},Be=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function Xe(r){let e={},n=r.toString();n=n.replace(/\r\n?/mg,`
`);let t;for(;(t=Be.exec(n))!=null;){let s=t[1],o=t[2]||"";o=o.trim();let l=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),l==='"'&&(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),e[s]=o}return e}var ke=async(r,e)=>{let n=e.value;n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1);let t=e.isFallback;if(e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let s=T.default.resolve(n),o,l=U(s);try{o=J(l)}catch{}o||(f("Parsing with JSON failed, for now, trying to parse line literals."),o=Xe(l)),n=o}if(typeof n!="object")throw new Error('The content of the "value" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(n).forEach(s=>{D(r,s,n[s],t)})},Ce=async(r,e)=>{let n=e.text??"",t=(e.target??"c").trim(),s=e.path;if(t==="c"||t==="console")console.log(n);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let o=T.default.resolve(s),l=T.default.dirname(o);if(d.default.existsSync(l)||(0,k.mkdirpSync)(l),t=="fa"||t=="file-append"){let c,p;try{p=d.default.openSync(o,"a"),d.default.appendFileSync(p,n,"utf8")}catch(u){c=u}finally{p!==void 0&&d.default.closeSync(p)}if(c)throw c}else d.default.writeFileSync(o,n)}},S=(r,e)=>{if(r!=null){if(typeof r=="string")return[r];if(Array.isArray(r))return r.filter(n=>typeof n=="string")}return[]},ue=(r,e,n)=>{f(`Copy: ${r} => ${e}`),(0,k.copySync)(r,e,n)},Se=async(r,e)=>{if(!d.default.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let n=e?.options?.conflict,t=n==null||typeof n=="string"&&n.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let s={overwrite:t};V(c=>{for(let p of c){let u=T.default.join(e.src,p),v=T.default.join(e.dest,p);ue(u,v,s)}},e.src,S(e.include,[]),S(e.exclude,[]),!1,!1)||ue(e.src,e.dest,s)},me=r=>{f(`Delete: ${r}`),(0,k.removeSync)(r)},_e=async(r,e)=>{if(!d.default.existsSync(e.path)){f(`The '${e.path}' does not exist and cannot be deleted`);return}V(s=>{for(let o of s)me(T.default.join(e.path,o))},e.path,S(e.include,[]),S(e.exclude,[]),!1,!1)||me(e.path)},He=(r,e,n,t)=>{var s=r;if(t<1)for(;e.test(s);)s=s.replace(e,n);else for(var o=0;o<t;o++)e.test(s)&&(s=s.replace(e,n));return s},qe=(r,e,n,t)=>{var s=r;if(t<1)for(;s.indexOf(e)>=0;)s=s.replace(e,n);else for(var o=0;o<t;o++)s.indexOf(e)>=0&&(s=s.replace(e,n));return s},Ye=r=>r!=null&&typeof r=="object"&&"pattern"in r&&typeof r.pattern=="string",ye=(r,e,n,t,s)=>{f(`Find and Replace: ${r}`);let o=d.default.readFileSync(r,"utf-8"),l=e(o,n,t,s);d.default.writeFileSync(r,l,"utf-8")},$e=async(r,e)=>{if(!d.default.existsSync(e.path)){f(`The '${e.path}' does not exist`);return}(e.replace===void 0||typeof e.replace!="string")&&z(e,"replace");let n=e.loop===void 0||e.loop===null?1:e.loop;typeof n=="string"?n=parseInt(n,10):typeof n!="number"&&z(e,"loop");let t,s;if(Ye(e.find)){let c=e.find;t=new RegExp(c.pattern,c.flags),s=He}else if(typeof e.find=="string")t=e.find,s=qe;else{z(e,"find");return}V(c=>{for(let p of c){let u=T.default.join(e.path,p);d.default.statSync(u).isDirectory()||ye(T.default.join(e.path,p),s,t,e.replace,n)}},e.path,S(e.include,[]),S(e.exclude,[]),!0,!0)||ye(e.path,s,t,e.replace,n)};var Q={"git-repo-prepare":Te,symlink:be,cmd:ve,"set-var":we,output:Ce,"fs-copy":Se,"fs-del":_e,"env-var":ke,"sub-tasks":de,"content-replace":$e};var C=(r,e,n)=>{let t={},s=P.default.resolve(e.config);try{t=W(s)}catch(a){a instanceof Error?console.log(a.message):console.log(a),console.log(""),n.help()}let o,l="info",c=ae;if(t.env&&typeof t.env=="object"){let a=t.env;(a.verbose||a.verboseGit)&&(l="debug"),a.logLevel&&L.includes(a.logLevel)&&(l=a.logLevel),a.replaceRegex&&(c=a.replaceRegex)}if(e.logLevel&&L.includes(e.logLevel)&&(l=e.logLevel),l==="debug"?(o=`${$},${I}`,o=`${o},simple-git,simple-git:*`):l==="info"&&(o=`${$}`),o&&Ee.default.enable(o),f("CLI Options",e),typeof c!="string")throw new Error(`replaceRegex '${c}'  must be a string`);if(c.length<1)throw new Error(`replaceRegex '${c}' cannot be empty`);if(c.indexOf("(")<0||c.indexOf(")")<0)throw new Error(`replaceRegex '${c}' must contain regex group express '(' and ')'`);let p=P.default.resolve(process.cwd()),u={originCwd:r,baseCwd:p,replaceRegex:new RegExp(c),vars:{__env:{cwd_startup:r,cwd_base:p}}};e.extraArgs&&(f("Setting up the variables from the additional arguments"),Y(e.extraArgs,le,e.camelKeys,(a,h)=>{G(u,a,h,!1)}),f("Setting up the environment variables from the additional arguments"),Y(e.extraArgs,ce,e.camelKeys,(a,h)=>{D(u,a,h,!1)})),b(""),b(`[${t.name}] Start task processing`);let v=(a,h)=>h!=null?a.id!==void 0?`[${h}]${a.id}/${a.type}`:`[${h}]${a.type}`:a.id!==void 0?`${a.id}/${a.type}`:`${a.type}`;(async()=>{let a=t.tasks??[];for(let g=0;g<a.length;g++){let i=a[g];if(i.id!==void 0&&i.id!==null){if(typeof i.id!="string")throw new Error("The task id must be a 'string' type");if(i.id.length<1)throw new Error("The task id cannot be empty");for(let y=g+1;y<a.length;y++){let m=a[y];if(m.id!==void 0&&m.id===i.id)throw new Error(`The task id '${i.id}' must be unique`)}}if(!i.type||!(i.type in Q))throw new Error(`Found the invalid task type '${i.type}'`);if(i.__compare__elements=[],i.id&&(i.id=i.id.trim(),i.__compare__elements.push(i.id.trim())),i.tags){let y=m=>{f(`Ignoring invalid tags '${m}'`)};if(typeof i.tags=="string")i.tags.length>0?(i.tags=i.tags.trim(),i.__compare__elements.push(i.tags)):y(i.tags);else if(Array.isArray(i.tags)){i.tags=i.tags.map(m=>m.trim());for(let m of i.tags)typeof m=="string"&&m.length>0?i.__compare__elements.push(m):y(m)}else y(i.tags)}}if(e.exclude&&e.exclude.length>0){let g=e.exclude;f(`Excluding tasks by specified IDs or Tags : --exclude=${g}`),a=a.filter((i,y,m)=>{if(X(g,i.__compare__elements)===!1)return i})}if(e.excludeCta&&e.excludeCta.length>0){let g=e.excludeCta;f(`Excluding tasks by specified IDs or Tags : --exclude-cta=${g}`),a=a.filter((i,y,m)=>{if(H(g,i.__compare__elements)===!1)return i})}let h=e.include&&e.include.length>0,_=e.includeCta&&e.includeCta.length>0;if(h||_){let g=e.include,i=e.includeCta;f(`Including tasks by specified IDs or Tags : --include=${g} / --include-cta=${i}`),a=a.filter((y,m,Z)=>{if(h&&X(g,y.__compare__elements)===!0||_&&H(i,y.__compare__elements)===!0)return y})}b(`Tasks : ${a.map((g,i)=>v(g,i))}`);let Ae=a.length??0;for(let g=0;g<Ae;g++){let i=a[g];pe(u,i);let y=v(i,g);if(i.enabled===!1){b(`
### Skip the task without execution => ${y}`);continue}else b(`
### Task : ${y}`);i.comment&&b(i.comment);let m=!1;if(i.cwd){let ee=P.default.resolve(i.cwd);b(`Changing the current working directory => ${ee}`),m=!0,process.chdir(ee)}let Z=Q[i.type];await Z(u,i),e.cwdModeIsContinue||(m&&b(`Restoring the current working directory => ${p}`),process.chdir(p))}})().then(()=>{}).catch(a=>{throw a}).finally(()=>{process.chdir(p),b(`[${t.name}] Tasks done
`)})};var ze=Re.default.resolve(process.cwd()),Fe=O();C(ze,Fe.opt,Fe.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map