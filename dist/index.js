#!/usr/bin/env node
"use strict";var Ae=Object.create;var F=Object.defineProperty;var Le=Object.getOwnPropertyDescriptor;var Oe=Object.getOwnPropertyNames;var Ge=Object.getPrototypeOf,Ie=Object.prototype.hasOwnProperty;var De=(r,e)=>{for(var n in e)F(r,n,{get:e[n],enumerable:!0})},ee=(r,e,n,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Oe(e))!Ie.call(r,s)&&s!==n&&F(r,s,{get:()=>e[s],enumerable:!(t=Le(e,s))||t.enumerable});return r};var x=(r,e,n)=>(n=r!=null?Ae(Ge(r)):{},ee(e||!r||!r.__esModule?F(n,"default",{value:r,enumerable:!0}):n,r)),Ve=r=>ee(F({},"__esModule",{value:!0}),r);var He={};De(He,{usefulTasks:()=>C});module.exports=Ve(He);var Re=x(require("path"));var ne=require("commander"),re=x(require("path")),Pe="useful_tasks.json",te=!0,M="restore",j="keep",Me=[M,j],je="info",Ke="debug",Ne="none",L=[Ne,je,Ke],Ue={cwdMode:`Choose between ${Me.map(r=>`'${r}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${M}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${j}' mode, the CWD will remain unchanged.`},O=r=>{let e=new ne.Command;e.name("useful-tasks").version("0.1.29").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",Pe).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',te).option("--cwd-mode <string>",Ue.cwdMode,M).option("--log-level <string>",`Specify the logging level as ${L.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),r!==void 0?e.parse(r,{from:"user"}):e.parse();let t=e.opts();if(t.include=A(t.include),t.includeCta=A(t.includeCta),t.exclude=A(t.exclude),t.excludeCta=A(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===j,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let s=t.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?t.camelKeys=!1:s==="true"||s==="1"||s==="yes"?t.camelKeys=!0:t.camelKeys=te}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(re.default.resolve(t.cwd)),{opt:t,program:e}},A=(r,e=!0)=>{if(!r)return[];if(typeof r=="string"){let n=[];return r.split(",").forEach(s=>{let i=s.trim();e?i.length>0&&n.push(i):n.push(i)}),n}return[]};var P=x(require("path"));var K=x(require("fs")),N=x(require("path")),se=x(require("json5")),U=r=>{if(!K.default.existsSync(r))throw new Error(`ERROR: The Path '${r}' does not exists!`);let e=K.default.readFileSync(r,{encoding:"utf-8"});return se.default.parse(e)},W=r=>{let e=U(r);if(e.extends){let n=N.default.dirname(r),t=N.default.resolve(n,e.extends);e=Object.assign({},e,W(t))}return e},B=(r,e)=>{if(!e)return r;let n="",t=r.split("-");for(let s=0;s<t.length;s++){let i=t[s];s===0?n=i:(i.length>0&&(i=`${i[0].toUpperCase()}${i.substring(1)}`),n=`${n}${i}`)}return n},J=(r,e)=>{if(r.length<1)return!1;for(let n of r)for(let t of e)if(n===t)return!0;return!1},X=(r,e)=>{if(r.length<1)return!1;for(let n of r){let t=!1;for(let s of e)if(s===n){t=!0;break}if(!t)return!1}return!0};var $e=x(require("debug"));var oe="useful-tasks",G=`${oe}:debug`,$=`${oe}:info`,ie="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",ae="--var-",le="--env-";var H=x(require("debug"));var f=(0,H.default)(G),b=(0,H.default)($);var ce=async(r,e)=>{let n=e;for(let t of Object.keys(n))if(typeof t=="string"&&!(t==="id"||t==="tags")&&n[t]!==void 0&&typeof n[t]=="string"){let s=n[t];for(;;){let i=r.replaceRegex.exec(s);if(i==null)break;let c=i[0],l=i[1],p=r.vars;if(l.length>0){let a=l.split(".");for(let h=0;h<a.length;h++){let _=a[h];if(p.hasOwnProperty(_))p=p[_];else throw new Error(`The value of ${l} could not be found!`)}}let u=s.substring(0,i.index),v=`${p}`,R=s.substring(i.index+c.length);s=`${u}${v}${R}`,f(`Variable injection: '${t}'=>'${s}'`)}n[t]=s}},q=(r,e,n,t)=>{let s,i=!1;for(let c of r){if(c.trim()==="--"){f("Stop parsing by '--'");break}if(i&&s){let p=c.startsWith("-")?"":c;t(s,p),s=void 0,i=!1}else if(c.indexOf(e)>=0){let u=c.indexOf("=");if(u>=0){let v=B(c.substring(e.length,u),n),R=c.substring(u+1);t(v,R)}else s=B(c.substring(e.length),n),i=!0}}},I=(r,e,n,t)=>{if(t&&r.vars[e]!==void 0){f(`Skips assigning the variable ${e}=${n} because it already exists.`);return}f(`Sets the variable ${e}=${n}`),r.vars[e]=n},D=(r,e,n,t)=>{var s=typeof n;if(s!=="string"&&s!=="number"&&s!=="boolean")f(`Ignoring the invalid typed(${s}) environment variable ${e}=${n}`);else if(String(n).length<1)f(`Ignoring the invalid environment variable ${e}=${n}`);else{if(t&&process.env[e]!==void 0){f(`Skips assigning the environment variable ${e}=${n} because it already exists.`);return}f(`Sets the environment variable ${e}=${n}`),process.env[e]=String(n)}};var pe=x(require("string-argv"));var fe=async(r,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let n=(0,pe.default)(e.args),t=O(n);C(r.originCwd,t.opt,t.program)};var d=x(require("fs")),ye=require("child_process"),T=x(require("path")),k=require("simple-git"),w=require("fs-extra");var he=x(require("json5"));var de=x(require("fs")),E=require("glob"),V=(r,e,n,t,s,i)=>{if(de.default.statSync(e).isDirectory()===!1)return!1;let c=s===!0,l=n.length>0,p=t.length>0;return!l&&p?(r((0,E.globSync)("**",{ignore:[".",...t],cwd:e,nodir:c})),!0):l&&!p?(r((0,E.globSync)(n,{cwd:e,nodir:c})),!0):l&&p?(r((0,E.globSync)(n,{ignore:t,cwd:e,nodir:c})),!0):i?(r((0,E.globSync)("**",{ignore:["."],cwd:e,nodir:c})),!0):!1};var Y=(r,e)=>{throw new Error(`The parameter '${String(e)}' has an invalid value ${r[e]}`)},xe=async(r,e)=>{let n=T.default.resolve(e.localPath);d.default.existsSync(n)||d.default.mkdirSync(n,{recursive:!0}),d.default.readdirSync(n).length===0&&e.url&&await(0,k.simpleGit)().clone(e.url,n);let t=(0,k.simpleGit)(n,{binary:e.binary});if(!await t.checkIsRepo(k.CheckRepoActions.IS_REPO_ROOT))throw Error(`${n} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let c=!1,l=await t.branchLocal();for(var i of l.all)if(i===e.branch){c=!0;break}let p=e.branch??"",u=e.startPoint??"";c?(l.current!==e.branch&&await t.checkout(p),await t.reset(k.ResetMode.HARD,[u])):await t.checkoutBranch(p,u)}},Te=async(r,e)=>{let n=T.default.resolve(e.target),t=T.default.resolve(e.path);if(d.default.existsSync(t)){let s=d.default.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(f(`Unlink ${t}`),d.default.unlinkSync(t)):s.isDirectory()&&(f(`Remove directory '${t}'`),(0,w.removeSync)(t)))}if(d.default.existsSync(t))f(`Could not create symbolic link cause '${t}' already exists`);else{f(`Create symbolic link ${n} => ${t}`),d.default.symlinkSync(n,t,e.linkType);let s=d.default.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}},be=async(r,e)=>{f(`Start execution... ${e.cmd}`),(0,ye.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},ve=async(r,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let n=e.value;if(n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.default.resolve(n);if(!d.default.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);n=d.default.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(n=he.default.parse(n))}I(r,e.key,n,e.isFallback)},ke=async(r,e)=>{let n=e.value;n==null&&e.var&&(n=e.var),e.isFallback!==!0&&(e.isFallback=!1);let t=e.isFallback;if(e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let s=T.default.resolve(n);n=U(s)}if(typeof n!="object")throw new Error('The content of the "value" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(n).forEach(s=>{D(r,s,n[s],t)})},we=async(r,e)=>{let n=e.text??"",t=(e.target??"c").trim(),s=e.path;if(t==="c"||t==="console")console.log(n);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let i=T.default.resolve(s),c=T.default.dirname(i);if(d.default.existsSync(c)||(0,w.mkdirpSync)(c),t=="fa"||t=="file-append"){let l,p;try{p=d.default.openSync(i,"a"),d.default.appendFileSync(p,n,"utf8")}catch(u){l=u}finally{p!==void 0&&d.default.closeSync(p)}if(l)throw l}else d.default.writeFileSync(i,n)}},S=(r,e)=>{if(r!=null){if(typeof r=="string")return[r];if(Array.isArray(r))return r.filter(n=>typeof n=="string")}return[]},ge=(r,e,n)=>{f(`Copy: ${r} => ${e}`),(0,w.copySync)(r,e,n)},Ce=async(r,e)=>{if(!d.default.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let n=e?.options?.conflict,t=n==null||typeof n=="string"&&n.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let s={overwrite:t};V(l=>{for(let p of l){let u=T.default.join(e.src,p),v=T.default.join(e.dest,p);ge(u,v,s)}},e.src,S(e.include,[]),S(e.exclude,[]),!1,!1)||ge(e.src,e.dest,s)},ue=r=>{f(`Delete: ${r}`),(0,w.removeSync)(r)},Se=async(r,e)=>{if(!d.default.existsSync(e.path)){f(`The '${e.path}' does not exist and cannot be deleted`);return}V(s=>{for(let i of s)ue(T.default.join(e.path,i))},e.path,S(e.include,[]),S(e.exclude,[]),!1,!1)||ue(e.path)},We=(r,e,n,t)=>{var s=r;if(t<1)for(;e.test(s);)s=s.replace(e,n);else for(var i=0;i<t;i++)e.test(s)&&(s=s.replace(e,n));return s},Be=(r,e,n,t)=>{var s=r;if(t<1)for(;s.indexOf(e)>=0;)s=s.replace(e,n);else for(var i=0;i<t;i++)s.indexOf(e)>=0&&(s=s.replace(e,n));return s},Je=r=>r!=null&&typeof r=="object"&&"pattern"in r&&typeof r.pattern=="string",me=(r,e,n,t,s)=>{f(`Find and Replace: ${r}`);let i=d.default.readFileSync(r,"utf-8"),c=e(i,n,t,s);d.default.writeFileSync(r,c,"utf-8")},_e=async(r,e)=>{if(!d.default.existsSync(e.path)){f(`The '${e.path}' does not exist`);return}(e.replace===void 0||typeof e.replace!="string")&&Y(e,"replace");let n=e.loop===void 0||e.loop===null?1:e.loop;typeof n=="string"?n=parseInt(n,10):typeof n!="number"&&Y(e,"loop");let t,s;if(Je(e.find)){let l=e.find;t=new RegExp(l.pattern,l.flags),s=We}else if(typeof e.find=="string")t=e.find,s=Be;else{Y(e,"find");return}V(l=>{for(let p of l){let u=T.default.join(e.path,p);d.default.statSync(u).isDirectory()||me(T.default.join(e.path,p),s,t,e.replace,n)}},e.path,S(e.include,[]),S(e.exclude,[]),!0,!0)||me(e.path,s,t,e.replace,n)};var z={"git-repo-prepare":xe,symlink:Te,cmd:be,"set-var":ve,output:we,"fs-copy":Ce,"fs-del":Se,"env-var":ke,"sub-tasks":fe,"content-replace":_e};var C=(r,e,n)=>{let t={},s=P.default.resolve(e.config);try{t=W(s)}catch(a){a instanceof Error?console.log(a.message):console.log(a),console.log(""),n.help()}let i,c="info",l=ie;if(t.env&&typeof t.env=="object"){let a=t.env;(a.verbose||a.verboseGit)&&(c="debug"),a.logLevel&&L.includes(a.logLevel)&&(c=a.logLevel),a.replaceRegex&&(l=a.replaceRegex)}if(e.logLevel&&L.includes(e.logLevel)&&(c=e.logLevel),c==="debug"?(i=`${$},${G}`,i=`${i},simple-git,simple-git:*`):c==="info"&&(i=`${$}`),i&&$e.default.enable(i),f("CLI Options",e),typeof l!="string")throw new Error(`replaceRegex '${l}'  must be a string`);if(l.length<1)throw new Error(`replaceRegex '${l}' cannot be empty`);if(l.indexOf("(")<0||l.indexOf(")")<0)throw new Error(`replaceRegex '${l}' must contain regex group express '(' and ')'`);let p=P.default.resolve(process.cwd()),u={originCwd:r,baseCwd:p,replaceRegex:new RegExp(l),vars:{__env:{cwd_startup:r,cwd_base:p}}};e.extraArgs&&(f("Setting up the variables from the additional arguments"),q(e.extraArgs,ae,e.camelKeys,(a,h)=>{I(u,a,h,!1)}),f("Setting up the environment variables from the additional arguments"),q(e.extraArgs,le,e.camelKeys,(a,h)=>{D(u,a,h,!1)})),b(""),b(`[${t.name}] Start task processing`);let v=(a,h)=>h!=null?a.id!==void 0?`[${h}]${a.id}/${a.type}`:`[${h}]${a.type}`:a.id!==void 0?`${a.id}/${a.type}`:`${a.type}`;(async()=>{let a=t.tasks??[];for(let g=0;g<a.length;g++){let o=a[g];if(o.id!==void 0&&o.id!==null){if(typeof o.id!="string")throw new Error("The task id must be a 'string' type");if(o.id.length<1)throw new Error("The task id cannot be empty");for(let y=g+1;y<a.length;y++){let m=a[y];if(m.id!==void 0&&m.id===o.id)throw new Error(`The task id '${o.id}' must be unique`)}}if(!o.type||!(o.type in z))throw new Error(`Found the invalid task type '${o.type}'`);if(o.__compare__elements=[],o.id&&(o.id=o.id.trim(),o.__compare__elements.push(o.id.trim())),o.tags){let y=m=>{f(`Ignoring invalid tags '${m}'`)};if(typeof o.tags=="string")o.tags.length>0?(o.tags=o.tags.trim(),o.__compare__elements.push(o.tags)):y(o.tags);else if(Array.isArray(o.tags)){o.tags=o.tags.map(m=>m.trim());for(let m of o.tags)typeof m=="string"&&m.length>0?o.__compare__elements.push(m):y(m)}else y(o.tags)}}if(e.exclude&&e.exclude.length>0){let g=e.exclude;f(`Excluding tasks by specified IDs or Tags : --exclude=${g}`),a=a.filter((o,y,m)=>{if(J(g,o.__compare__elements)===!1)return o})}if(e.excludeCta&&e.excludeCta.length>0){let g=e.excludeCta;f(`Excluding tasks by specified IDs or Tags : --exclude-cta=${g}`),a=a.filter((o,y,m)=>{if(X(g,o.__compare__elements)===!1)return o})}let h=e.include&&e.include.length>0,_=e.includeCta&&e.includeCta.length>0;if(h||_){let g=e.include,o=e.includeCta;f(`Including tasks by specified IDs or Tags : --include=${g} / --include-cta=${o}`),a=a.filter((y,m,Z)=>{if(h&&J(g,y.__compare__elements)===!0||_&&X(o,y.__compare__elements)===!0)return y})}b(`Tasks : ${a.map((g,o)=>v(g,o))}`);let Fe=a.length??0;for(let g=0;g<Fe;g++){let o=a[g];ce(u,o);let y=v(o,g);if(o.enabled===!1){b(`
### Skip the task without execution => ${y}`);continue}else b(`
### Task : ${y}`);o.comment&&b(o.comment);let m=!1;if(o.cwd){let Q=P.default.resolve(o.cwd);b(`Changing the current working directory => ${Q}`),m=!0,process.chdir(Q)}let Z=z[o.type];await Z(u,o),e.cwdModeIsContinue||(m&&b(`Restoring the current working directory => ${p}`),process.chdir(p))}})().then(()=>{}).catch(a=>{throw a}).finally(()=>{process.chdir(p),b(`[${t.name}] Tasks done
`)})};var Xe=Re.default.resolve(process.cwd()),Ee=O();C(Xe,Ee.opt,Ee.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map