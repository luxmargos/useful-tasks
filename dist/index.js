#!/usr/bin/env node
"use strict";var rt=Object.create;var M=Object.defineProperty;var nt=Object.getOwnPropertyDescriptor;var ot=Object.getOwnPropertyNames;var st=Object.getPrototypeOf,it=Object.prototype.hasOwnProperty;var at=(r,e)=>{for(var n in e)M(r,n,{get:e[n],enumerable:!0})},de=(r,e,n,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of ot(e))!it.call(r,o)&&o!==n&&M(r,o,{get:()=>e[o],enumerable:!(t=nt(e,o))||t.enumerable});return r};var m=(r,e,n)=>(n=r!=null?rt(st(r)):{},de(e||!r||!r.__esModule?M(n,"default",{value:r,enumerable:!0}):n,r)),lt=r=>de(M({},"__esModule",{value:!0}),r);var kt={};at(kt,{usefulTasks:()=>_});module.exports=lt(kt);var et=m(require("path"));var ue=require("commander"),ye=m(require("path")),ct="useful_tasks.json",me=!0,H="restore",q="keep",pt=[H,q],ft="info",gt="debug",dt="none",N=[dt,ft,gt],mt={cwdMode:`Choose between ${pt.map(r=>`'${r}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${H}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${q}' mode, the CWD will remain unchanged.`},U=r=>{let e=new ue.Command;e.name("useful-tasks").version("0.2.1").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",ct).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',me).option("--cwd-mode <string>",mt.cwdMode,H).option("--log-level <string>",`Specify the logging level as ${N.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),r!==void 0?e.parse(r,{from:"user"}):e.parse();let t=e.opts();if(t.include=P(t.include),t.includeCta=P(t.includeCta),t.exclude=P(t.exclude),t.excludeCta=P(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===q,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let o=t.camelKeys;o=o.trim().toLowerCase(),o==="false"||o==="0"||o==="no"?t.camelKeys=!1:o==="true"||o==="1"||o==="yes"?t.camelKeys=!0:t.camelKeys=me}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(ye.default.resolve(t.cwd)),{opt:t,program:e}},P=(r,e=!0)=>{if(!r)return[];if(typeof r=="string"){let n=[];return r.split(",").forEach(o=>{let s=o.trim();e?s.length>0&&n.push(s):n.push(s)}),n}return[]};var B=m(require("path"));var Q=m(require("fs")),Z=m(require("path")),ve=m(require("json5"));var K=m(require("debug"));var z="useful-tasks",W=`${z}:debug`,R=`${z}:info`,A=`${z}:warn`,he="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",xe="--var-",Te="--env-";var be=(0,K.default)(A),v=(0,K.default)(R),c=(0,K.default)(W);var O=r=>{if(c(`Loading file: ${r}`),!Q.default.existsSync(r))throw new Error(`ERROR: The Path '${r}' does not exists!`);return Q.default.readFileSync(r,{encoding:"utf-8"})},ut=r=>L(O(r)),L=r=>ve.default.parse(r),Y=r=>{let e=ut(r);if(e.extends){let n=Z.default.dirname(r),t=Z.default.resolve(n,e.extends);e=Object.assign({},e,Y(t))}return e},ee=(r,e)=>{if(!e)return r;let n="",t=r.split("-");for(let o=0;o<t.length;o++){let s=t[o];o===0?n=s:(s.length>0&&(s=`${s[0].toUpperCase()}${s.substring(1)}`),n=`${n}${s}`)}return n},te=(r,e)=>{if(r.length<1)return!1;for(let n of r)for(let t of e)if(n===t)return!0;return!1},re=(r,e)=>{if(r.length<1)return!1;for(let n of r){let t=!1;for(let o of e)if(o===n){t=!0;break}if(!t)return!1}return!0},ke=(r,e)=>{if(!e)throw new Error(`The '${r}' property must not be empty.`)},w=(r,e)=>{r[e]!==void 0&&be(`The key '${e}' has been deprecated.`)},yt=(r,e)=>e.length<=0?!0:e.includes(typeof r),S=(r,e,n)=>{if(yt(e,n))return!0;let t=typeof e;throw new Error(`The '${r}' property has an invalid type '${t}' with the value '${e}'. The allowed types are [${n}].`)},ht=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;function G(r){let e={},n=r.toString();n=n.replace(/\r\n?/gm,`
`);let t;for(;(t=ht.exec(n))!=null;){let o=t[1],s=t[2]||"";s=s.trim();let p=s[0];s=s.replace(/^(['"`])([\s\S]*)\1$/gm,"$2"),p==='"'&&(s=s.replace(/\\n/g,`
`),s=s.replace(/\\r/g,"\r")),e[o]=s}return e}var J=(r,e)=>{throw new Error(`The parameter '${String(e)}' has an invalid value ${r[e]}`)},T=(r,e)=>{if(r!=null){if(typeof r=="string")return[r];if(Array.isArray(r))return r.filter(n=>typeof n=="string")}return e};var Ze=m(require("debug"));var we=async(r,e)=>{let n=e;for(let t of Object.keys(n))if(typeof t=="string"&&!(t==="id"||t==="tags")&&n[t]!==void 0&&typeof n[t]=="string"){let o=n[t];for(;;){let s=r.replaceRegex.exec(o);if(s==null)break;let p=s[0],f=s[1],l=r.vars;if(f.length>0){let i=f.split(".");for(let y=0;y<i.length;y++){let E=i[y];if(l.hasOwnProperty(E))l=l[E];else throw new Error(`The value of ${f} could not be found!`)}}let g=o.substring(0,s.index),d=`${l}`,b=o.substring(s.index+p.length);o=`${g}${d}${b}`,c(`Variable injection: '${t}'=>'${o}'`)}n[t]=o}},ne=(r,e,n,t)=>{let o,s=!1;for(let p of r){if(p.trim()==="--"){c("Stop parsing by '--'");break}if(s&&o){let l=p.startsWith("-")?"":p;t(o,l),o=void 0,s=!1}else if(p.indexOf(e)>=0){let g=p.indexOf("=");if(g>=0){let d=ee(p.substring(e.length,g),n),b=p.substring(g+1);t(d,b)}else o=ee(p.substring(e.length),n),s=!0}}},D=(r,e,n,t)=>{if(t&&r.vars[e]!==void 0){c(`Skips assigning the variable ${e}=${n} because it already exists.`);return}c(`Sets the variable ${e}=${n}`),r.vars[e]=n},I=(r,e,n,t)=>{var o=typeof n;if(o!=="string"&&o!=="number"&&o!=="boolean")c(`Ignoring the invalid typed(${o}) environment variable ${e}=${n}`);else if(String(n).length<1)c(`Ignoring the invalid environment variable ${e}=${n}`);else{if(t&&process.env[e]!==void 0){c(`Skips assigning the environment variable ${e}=${n} because it already exists.`);return}c(`Sets the environment variable ${e}=${n}`),process.env[e]=String(n)}};var Se=m(require("string-argv"));var Ce=async(r,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let n=(0,Se.default)(e.args),t=U(n);_(r.originCwd,t.opt,t.program)};var j=m(require("fs")),oe=m(require("path"));var $e=m(require("fs")),V=require("glob"),k=(r,e,n,t,o,s)=>{if($e.default.statSync(e).isDirectory()===!1)return!1;let p=o===!0,f=n.length>0,l=t.length>0;return!f&&l?(r((0,V.globSync)("**",{ignore:[".",...t],cwd:e,nodir:p})),!0):f&&!l?(r((0,V.globSync)(n,{cwd:e,nodir:p})),!0):f&&l?(r((0,V.globSync)(n,{ignore:t,cwd:e,nodir:p})),!0):s?(r((0,V.globSync)("**",{ignore:["."],cwd:e,nodir:p})),!0):!1};var xt=(r,e,n,t)=>{var o=r;if(t<1)for(;e.test(o);)o=o.replace(e,n);else for(var s=0;s<t;s++)e.test(o)&&(o=o.replace(e,n));return o},Tt=(r,e,n,t)=>{var o=r;if(t<1)for(;o.indexOf(e)>=0;)o=o.replace(e,n);else for(var s=0;s<t;s++)o.indexOf(e)>=0&&(o=o.replace(e,n));return o},bt=r=>r!=null&&typeof r=="object"&&"pattern"in r&&typeof r.pattern=="string",_e=(r,e,n,t,o)=>{c(`Find and Replace: ${r}`);let s=j.default.readFileSync(r,"utf-8"),p=e(s,n,t,o);j.default.writeFileSync(r,p,"utf-8")},Fe=async(r,e)=>{if(!j.default.existsSync(e.path)){c(`The '${e.path}' does not exist`);return}(e.replace===void 0||typeof e.replace!="string")&&J(e,"replace");let n=e.loop===void 0||e.loop===null?1:e.loop;typeof n=="string"?n=parseInt(n,10):typeof n!="number"&&J(e,"loop");let t,o;if(bt(e.find)){let f=e.find;t=new RegExp(f.pattern,f.flags),o=xt}else if(typeof e.find=="string")t=e.find,o=Tt;else{J(e,"find");return}k(f=>{for(let l of f){let g=oe.default.join(e.path,l);j.default.statSync(g).isDirectory()||_e(oe.default.join(e.path,l),o,t,e.replace,n)}},e.path,T(e.include,[]),T(e.exclude,[]),!0,!0)||_e(e.path,o,t,e.replace,n)};var Ee=require("fs-extra");var Re=async(r,e)=>{S("path",e.path,["string"]),c(`Make a directory at : ${e.path}`),(0,Ee.mkdirpSync)(e.path)};var Oe=m(require("fs"));var Le=m(require("path")),Ge=require("fs-extra");var Ae=r=>{c(`Delete: ${r}`),(0,Ge.removeSync)(r)},De=async(r,e)=>{if(!Oe.default.existsSync(e.path)){c(`The '${e.path}' does not exist and cannot be deleted`);return}k(o=>{for(let s of o)Ae(Le.default.join(e.path,s))},e.path,T(e.include,[]),T(e.exclude,[]),!1,!1)||Ae(e.path)};var se=m(require("path"));var Ve=m(require("fs-extra")),je=require("fs-extra");var Ie=(r,e,n)=>{c(`Copy: ${r} => ${e}`),(0,je.copySync)(r,e,n)},Me=async(r,e)=>{if(!Ve.default.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let n=e?.options?.conflict,t=n==null||typeof n=="string"&&n.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let o={overwrite:t};k(f=>{for(let l of f){let g=se.default.join(e.src,l),d=se.default.join(e.dest,l);Ie(g,d,o)}},e.src,T(e.include,[]),T(e.exclude,[]),!1,!1)||Ie(e.src,e.dest,o)};var F=m(require("fs")),Pe=require("fs-extra"),ie=m(require("path")),Ne=async(r,e)=>{let n=e.text??"",t=(e.target??"c").trim(),o=e.path;if(t==="c"||t==="console")console.log(n);else{if(!o)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let s=ie.default.resolve(o),p=ie.default.dirname(s);if(F.default.existsSync(p)||(0,Pe.mkdirpSync)(p),t=="fa"||t=="file-append"){let f,l;try{l=F.default.openSync(s,"a"),F.default.appendFileSync(l,n,"utf8")}catch(g){f=g}finally{l!==void 0&&F.default.closeSync(l)}if(f)throw f}else F.default.writeFileSync(s,n)}};var Ue=m(require("fs-extra"));var ae=m(require("path"));var We=async(r,e)=>{w(e,"var"),w(e,"varType"),w(e,"fileFormat"),e.isFallback!==!0&&(e.isFallback=!1);let n=e.isFallback;if(e.value!==void 0){let l=e.value;typeof l=="string"&&(c("Trying to parse as lines."),l=G(l)),Object.keys(l).forEach(g=>{I(r,g,l[g],n)})}if(!e.src)return;S("src",e.src,["string"]);let t=e.src,o=e.parser||"auto";c(`Parser = ${o}`);let s=l=>{let g=ae.default.resolve(l),d,b=O(g);if(o==="auto"||o==="json")try{c("Trying to parse as JSON."),d=L(b)}catch(i){if(o==="json")throw i}if(!d&&(o==="auto"||o==="lines")&&(c("Trying to parse as lines."),d=G(b)),d){let i=d;Object.keys(i).forEach(y=>{I(r,y,i[y],n)})}};k(l=>{for(let g of l){let d=ae.default.join(t,g);Ue.default.statSync(d).isDirectory()||s(d)}},t,T(e.include,[]),T(e.exclude,[]),!0,!0)||s(t)};var Ke=m(require("fs"));var le=m(require("path"));var Je=async(r,e)=>{w(e,"var"),w(e,"varType"),w(e,"fileFormat"),S("key",e.key,["string"]),ke("key",e.key),e.isFallback!==!0&&(e.isFallback=!1);let n=e.isFallback;if(e.value!==void 0){let l=e.value;D(r,e.key,l,n)}if(!e.src)return;S("src",e.src,["string"]);let t=e.src,o=e.parser||"auto";c(`Parser = ${o}`);let s=l=>{let g=le.default.resolve(l),d,b=O(g);if(o==="auto"||o==="json")try{c("Trying to parse as JSON."),d=L(b)}catch(i){if(o==="json")throw i}!d&&(o==="auto"||o==="lines")&&(c("Trying to parse as lines."),d=G(b)),!d&&(o==="auto"||o==="string")&&(d=b),D(r,e.key,d,n)};k(l=>{for(let g of l){let d=le.default.join(t,g);Ke.default.statSync(d).isDirectory()||s(d)}},t,T(e.include,[]),T(e.exclude,[]),!0,!0)||s(t)};var Xe=require("child_process");var Be=async(r,e)=>{c(`Start execution... ${e.cmd}`),(0,Xe.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})};var C=m(require("fs")),He=require("fs-extra");var ce=m(require("path")),qe=async(r,e)=>{let n=ce.default.resolve(e.target),t=ce.default.resolve(e.path);if(C.default.existsSync(t)){let o=C.default.lstatSync(t);c(`LSTAT is symlink? ${o.isSymbolicLink()}, is directory? ${o.isDirectory()}`),e.forced&&(o.isSymbolicLink()||o.isFile()?(c(`Unlink ${t}`),C.default.unlinkSync(t)):o.isDirectory()&&(c(`Remove directory '${t}'`),(0,He.removeSync)(t)))}if(C.default.existsSync(t))c(`Could not create symbolic link cause '${t}' already exists`);else{c(`Create symbolic link ${n} => ${t}`),C.default.symlinkSync(n,t,e.linkType);let o=C.default.lstatSync(t);c(`LSTAT is symlink? ${o.isSymbolicLink()}, is directory? ${o.isDirectory()}`)}};var X=m(require("fs")),ze=m(require("path")),$=m(require("simple-git")),Qe=async(r,e)=>{let n=ze.default.resolve(e.localPath);X.default.existsSync(n)||X.default.mkdirSync(n,{recursive:!0}),X.default.readdirSync(n).length===0&&e.url&&await(0,$.default)().clone(e.url,n);let t=(0,$.default)(n,{binary:e.binary});if(!await t.checkIsRepo($.CheckRepoActions.IS_REPO_ROOT))throw Error(`${n} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let p=!1,f=await t.branchLocal();for(var s of f.all)if(s===e.branch){p=!0;break}let l=e.branch??"",g=e.startPoint??"";p?(f.current!==e.branch&&await t.checkout(l),await t.reset($.ResetMode.HARD,[g])):await t.checkoutBranch(l,g)}};var pe={"git-repo-prepare":Qe,cmd:Be,"set-var":Je,output:Ne,symlink:qe,"fs-copy":Me,"fs-del":De,"fs-mkdir":Re,"env-var":We,"sub-tasks":Ce,"content-replace":Fe};var _=(r,e,n)=>{let t={},o=B.default.resolve(e.config);try{t=Y(o)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),n.help()}let s,p="info",f=he;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(p="debug"),i.logLevel&&N.includes(i.logLevel)&&(p=i.logLevel),i.replaceRegex&&(f=i.replaceRegex)}if(e.logLevel&&N.includes(e.logLevel)&&(p=e.logLevel),p==="debug"?(s=`${A},${R},${W}`,s=`${s},simple-git,simple-git:*`):p==="info"&&(s=`${A},${R}`),s&&Ze.default.enable(s),c("CLI Options",e),typeof f!="string")throw new Error(`replaceRegex '${f}'  must be a string`);if(f.length<1)throw new Error(`replaceRegex '${f}' cannot be empty`);if(f.indexOf("(")<0||f.indexOf(")")<0)throw new Error(`replaceRegex '${f}' must contain regex group express '(' and ')'`);let l=B.default.resolve(process.cwd()),g={originCwd:r,baseCwd:l,replaceRegex:new RegExp(f),vars:{__env:{cwd_startup:r,cwd_base:l}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),ne(e.extraArgs,xe,e.camelKeys,(i,y)=>{D(g,i,y,!1)}),c("Setting up the environment variables from the additional arguments"),ne(e.extraArgs,Te,e.camelKeys,(i,y)=>{I(g,i,y,!1)})),v(""),v(`[${t.name}] Start task processing`);let d=(i,y)=>y!=null?i.id!==void 0?`[${y}]${i.id}/${i.type}`:`[${y}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let u=0;u<i.length;u++){let a=i[u];if(a.id!==void 0&&a.id!==null){if(typeof a.id!="string")throw new Error("The task id must be a 'string' type");if(a.id.length<1)throw new Error("The task id cannot be empty");for(let x=u+1;x<i.length;x++){let h=i[x];if(h.id!==void 0&&h.id===a.id)throw new Error(`The task id '${a.id}' must be unique`)}}if(!a.type||!(a.type in pe))throw new Error(`Found the invalid task type '${a.type}'`);if(a.__compare__elements=[],a.id&&(a.id=a.id.trim(),a.__compare__elements.push(a.id.trim())),a.tags){let x=h=>{c(`Ignoring invalid tags '${h}'`)};if(typeof a.tags=="string")a.tags.length>0?(a.tags=a.tags.trim(),a.__compare__elements.push(a.tags)):x(a.tags);else if(Array.isArray(a.tags)){a.tags=a.tags.map(h=>h.trim());for(let h of a.tags)typeof h=="string"&&h.length>0?a.__compare__elements.push(h):x(h)}else x(a.tags)}}if(e.exclude&&e.exclude.length>0){let u=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${u}`),i=i.filter((a,x,h)=>{if(te(u,a.__compare__elements)===!1)return a})}if(e.excludeCta&&e.excludeCta.length>0){let u=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${u}`),i=i.filter((a,x,h)=>{if(re(u,a.__compare__elements)===!1)return a})}let y=e.include&&e.include.length>0,E=e.includeCta&&e.includeCta.length>0;if(y||E){let u=e.include,a=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${u} / --include-cta=${a}`),i=i.filter((x,h,fe)=>{if(y&&te(u,x.__compare__elements)===!0||E&&re(a,x.__compare__elements)===!0)return x})}v(`Tasks : ${i.map((u,a)=>d(u,a))}`);let tt=i.length??0;for(let u=0;u<tt;u++){let a=i[u];await we(g,a);let x=d(a,u);if(a.enabled===!1){v(`
### Skip the task without execution => ${x}`);continue}else v(`
### Task : ${x}`);a.comment&&v(a.comment);let h=!1;if(a.cwd){let ge=B.default.resolve(a.cwd);v(`Changing the current working directory => ${ge}`),h=!0,process.chdir(ge)}let fe=pe[a.type];await fe(g,a),e.cwdModeIsContinue||(h&&v(`Restoring the current working directory => ${l}`),process.chdir(l))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(l),v(`[${t.name}] Tasks done
`)})};var vt=et.default.resolve(process.cwd()),Ye=U();_(vt,Ye.opt,Ye.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map