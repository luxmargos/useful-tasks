#!/usr/bin/env node
"use strict";var ke=Object.create;var E=Object.defineProperty;var ve=Object.getOwnPropertyDescriptor;var be=Object.getOwnPropertyNames;var we=Object.getPrototypeOf,Ce=Object.prototype.hasOwnProperty;var _e=(s,e)=>{for(var r in e)E(s,r,{get:e[r],enumerable:!0})},q=(s,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of be(e))!Ce.call(s,n)&&n!==r&&E(s,n,{get:()=>e[n],enumerable:!(t=ve(e,n))||t.enumerable});return s};var h=(s,e,r)=>(r=s!=null?ke(we(s)):{},q(e||!s||!s.__esModule?E(r,"default",{value:s,enumerable:!0}):r,s)),Se=s=>q(E({},"__esModule",{value:!0}),s);var Fe={};_e(Fe,{usefulTasks:()=>_});module.exports=Se(Fe);var Te=h(require("path"));var B=require("commander"),Y=h(require("path")),$e="useful_tasks.json",W=!0,M="restore",D="keep",Ee=[M,D],Re={cwdMode:`Choose between ${Ee.map(s=>`'${s}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${M}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${D}' mode, the CWD will remain unchanged.`},A=s=>{let e=new B.Command;e.name("useful-tasks").version("0.1.22").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",$e).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',W).option("--cwd-mode <string>",Re.cwdMode,M).allowUnknownOption(!0),s!==void 0?e.parse(s,{from:"user"}):e.parse();let t=e.opts();if(t.include=R(t.include),t.includeCta=R(t.includeCta),t.exclude=R(t.exclude),t.excludeCta=R(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===D,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let n=t.camelKeys;n=n.trim().toLowerCase(),n==="false"||n==="0"||n==="no"?t.camelKeys=!1:n==="true"||n==="1"||n==="yes"?t.camelKeys=!0:t.camelKeys=W}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(Y.default.resolve(t.cwd)),{opt:t,program:e}},R=(s,e=!0)=>{if(!s)return[];if(typeof s=="string"){let r=[];return s.split(",").forEach(n=>{let i=n.trim();e?i.length>0&&r.push(i):r.push(i)}),r}return[]};var I=h(require("path"));var P=h(require("fs")),G=h(require("path")),z=h(require("json5")),L=s=>{if(!P.default.existsSync(s))throw new Error(`ERROR: The Path '${s}' does not exists!`);let e=P.default.readFileSync(s,{encoding:"utf-8"});return z.default.parse(e)},K=s=>{let e=L(s);if(e.extends){let r=G.default.dirname(s),t=G.default.resolve(r,e.extends);e=Object.assign({},e,K(t))}return e},j=(s,e)=>{if(!e)return s;let r="",t=s.split("-");for(let n=0;n<t.length;n++){let i=t[n];n===0?r=i:(i.length>0&&(i=`${i[0].toUpperCase()}${i.substring(1)}`),r=`${r}${i}`)}return r},U=(s,e)=>{if(s.length<1)return!1;for(let r of s)for(let t of e)if(r===t)return!0;return!1},N=(s,e)=>{if(s.length<1)return!1;for(let r of s){let t=!1;for(let n of e)if(n===r){t=!0;break}if(!t)return!1}return!0};var H=h(require("debug"));var T="useful-tasks",Z="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",Q="--var-",ee="--env-";var te=h(require("debug"));var C=(0,te.default)(T),re=async(s,e)=>{let r=e;for(let t of Object.keys(r))if(typeof t=="string"&&!(t==="id"||t==="tags")&&r[t]!==void 0&&typeof r[t]=="string"){let n=r[t];for(;;){let i=s.replaceRegex.exec(n);if(i==null)break;let l=i[0],c=i[1],p=s.vars;if(c.length>0){let a=c.split(".");for(let y=0;y<a.length;y++){let S=a[y];if(p.hasOwnProperty(S))p=p[S];else throw new Error(`The value of ${c} could not be found!`)}}let m=n.substring(0,i.index),w=`${p}`,$=n.substring(i.index+l.length);n=`${m}${w}${$}`,C(`Updated value ${n}`)}r[t]=n}},J=(s,e,r,t)=>{let n,i=!1;for(let l of s){if(l.trim()==="--"){C("Stop parsing by '--'");break}if(i&&n){let p=l.startsWith("-")?"":l;t(n,p),n=void 0,i=!1}else if(l.indexOf(e)>=0){let m=l.indexOf("=");if(m>=0){let w=j(l.substring(e.length,m),r),$=l.substring(m+1);t(w,$)}else n=j(l.substring(e.length),r),i=!0}}},F=(s,e,r)=>{C(`Sets the variable ${e}=${r}`),s.vars[e]=r},O=(s,e,r)=>{var t=typeof r;t!=="string"&&t!=="number"&&t!=="boolean"?C(`Ignoring the invalid typed(${t}) environment variable ${e}=${r}`):String(r).length<1?C(`Ignoring the invalid environment variable ${e}=${r}`):(C(`Sets the environment variable ${e}=${r}`),process.env[e]=String(r))};var se=h(require("string-argv"));var ne=h(require("debug"));var qe=(0,ne.default)(T),oe=async(s,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let r=(0,se.default)(e.args),t=A(r);_(s.originCwd,t.opt,t.program)};var f=h(require("fs")),ae=require("child_process"),x=h(require("path")),v=require("simple-git"),b=require("fs-extra"),ie=h(require("debug"));var ce=h(require("json5"));var k=(0,ie.default)(T),le=async(s,e)=>{let r=x.default.resolve(e.localPath);f.default.existsSync(r)||f.default.mkdirSync(r,{recursive:!0}),f.default.readdirSync(r).length===0&&e.url&&await(0,v.simpleGit)().clone(e.url,r);let t=(0,v.simpleGit)(r,{binary:e.binary});if(!await t.checkIsRepo(v.CheckRepoActions.IS_REPO_ROOT))throw Error(`${r} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let l=!1,c=await t.branchLocal();for(var i of c.all)if(i===e.branch){l=!0;break}let p=e.branch??"",m=e.startPoint??"";l?(c.current!==e.branch&&await t.checkout(p),await t.reset(v.ResetMode.HARD,[m])):await t.checkoutBranch(p,m)}},pe=async(s,e)=>{let r=x.default.resolve(e.target),t=x.default.resolve(e.path);if(f.default.existsSync(t)){let n=f.default.lstatSync(t);k(`LSTAT is symlink? ${n.isSymbolicLink()}, is directory? ${n.isDirectory()}`),e.forced&&(n.isSymbolicLink()||n.isFile()?(k(`Unlink ${t}`),f.default.unlinkSync(t)):n.isDirectory()&&(k(`Remove directory '${t}'`),(0,b.removeSync)(t)))}if(f.default.existsSync(t))k(`Could not create symbolic link cause '${t}' already exists`);else{k(`Create symbolic link ${r} => ${t}`),f.default.symlinkSync(r,t,e.linkType);let n=f.default.lstatSync(t);k(`LSTAT is symlink? ${n.isSymbolicLink()}, is directory? ${n.isDirectory()}`)}},de=async(s,e)=>{k(`Start execution... ${e.cmd}`),(0,ae.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},fe=async(s,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=x.default.resolve(r);if(!f.default.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);r=f.default.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(r=ce.default.parse(r))}F(s,e.key,r)},ue=async(s,e)=>{let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=x.default.resolve(r);r=L(t)}if(typeof r!="object")throw new Error('The content of the "var" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(r).forEach(t=>{O(s,t,r[t])})},ge=async(s,e)=>{let r=e.text??"",t=(e.target??"c").trim(),n=e.path;if(t==="c"||t==="console")console.log(r);else{if(!n)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let i=x.default.resolve(n),l=x.default.dirname(i);if(f.default.existsSync(l)||(0,b.mkdirpSync)(l),t=="fa"||t=="file-append"){let c,p;try{p=f.default.openSync(i,"a"),f.default.appendFileSync(p,r,"utf8")}catch(m){c=m}finally{p!==void 0&&f.default.closeSync(p)}if(c)throw c}else f.default.writeFileSync(i,r)}},me=async(s,e)=>{let r=e?.options?.conflict!=="skip";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(r=e.options.overwrite),(0,b.copySync)(e.src,e.dest,{overwrite:r})},ye=async(s,e)=>{(0,b.removeSync)(e.path)};var X={"git-repo-prepare":le,symlink:pe,cmd:de,"set-var":fe,output:ge,"fs-copy":me,"fs-del":ye,"env-var":ue,"sub-tasks":oe};var _=(s,e,r)=>{let t={},n=I.default.resolve(e.config);try{t=K(n)}catch(a){a instanceof Error?console.log(a.message):console.log(a),console.log(""),r.help()}let i="",l=Z;if(t.env&&typeof t.env=="object"){let a=t.env;a.verbose&&(i=`${T}, ${T}:*`),a.verboseGit&&(i=`${i},simple-git,simple-git:*`),a.replaceRegex&&(l=a.replaceRegex)}if(typeof l!="string")throw new Error(`replaceRegex '${l}'  must be a string`);if(l.length<1)throw new Error(`replaceRegex '${l}' cannot be empty`);if(l.indexOf("(")<0||l.indexOf(")")<0)throw new Error(`replaceRegex '${l}' must contain regex group express '(' and ')'`);i&&H.default.enable(i);let c=(0,H.default)(T),p=I.default.resolve(process.cwd()),m={originCwd:s,baseCwd:p,replaceRegex:new RegExp(l),vars:{__env:{cwd_startup:s,cwd_base:p}}};e.extraArgs&&(c("Setting up the variables from the additional arguments"),J(e.extraArgs,Q,e.camelKeys,(a,y)=>{F(m,a,y)}),c("Setting up the environment variables from the additional arguments"),J(e.extraArgs,ee,e.camelKeys,(a,y)=>{O(m,a,y)})),c(""),c(`[${t.name}] Start task processing`);let w=(a,y)=>y!=null?a.id!==void 0?`[${y}]${a.id}/${a.type}`:`[${y}]${a.type}`:a.id!==void 0?`${a.id}/${a.type}`:`${a.type}`;(async()=>{let a=t.tasks??[];for(let d=0;d<a.length;d++){let o=a[d];if(o.id!==void 0&&o.id!==null){if(typeof o.id!="string")throw new Error("The task id must be a 'string' type");if(o.id.length<1)throw new Error("The task id cannot be empty");for(let u=d+1;u<a.length;u++){let g=a[u];if(g.id!==void 0&&g.id===o.id)throw new Error(`The task id '${o.id}' must be unique`)}}if(!o.type||!(o.type in X))throw new Error(`Found the invalid task type '${o.type}'`);if(o.__compare__elements=[],o.id&&(o.id=o.id.trim(),o.__compare__elements.push(o.id.trim())),o.tags){let u=g=>{c(`Ignoring invalid tags '${g}'`)};if(typeof o.tags=="string")o.tags.length>0?(o.tags=o.tags.trim(),o.__compare__elements.push(o.tags)):u(o.tags);else if(Array.isArray(o.tags)){o.tags=o.tags.map(g=>g.trim());for(let g of o.tags)typeof g=="string"&&g.length>0?o.__compare__elements.push(g):u(g)}else u(o.tags)}}if(e.exclude&&e.exclude.length>0){let d=e.exclude;c(`Excluding tasks by specified IDs or Tags : --exclude=${d}`),a=a.filter((o,u,g)=>{if(U(d,o.__compare__elements)===!1)return o})}if(e.excludeCta&&e.excludeCta.length>0){let d=e.excludeCta;c(`Excluding tasks by specified IDs or Tags : --exclude-cta=${d}`),a=a.filter((o,u,g)=>{if(N(d,o.__compare__elements)===!1)return o})}let y=e.include&&e.include.length>0,S=e.includeCta&&e.includeCta.length>0;if(y||S){let d=e.include,o=e.includeCta;c(`Including tasks by specified IDs or Tags : --include=${d} / --include-cta=${o}`),a=a.filter((u,g,V)=>{if(y&&U(d,u.__compare__elements)===!0||S&&N(o,u.__compare__elements)===!0)return u})}c(`Tasks : ${a.map((d,o)=>w(d,o))}`);let xe=a.length??0;for(let d=0;d<xe;d++){let o=a[d];re(m,o);let u=w(o,d);if(o.enabled===!1){c(`
### Skip the task without execution => ${u}`);continue}else c(`
### Task : ${u}`);if(o.comment&&c(o.comment),o.cwd){let V=I.default.resolve(o.cwd);c(`Changing the current working directory => ${V}`),process.chdir(V)}let g=X[o.type];await g(m,o),e.cwdModeIsContinue||process.chdir(p)}})().then(()=>{}).catch(a=>{throw a}).finally(()=>{process.chdir(p),c(`[${t.name}] Tasks completed`),c("")})};var Ae=Te.default.resolve(process.cwd()),he=A();_(Ae,he.opt,he.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map