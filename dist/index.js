#!/usr/bin/env node
"use strict";var we=Object.create;var E=Object.defineProperty;var _e=Object.getOwnPropertyDescriptor;var Ce=Object.getOwnPropertyNames;var $e=Object.getPrototypeOf,Se=Object.prototype.hasOwnProperty;var Ee=(n,e)=>{for(var r in e)E(n,r,{get:e[r],enumerable:!0})},Y=(n,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Ce(e))!Se.call(n,s)&&s!==r&&E(n,s,{get:()=>e[s],enumerable:!(t=_e(e,s))||t.enumerable});return n};var x=(n,e,r)=>(r=n!=null?we($e(n)):{},Y(e||!n||!n.__esModule?E(r,"default",{value:n,enumerable:!0}):r,n)),Le=n=>Y(E({},"__esModule",{value:!0}),n);var Ge={};Ee(Ge,{usefulTasks:()=>_});module.exports=Le(Ge);var ve=x(require("path"));var Z=require("commander"),Q=x(require("path")),Re="useful_tasks.json",z=!0,G="restore",D="keep",Ae=[G,D],ee="info",Fe="debug",Oe="none",R=[Oe,ee,Fe],Ie={cwdMode:`Choose between ${Ae.map(n=>`'${n}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${G}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${D}' mode, the CWD will remain unchanged.`},A=n=>{let e=new Z.Command;e.name("useful-tasks").version("0.1.24").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",Re).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',z).option("--cwd-mode <string>",Ie.cwdMode,G).option("--log-level <string>",`Specify the logging level as ${R.join(",")}. This parameter takes higher priority than the 'json' configuration.`,ee).allowUnknownOption(!0),n!==void 0?e.parse(n,{from:"user"}):e.parse();let t=e.opts();if(t.include=L(t.include),t.includeCta=L(t.includeCta),t.exclude=L(t.exclude),t.excludeCta=L(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===D,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let s=t.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?t.camelKeys=!1:s==="true"||s==="1"||s==="yes"?t.camelKeys=!0:t.camelKeys=z}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(Q.default.resolve(t.cwd)),{opt:t,program:e}},L=(n,e=!0)=>{if(!n)return[];if(typeof n=="string"){let r=[];return n.split(",").forEach(s=>{let a=s.trim();e?a.length>0&&r.push(a):r.push(a)}),r}return[]};var V=x(require("path"));var M=x(require("fs")),P=x(require("path")),te=x(require("json5")),U=n=>{if(!M.default.existsSync(n))throw new Error(`ERROR: The Path '${n}' does not exists!`);let e=M.default.readFileSync(n,{encoding:"utf-8"});return te.default.parse(e)},j=n=>{let e=U(n);if(e.extends){let r=P.default.dirname(n),t=P.default.resolve(r,e.extends);e=Object.assign({},e,j(t))}return e},N=(n,e)=>{if(!e)return n;let r="",t=n.split("-");for(let s=0;s<t.length;s++){let a=t[s];s===0?r=a:(a.length>0&&(a=`${a[0].toUpperCase()}${a.substring(1)}`),r=`${r}${a}`)}return r},K=(n,e)=>{if(n.length<1)return!1;for(let r of n)for(let t of e)if(r===t)return!0;return!1},B=(n,e)=>{if(n.length<1)return!1;for(let r of n){let t=!1;for(let s of e)if(s===r){t=!0;break}if(!t)return!1}return!0};var Te=x(require("debug"));var re="useful-tasks",F=`${re}:debug`,$=`${re}:info`,ne="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",se="--var-",oe="--env-";var J=x(require("debug"));var l=(0,J.default)(F),T=(0,J.default)($);var ie=async(n,e)=>{let r=e;for(let t of Object.keys(r))if(typeof t=="string"&&!(t==="id"||t==="tags")&&r[t]!==void 0&&typeof r[t]=="string"){let s=r[t];for(;;){let a=n.replaceRegex.exec(s);if(a==null)break;let c=a[0],p=a[1],f=n.vars;if(p.length>0){let i=p.split(".");for(let h=0;h<i.length;h++){let C=i[h];if(f.hasOwnProperty(C))f=f[C];else throw new Error(`The value of ${p} could not be found!`)}}let y=s.substring(0,a.index),w=`${f}`,S=s.substring(a.index+c.length);s=`${y}${w}${S}`,l(`Updated value ${s}`)}r[t]=s}},X=(n,e,r,t)=>{let s,a=!1;for(let c of n){if(c.trim()==="--"){l("Stop parsing by '--'");break}if(a&&s){let f=c.startsWith("-")?"":c;t(s,f),s=void 0,a=!1}else if(c.indexOf(e)>=0){let y=c.indexOf("=");if(y>=0){let w=N(c.substring(e.length,y),r),S=c.substring(y+1);t(w,S)}else s=N(c.substring(e.length),r),a=!0}}},O=(n,e,r)=>{l(`Sets the variable ${e}=${r}`),n.vars[e]=r},I=(n,e,r)=>{var t=typeof r;t!=="string"&&t!=="number"&&t!=="boolean"?l(`Ignoring the invalid typed(${t}) environment variable ${e}=${r}`):String(r).length<1?l(`Ignoring the invalid environment variable ${e}=${r}`):(l(`Sets the environment variable ${e}=${r}`),process.env[e]=String(r))};var ae=x(require("string-argv"));var le=async(n,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let r=(0,ae.default)(e.args),t=A(r);_(n.originCwd,t.opt,t.program)};var u=x(require("fs")),ce=require("child_process"),k=x(require("path")),v=require("simple-git"),b=require("fs-extra");var pe=x(require("json5"));var fe=async(n,e)=>{let r=k.default.resolve(e.localPath);u.default.existsSync(r)||u.default.mkdirSync(r,{recursive:!0}),u.default.readdirSync(r).length===0&&e.url&&await(0,v.simpleGit)().clone(e.url,r);let t=(0,v.simpleGit)(r,{binary:e.binary});if(!await t.checkIsRepo(v.CheckRepoActions.IS_REPO_ROOT))throw Error(`${r} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let c=!1,p=await t.branchLocal();for(var a of p.all)if(a===e.branch){c=!0;break}let f=e.branch??"",y=e.startPoint??"";c?(p.current!==e.branch&&await t.checkout(f),await t.reset(v.ResetMode.HARD,[y])):await t.checkoutBranch(f,y)}},de=async(n,e)=>{let r=k.default.resolve(e.target),t=k.default.resolve(e.path);if(u.default.existsSync(t)){let s=u.default.lstatSync(t);l(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(l(`Unlink ${t}`),u.default.unlinkSync(t)):s.isDirectory()&&(l(`Remove directory '${t}'`),(0,b.removeSync)(t)))}if(u.default.existsSync(t))l(`Could not create symbolic link cause '${t}' already exists`);else{l(`Create symbolic link ${r} => ${t}`),u.default.symlinkSync(r,t,e.linkType);let s=u.default.lstatSync(t);l(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}},ge=async(n,e)=>{l(`Start execution... ${e.cmd}`),(0,ce.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},ue=async(n,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=k.default.resolve(r);if(!u.default.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);r=u.default.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(r=pe.default.parse(r))}O(n,e.key,r)},me=async(n,e)=>{let r=e.var;if(e.varType==="file"){if(typeof r!="string")throw new Error(`The "var" must contain path of a file with "varType":"${e.varType}"`);let t=k.default.resolve(r);r=U(t)}if(typeof r!="object")throw new Error('The content of the "var" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(r).forEach(t=>{I(n,t,r[t])})},ye=async(n,e)=>{let r=e.text??"",t=(e.target??"c").trim(),s=e.path;if(t==="c"||t==="console")console.log(r);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let a=k.default.resolve(s),c=k.default.dirname(a);if(u.default.existsSync(c)||(0,b.mkdirpSync)(c),t=="fa"||t=="file-append"){let p,f;try{f=u.default.openSync(a,"a"),u.default.appendFileSync(f,r,"utf8")}catch(y){p=y}finally{f!==void 0&&u.default.closeSync(f)}if(p)throw p}else u.default.writeFileSync(a,r)}},he=async(n,e)=>{let r=e?.options?.conflict!=="skip";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(r=e.options.overwrite),(0,b.copySync)(e.src,e.dest,{overwrite:r})},xe=async(n,e)=>{(0,b.removeSync)(e.path)};var H={"git-repo-prepare":fe,symlink:de,cmd:ge,"set-var":ue,output:ye,"fs-copy":he,"fs-del":xe,"env-var":me,"sub-tasks":le};var _=(n,e,r)=>{let t={},s=V.default.resolve(e.config);try{t=j(s)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),r.help()}let a,c="info",p=ne;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(c="debug"),i.logLevel&&R.includes(i.logLevel)&&(c=i.logLevel),i.replaceRegex&&(p=i.replaceRegex)}if(e.logLevel&&R.includes(e.logLevel)&&(c=e.logLevel),c==="debug"?(a=`${$},${F}`,a=`${a},simple-git,simple-git:*`):c==="info"&&(a=`${$}`),a&&Te.default.enable(a),l("CLI Options",e),typeof p!="string")throw new Error(`replaceRegex '${p}'  must be a string`);if(p.length<1)throw new Error(`replaceRegex '${p}' cannot be empty`);if(p.indexOf("(")<0||p.indexOf(")")<0)throw new Error(`replaceRegex '${p}' must contain regex group express '(' and ')'`);let f=V.default.resolve(process.cwd()),y={originCwd:n,baseCwd:f,replaceRegex:new RegExp(p),vars:{__env:{cwd_startup:n,cwd_base:f}}};e.extraArgs&&(l("Setting up the variables from the additional arguments"),X(e.extraArgs,se,e.camelKeys,(i,h)=>{O(y,i,h)}),l("Setting up the environment variables from the additional arguments"),X(e.extraArgs,oe,e.camelKeys,(i,h)=>{I(y,i,h)})),T(""),T(`[${t.name}] Start task processing`);let w=(i,h)=>h!=null?i.id!==void 0?`[${h}]${i.id}/${i.type}`:`[${h}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let d=0;d<i.length;d++){let o=i[d];if(o.id!==void 0&&o.id!==null){if(typeof o.id!="string")throw new Error("The task id must be a 'string' type");if(o.id.length<1)throw new Error("The task id cannot be empty");for(let m=d+1;m<i.length;m++){let g=i[m];if(g.id!==void 0&&g.id===o.id)throw new Error(`The task id '${o.id}' must be unique`)}}if(!o.type||!(o.type in H))throw new Error(`Found the invalid task type '${o.type}'`);if(o.__compare__elements=[],o.id&&(o.id=o.id.trim(),o.__compare__elements.push(o.id.trim())),o.tags){let m=g=>{l(`Ignoring invalid tags '${g}'`)};if(typeof o.tags=="string")o.tags.length>0?(o.tags=o.tags.trim(),o.__compare__elements.push(o.tags)):m(o.tags);else if(Array.isArray(o.tags)){o.tags=o.tags.map(g=>g.trim());for(let g of o.tags)typeof g=="string"&&g.length>0?o.__compare__elements.push(g):m(g)}else m(o.tags)}}if(e.exclude&&e.exclude.length>0){let d=e.exclude;l(`Excluding tasks by specified IDs or Tags : --exclude=${d}`),i=i.filter((o,m,g)=>{if(K(d,o.__compare__elements)===!1)return o})}if(e.excludeCta&&e.excludeCta.length>0){let d=e.excludeCta;l(`Excluding tasks by specified IDs or Tags : --exclude-cta=${d}`),i=i.filter((o,m,g)=>{if(B(d,o.__compare__elements)===!1)return o})}let h=e.include&&e.include.length>0,C=e.includeCta&&e.includeCta.length>0;if(h||C){let d=e.include,o=e.includeCta;l(`Including tasks by specified IDs or Tags : --include=${d} / --include-cta=${o}`),i=i.filter((m,g,q)=>{if(h&&K(d,m.__compare__elements)===!0||C&&B(o,m.__compare__elements)===!0)return m})}T(`Tasks : ${i.map((d,o)=>w(d,o))}`);let be=i.length??0;for(let d=0;d<be;d++){let o=i[d];ie(y,o);let m=w(o,d);if(o.enabled===!1){T(`
### Skip the task without execution => ${m}`);continue}else T(`
### Task : ${m}`);o.comment&&T(o.comment);let g=!1;if(o.cwd){let W=V.default.resolve(o.cwd);T(`Changing the current working directory => ${W}`),g=!0,process.chdir(W)}let q=H[o.type];await q(y,o),e.cwdModeIsContinue||(g&&T(`Restoring the current working directory => ${f}`),process.chdir(f))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(f),l(`[${t.name}] Tasks completed`),l("")})};var Ve=ve.default.resolve(process.cwd()),ke=A();_(Ve,ke.opt,ke.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map