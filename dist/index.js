#!/usr/bin/env node
"use strict";var Se=Object.create;var R=Object.defineProperty;var $e=Object.getOwnPropertyDescriptor;var Ee=Object.getOwnPropertyNames;var Re=Object.getPrototypeOf,Ae=Object.prototype.hasOwnProperty;var Le=(r,e)=>{for(var n in e)R(r,n,{get:e[n],enumerable:!0})},ee=(r,e,n,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Ee(e))!Ae.call(r,s)&&s!==n&&R(r,s,{get:()=>e[s],enumerable:!(t=$e(e,s))||t.enumerable});return r};var x=(r,e,n)=>(n=r!=null?Se(Re(r)):{},ee(e||!r||!r.__esModule?R(n,"default",{value:r,enumerable:!0}):n,r)),Fe=r=>ee(R({},"__esModule",{value:!0}),r);var je={};Le(je,{usefulTasks:()=>S});module.exports=Fe(je);var Ce=x(require("path"));var ne=require("commander"),re=x(require("path")),Oe="useful_tasks.json",te=!0,M="restore",P="keep",De=[M,P],Ie="info",Ve="debug",Ge="none",L=[Ge,Ie,Ve],Me={cwdMode:`Choose between ${De.map(r=>`'${r}'`).join(" or ")}. If you use 'cwd' property in a specific task, consider using this parameter. This parameter determines the behavior of the current working directory (CWD) when each task ends. In '${M}' mode, the CWD will be restored to its original state (or the one specified at --cwd) when each task ends, while in '${P}' mode, the CWD will remain unchanged.`},F=r=>{let e=new ne.Command;e.name("useful-tasks").version("0.1.25").option("--cwd <string>","Change working directory").option("-c, --config <string>","A path of json configuraion",Oe).option("-i, --include <items>","Include tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-a, --include-cta <items>","Include tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-e, --exclude <items>","Exclude tasks that contain at least one of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("-x, --exclude-cta <items>","Exclude tasks that contain all of the specified parameters. Specify the IDs or tags separated by commas. For example: my_task_01, my_task_02").option("--camel-keys <boolean>",'Specify whether to use camel case for the key of the variable. If the value is true, the paramter "--var-my-key" will be converted to "myKey" otherwise it will be "my-key"',te).option("--cwd-mode <string>",Me.cwdMode,M).option("--log-level <string>",`Specify the logging level as ${L.join(",")}. This parameter takes higher priority than the 'json' configuration.`).allowUnknownOption(!0),r!==void 0?e.parse(r,{from:"user"}):e.parse();let t=e.opts();if(t.include=A(t.include),t.includeCta=A(t.includeCta),t.exclude=A(t.exclude),t.excludeCta=A(t.excludeCta),t.cwdModeIsContinue=t.cwdMode===P,t.camelKeys!==void 0&&typeof t.camelKeys=="string"){let s=t.camelKeys;s=s.trim().toLowerCase(),s==="false"||s==="0"||s==="no"?t.camelKeys=!1:s==="true"||s==="1"||s==="yes"?t.camelKeys=!0:t.camelKeys=te}return t.extraArgs=[...e.args??[]],t.cwd&&process.chdir(re.default.resolve(t.cwd)),{opt:t,program:e}},A=(r,e=!0)=>{if(!r)return[];if(typeof r=="string"){let n=[];return r.split(",").forEach(s=>{let a=s.trim();e?a.length>0&&n.push(a):n.push(a)}),n}return[]};var G=x(require("path"));var j=x(require("fs")),N=x(require("path")),se=x(require("json5")),U=r=>{if(!j.default.existsSync(r))throw new Error(`ERROR: The Path '${r}' does not exists!`);let e=j.default.readFileSync(r,{encoding:"utf-8"});return se.default.parse(e)},K=r=>{let e=U(r);if(e.extends){let n=N.default.dirname(r),t=N.default.resolve(n,e.extends);e=Object.assign({},e,K(t))}return e},B=(r,e)=>{if(!e)return r;let n="",t=r.split("-");for(let s=0;s<t.length;s++){let a=t[s];s===0?n=a:(a.length>0&&(a=`${a[0].toUpperCase()}${a.substring(1)}`),n=`${n}${a}`)}return n},J=(r,e)=>{if(r.length<1)return!1;for(let n of r)for(let t of e)if(n===t)return!0;return!1},X=(r,e)=>{if(r.length<1)return!1;for(let n of r){let t=!1;for(let s of e)if(s===n){t=!0;break}if(!t)return!1}return!0};var we=x(require("debug"));var oe="useful-tasks",O=`${oe}:debug`,E=`${oe}:info`,ie="\\$\\{([a-zA-Z0-9\\.\\-_]*)\\}",ae="--var-",le="--env-";var q=x(require("debug"));var f=(0,q.default)(O),v=(0,q.default)(E);var ce=async(r,e)=>{let n=e;for(let t of Object.keys(n))if(typeof t=="string"&&!(t==="id"||t==="tags")&&n[t]!==void 0&&typeof n[t]=="string"){let s=n[t];for(;;){let a=r.replaceRegex.exec(s);if(a==null)break;let l=a[0],c=a[1],p=r.vars;if(c.length>0){let i=c.split(".");for(let m=0;m<i.length;m++){let $=i[m];if(p.hasOwnProperty($))p=p[$];else throw new Error(`The value of ${c} could not be found!`)}}let u=s.substring(0,a.index),k=`${p}`,w=s.substring(a.index+l.length);s=`${u}${k}${w}`,f(`Variable applied '${t}'=>'${s}'`)}n[t]=s}},H=(r,e,n,t)=>{let s,a=!1;for(let l of r){if(l.trim()==="--"){f("Stop parsing by '--'");break}if(a&&s){let p=l.startsWith("-")?"":l;t(s,p),s=void 0,a=!1}else if(l.indexOf(e)>=0){let u=l.indexOf("=");if(u>=0){let k=B(l.substring(e.length,u),n),w=l.substring(u+1);t(k,w)}else s=B(l.substring(e.length),n),a=!0}}},D=(r,e,n)=>{f(`Sets the variable ${e}=${n}`),r.vars[e]=n},I=(r,e,n)=>{var t=typeof n;t!=="string"&&t!=="number"&&t!=="boolean"?f(`Ignoring the invalid typed(${t}) environment variable ${e}=${n}`):String(n).length<1?f(`Ignoring the invalid environment variable ${e}=${n}`):(f(`Sets the environment variable ${e}=${n}`),process.env[e]=String(n))};var pe=x(require("string-argv"));var fe=async(r,e)=>{if(!e.args||typeof e.args!="string")throw new Error("Found missing or invalid property 'args' that is required");let n=(0,pe.default)(e.args),t=F(n);S(r.originCwd,t.opt,t.program)};var g=x(require("fs")),ge=require("child_process"),T=x(require("path")),C=require("simple-git"),_=require("fs-extra");var de=x(require("json5"));var b=require("glob"),ue=async(r,e)=>{let n=T.default.resolve(e.localPath);g.default.existsSync(n)||g.default.mkdirSync(n,{recursive:!0}),g.default.readdirSync(n).length===0&&e.url&&await(0,C.simpleGit)().clone(e.url,n);let t=(0,C.simpleGit)(n,{binary:e.binary});if(!await t.checkIsRepo(C.CheckRepoActions.IS_REPO_ROOT))throw Error(`${n} is not a git repository!!!`);if(e.updateSubmodules&&(await t.submoduleInit(),await t.submoduleUpdate()),await t.fetch(),e.branch){let l=!1,c=await t.branchLocal();for(var a of c.all)if(a===e.branch){l=!0;break}let p=e.branch??"",u=e.startPoint??"";l?(c.current!==e.branch&&await t.checkout(p),await t.reset(C.ResetMode.HARD,[u])):await t.checkoutBranch(p,u)}},me=async(r,e)=>{let n=T.default.resolve(e.target),t=T.default.resolve(e.path);if(g.default.existsSync(t)){let s=g.default.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`),e.forced&&(s.isSymbolicLink()||s.isFile()?(f(`Unlink ${t}`),g.default.unlinkSync(t)):s.isDirectory()&&(f(`Remove directory '${t}'`),(0,_.removeSync)(t)))}if(g.default.existsSync(t))f(`Could not create symbolic link cause '${t}' already exists`);else{f(`Create symbolic link ${n} => ${t}`),g.default.symlinkSync(n,t,e.linkType);let s=g.default.lstatSync(t);f(`LSTAT is symlink? ${s.isSymbolicLink()}, is directory? ${s.isDirectory()}`)}},ye=async(r,e)=>{f(`Start execution... ${e.cmd}`),(0,ge.execSync)(e.cmd,{shell:e.shell,env:process.env,stdio:[process.stdin,process.stdout,process.stderr],encoding:"utf-8"})},he=async(r,e)=>{if(e.key===void 0||!e.key||typeof e.key!="string"||e.key.length<1)throw new Error(`Invalid key ${e.key}. It must be a string.`);let n=e.value;if(n==null&&e.var&&(n=e.var),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.default.resolve(n);if(!g.default.existsSync(t))throw new Error(`File "${t}" does not exist to use as a variable`);n=g.default.readFileSync(t,{encoding:"utf8"}),e.fileFormat==="json"&&(n=de.default.parse(n))}D(r,e.key,n)},xe=async(r,e)=>{let n=e.value;if(n==null&&e.var&&(n=e.var),e.varType==="file"){if(typeof n!="string")throw new Error(`The "value" must contain path of a file with "varType":"${e.varType}"`);let t=T.default.resolve(n);n=U(t)}if(typeof n!="object")throw new Error('The content of the "value" must be in the form of key-value pairs. For example: {"KEY_A":"value_a", "KEY_B":"value_b"}');Object.keys(n).forEach(t=>{I(r,t,n[t])})},Te=async(r,e)=>{let n=e.text??"",t=(e.target??"c").trim(),s=e.path;if(t==="c"||t==="console")console.log(n);else{if(!s)throw new Error(`The parameter 'path' is required for a target '${t}'!`);let a=T.default.resolve(s),l=T.default.dirname(a);if(g.default.existsSync(l)||(0,_.mkdirpSync)(l),t=="fa"||t=="file-append"){let c,p;try{p=g.default.openSync(a,"a"),g.default.appendFileSync(p,n,"utf8")}catch(u){c=u}finally{p!==void 0&&g.default.closeSync(p)}if(c)throw c}else g.default.writeFileSync(a,n)}};var V=(r,e)=>{if(r!=null){if(typeof r=="string")return[r];if(Array.isArray(r))return r.filter(n=>typeof n=="string")}return[]},W=(r,e,n)=>{f(`Copy: ${r} => ${e}`),(0,_.copySync)(r,e,n)},ve=async(r,e)=>{if(!g.default.existsSync(e.src))throw new Error(`The source '${e.src}' does not exist`);let n=e?.options?.conflict,t=n==null||typeof n=="string"&&n.trim()==="overwrite";e.options&&"overwrite"in e?.options&&typeof e?.options?.overwrite=="boolean"&&(t=e.options.overwrite);let s={overwrite:t};if(g.default.statSync(e.src).isDirectory()===!1){W(e.src,e.dest,s);return}let a=V(e.include,[]),l=V(e.exclude,[]),c=k=>{for(let w of k){let i=T.default.join(e.src,w),m=T.default.join(e.dest,w);W(i,m,s)}},p=a.length>0,u=l.length>0;!p&&u?c((0,b.globSync)("**",{ignore:l,cwd:e.src})):p&&!u?c((0,b.globSync)(a,{cwd:e.src})):p&&u?c((0,b.globSync)(a,{ignore:l,cwd:e.src})):W(e.src,e.dest,s)},Y=r=>{f(`Delete: ${r}`),(0,_.removeSync)(r)},ke=async(r,e)=>{if(!g.default.existsSync(e.path)){f(`The '${e.path}' does not exist and cannot be deleted`);return}if(g.default.statSync(e.path).isDirectory()===!1){Y(e.path);return}let n=V(e.include,[]),t=V(e.exclude,[]),s=c=>{for(let p of c)Y(T.default.join(e.path,p))},a=n.length>0,l=t.length>0;!a&&l?s((0,b.globSync)("**",{ignore:t,cwd:e.path})):a&&!l?s((0,b.globSync)(n,{cwd:e.path})):a&&l?s((0,b.globSync)(n,{ignore:t,cwd:e.path})):Y(e.path)};var z={"git-repo-prepare":ue,symlink:me,cmd:ye,"set-var":he,output:Te,"fs-copy":ve,"fs-del":ke,"env-var":xe,"sub-tasks":fe};var S=(r,e,n)=>{let t={},s=G.default.resolve(e.config);try{t=K(s)}catch(i){i instanceof Error?console.log(i.message):console.log(i),console.log(""),n.help()}let a,l="info",c=ie;if(t.env&&typeof t.env=="object"){let i=t.env;(i.verbose||i.verboseGit)&&(l="debug"),i.logLevel&&L.includes(i.logLevel)&&(l=i.logLevel),i.replaceRegex&&(c=i.replaceRegex)}if(e.logLevel&&L.includes(e.logLevel)&&(l=e.logLevel),l==="debug"?(a=`${E},${O}`,a=`${a},simple-git,simple-git:*`):l==="info"&&(a=`${E}`),a&&we.default.enable(a),f("CLI Options",e),typeof c!="string")throw new Error(`replaceRegex '${c}'  must be a string`);if(c.length<1)throw new Error(`replaceRegex '${c}' cannot be empty`);if(c.indexOf("(")<0||c.indexOf(")")<0)throw new Error(`replaceRegex '${c}' must contain regex group express '(' and ')'`);let p=G.default.resolve(process.cwd()),u={originCwd:r,baseCwd:p,replaceRegex:new RegExp(c),vars:{__env:{cwd_startup:r,cwd_base:p}}};e.extraArgs&&(f("Setting up the variables from the additional arguments"),H(e.extraArgs,ae,e.camelKeys,(i,m)=>{D(u,i,m)}),f("Setting up the environment variables from the additional arguments"),H(e.extraArgs,le,e.camelKeys,(i,m)=>{I(u,i,m)})),v(""),v(`[${t.name}] Start task processing`);let k=(i,m)=>m!=null?i.id!==void 0?`[${m}]${i.id}/${i.type}`:`[${m}]${i.type}`:i.id!==void 0?`${i.id}/${i.type}`:`${i.type}`;(async()=>{let i=t.tasks??[];for(let d=0;d<i.length;d++){let o=i[d];if(o.id!==void 0&&o.id!==null){if(typeof o.id!="string")throw new Error("The task id must be a 'string' type");if(o.id.length<1)throw new Error("The task id cannot be empty");for(let h=d+1;h<i.length;h++){let y=i[h];if(y.id!==void 0&&y.id===o.id)throw new Error(`The task id '${o.id}' must be unique`)}}if(!o.type||!(o.type in z))throw new Error(`Found the invalid task type '${o.type}'`);if(o.__compare__elements=[],o.id&&(o.id=o.id.trim(),o.__compare__elements.push(o.id.trim())),o.tags){let h=y=>{f(`Ignoring invalid tags '${y}'`)};if(typeof o.tags=="string")o.tags.length>0?(o.tags=o.tags.trim(),o.__compare__elements.push(o.tags)):h(o.tags);else if(Array.isArray(o.tags)){o.tags=o.tags.map(y=>y.trim());for(let y of o.tags)typeof y=="string"&&y.length>0?o.__compare__elements.push(y):h(y)}else h(o.tags)}}if(e.exclude&&e.exclude.length>0){let d=e.exclude;f(`Excluding tasks by specified IDs or Tags : --exclude=${d}`),i=i.filter((o,h,y)=>{if(J(d,o.__compare__elements)===!1)return o})}if(e.excludeCta&&e.excludeCta.length>0){let d=e.excludeCta;f(`Excluding tasks by specified IDs or Tags : --exclude-cta=${d}`),i=i.filter((o,h,y)=>{if(X(d,o.__compare__elements)===!1)return o})}let m=e.include&&e.include.length>0,$=e.includeCta&&e.includeCta.length>0;if(m||$){let d=e.include,o=e.includeCta;f(`Including tasks by specified IDs or Tags : --include=${d} / --include-cta=${o}`),i=i.filter((h,y,Z)=>{if(m&&J(d,h.__compare__elements)===!0||$&&X(o,h.__compare__elements)===!0)return h})}v(`Tasks : ${i.map((d,o)=>k(d,o))}`);let _e=i.length??0;for(let d=0;d<_e;d++){let o=i[d];ce(u,o);let h=k(o,d);if(o.enabled===!1){v(`
### Skip the task without execution => ${h}`);continue}else v(`
### Task : ${h}`);o.comment&&v(o.comment);let y=!1;if(o.cwd){let Q=G.default.resolve(o.cwd);v(`Changing the current working directory => ${Q}`),y=!0,process.chdir(Q)}let Z=z[o.type];await Z(u,o),e.cwdModeIsContinue||(y&&v(`Restoring the current working directory => ${p}`),process.chdir(p))}})().then(()=>{}).catch(i=>{throw i}).finally(()=>{process.chdir(p),v(`[${t.name}] Tasks done
`)})};var Pe=Ce.default.resolve(process.cwd()),be=F();S(Pe,be.opt,be.program);0&&(module.exports={usefulTasks});
//# sourceMappingURL=index.js.map